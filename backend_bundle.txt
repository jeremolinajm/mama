========== FILE: ./backend_debug_bundle.txt ==========

========== FILE: src/main/java/com/flavia/dermobeauty/payment/controller/MercadoPagoWebhookController.java ==========
package com.flavia.dermobeauty.payment.controller;

import com.flavia.dermobeauty.booking.application.usecase.ConfirmBookingPaymentUseCase;
import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.domain.BookingRepository;
import com.flavia.dermobeauty.sales.application.usecase.ConfirmOrderPaymentUseCase;
import com.flavia.dermobeauty.sales.domain.Order;
import com.flavia.dermobeauty.sales.domain.OrderRepository;
import com.mercadopago.client.payment.PaymentClient;
import com.mercadopago.exceptions.MPApiException;
import com.mercadopago.exceptions.MPException;
import com.mercadopago.resources.payment.Payment;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

/**
 * Controller for Mercado Pago webhook notifications.
 * Handles payment status updates from Mercado Pago.
 *
 * CRITICAL: This endpoint must be publicly accessible (no authentication).
 * Mercado Pago sends IPN notifications here when payment status changes.
 */
@Slf4j
@RestController
@RequestMapping("/api/mp")
@RequiredArgsConstructor
public class MercadoPagoWebhookController {

    private final BookingRepository bookingRepository;
    private final OrderRepository orderRepository;
    private final ConfirmBookingPaymentUseCase confirmBookingPaymentUseCase;
    private final ConfirmOrderPaymentUseCase confirmOrderPaymentUseCase;
    private final PaymentClient paymentClient = new PaymentClient();

    @PostMapping("/webhook")
    public ResponseEntity<Void> handleWebhook(@RequestBody Map<String, Object> payload) {
        try {
            log.info("Received MP webhook: {}", payload);

            String type = (String) payload.get("type");

            if (!"payment".equals(type)) {
                log.debug("Ignoring non-payment notification: {}", type);
                return ResponseEntity.ok().build();
            }

            Map<String, Object> data = (Map<String, Object>) payload.get("data");
            if (data == null) {
                log.warn("Webhook data is null");
                return ResponseEntity.ok().build();
            }

            String paymentIdStr = (String) data.get("id");
            if (paymentIdStr == null) {
                log.warn("Payment ID is null in webhook data");
                return ResponseEntity.ok().build();
            }

            Long paymentId = Long.parseLong(paymentIdStr);
            log.info("Processing payment notification for payment ID: {}", paymentId);

            // Fetch payment details from Mercado Pago
            Payment payment = paymentClient.get(paymentId);
            log.info("Payment status: {}, External reference: {}",
                    payment.getStatus(), payment.getExternalReference());

            // Only process approved payments
            if (!"approved".equals(payment.getStatus())) {
                log.info("Payment {} not approved yet (status: {}), skipping confirmation",
                        paymentId, payment.getStatus());
                return ResponseEntity.ok().build();
            }

            String externalReference = payment.getExternalReference();
            if (externalReference == null) {
                log.warn("External reference is null for payment {}", paymentId);
                return ResponseEntity.ok().build();
            }

            // Update payment ID in booking/order and confirm
            if (externalReference.startsWith("BOOKING-")) {
                confirmBookingPayment(externalReference, String.valueOf(paymentId));
            } else if (externalReference.startsWith("ORDER-")) {
                confirmOrderPayment(externalReference, String.valueOf(paymentId));
            } else {
                log.warn("Unknown external reference format: {}", externalReference);
            }

            return ResponseEntity.ok().build();

        } catch (MPApiException e) {
            log.error("MP API error processing webhook: {} - {}", e.getStatusCode(), e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.OK).build(); // Always return 200 to MP
        } catch (MPException e) {
            log.error("MP error processing webhook: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.OK).build();
        } catch (Exception e) {
            log.error("Unexpected error processing webhook", e);
            return ResponseEntity.status(HttpStatus.OK).build(); // Always return 200 to MP
        }
    }

    private void confirmBookingPayment(String externalReference, String paymentId) {
        try {
            String bookingNumber = externalReference.replace("BOOKING-", "");
            log.info("Confirming payment for booking: {}", bookingNumber);

            // Find booking and update payment ID first
            Booking booking = bookingRepository.findByBookingNumber(bookingNumber)
                    .orElseThrow(() -> new RuntimeException("Booking not found: " + bookingNumber));

            // Update booking with payment ID
            Booking updatedBooking = Booking.builder()
                    .id(booking.getId())
                    .bookingNumber(booking.getBookingNumber())
                    .serviceId(booking.getServiceId())
                    .customerInfo(booking.getCustomerInfo())
                    .timeSlot(booking.getTimeSlot())
                    .durationMinutes(booking.getDurationMinutes())
                    .status(booking.getStatus())
                    .paymentStatus(booking.getPaymentStatus())
                    .mercadoPagoPreferenceId(booking.getMercadoPagoPreferenceId())
                    .mercadoPagoPaymentId(paymentId)
                    .amount(booking.getAmount())
                    .createdAt(booking.getCreatedAt())
                    .updatedAt(booking.getUpdatedAt())
                    .confirmedAt(booking.getConfirmedAt())
                    .cancelledAt(booking.getCancelledAt())
                    .build();

            bookingRepository.save(updatedBooking);

            // Confirm payment via use case
            confirmBookingPaymentUseCase.execute(paymentId);
            log.info("Booking payment confirmed successfully: {}", bookingNumber);

        } catch (Exception e) {
            log.error("Error confirming booking payment", e);
            throw new RuntimeException("Error confirming booking payment", e);
        }
    }

    private void confirmOrderPayment(String externalReference, String paymentId) {
        try {
            String orderNumber = externalReference.replace("ORDER-", "");
            log.info("Confirming payment for order: {}", orderNumber);

            // Find order and update payment ID first
            Order order = orderRepository.findByOrderNumber(orderNumber)
                    .orElseThrow(() -> new RuntimeException("Order not found: " + orderNumber));

            // Update order with payment ID
            Order updatedOrder = Order.builder()
                    .id(order.getId())
                    .orderNumber(order.getOrderNumber())
                    .customerInfo(order.getCustomerInfo())
                    .deliveryInfo(order.getDeliveryInfo())
                    .items(order.getItems())
                    .subtotal(order.getSubtotal())
                    .deliveryCost(order.getDeliveryCost())
                    .total(order.getTotal())
                    .status(order.getStatus())
                    .paymentStatus(order.getPaymentStatus())
                    .mercadoPagoPreferenceId(order.getMercadoPagoPreferenceId())
                    .mercadoPagoPaymentId(paymentId)
                    .createdAt(order.getCreatedAt())
                    .updatedAt(order.getUpdatedAt())
                    .build();

            orderRepository.save(updatedOrder);

            // Confirm payment via use case (decrements stock, sends email)
            confirmOrderPaymentUseCase.execute(paymentId);
            log.info("Order payment confirmed successfully: {}", orderNumber);

        } catch (Exception e) {
            log.error("Error confirming order payment", e);
            throw new RuntimeException("Error confirming order payment", e);
        }
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/payment/controller/PaymentController.java ==========
package com.flavia.dermobeauty.payment.controller;

import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.domain.BookingRepository;
import com.flavia.dermobeauty.payment.dto.PaymentPreferenceResponse;
import com.flavia.dermobeauty.payment.service.MercadoPagoClient;
import com.flavia.dermobeauty.sales.domain.Order;
import com.flavia.dermobeauty.sales.domain.OrderRepository;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

/**
 * Controller for payment preference creation.
 * Public endpoints to initiate payment for bookings and orders.
 */
@Slf4j
@RestController
@RequestMapping("/api/public/payments")
@RequiredArgsConstructor
public class PaymentController {

    private final MercadoPagoClient mercadoPagoClient;
    private final BookingRepository bookingRepository;
    private final OrderRepository orderRepository;

    @PostMapping("/bookings/{bookingId}/preference")
    public ResponseEntity<ApiResponse<PaymentPreferenceResponse>> createBookingPreference(
            @PathVariable Long bookingId) {

        log.info("Creating payment preference for booking: {}", bookingId);

        Booking booking = bookingRepository.findById(bookingId)
                .orElseThrow(() -> new ResourceNotFoundException("Booking", bookingId));

        String preferenceId = mercadoPagoClient.createPreferenceForBooking(booking);

        // Update booking with preference ID
        Booking updatedBooking = Booking.builder()
                .id(booking.getId())
                .bookingNumber(booking.getBookingNumber())
                .serviceId(booking.getServiceId())
                .customerInfo(booking.getCustomerInfo())
                .timeSlot(booking.getTimeSlot())
                .durationMinutes(booking.getDurationMinutes())
                .status(booking.getStatus())
                .paymentStatus(booking.getPaymentStatus())
                .mercadoPagoPreferenceId(preferenceId)
                .mercadoPagoPaymentId(booking.getMercadoPagoPaymentId())
                .amount(booking.getAmount())
                .createdAt(booking.getCreatedAt())
                .updatedAt(booking.getUpdatedAt())
                .confirmedAt(booking.getConfirmedAt())
                .cancelledAt(booking.getCancelledAt())
                .build();

        bookingRepository.save(updatedBooking);

        PaymentPreferenceResponse response = new PaymentPreferenceResponse(
                preferenceId,
                "https://www.mercadopago.com.ar/checkout/v1/redirect?pref_id=" + preferenceId
        );

        return ResponseEntity.ok(ApiResponse.success(response, "Payment preference created"));
    }

    @PostMapping("/orders/{orderId}/preference")
    public ResponseEntity<ApiResponse<PaymentPreferenceResponse>> createOrderPreference(
            @PathVariable Long orderId) {

        log.info("Creating payment preference for order: {}", orderId);

        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new ResourceNotFoundException("Order", orderId));

        String preferenceId = mercadoPagoClient.createPreferenceForOrder(order);

        // Update order with preference ID
        Order updatedOrder = Order.builder()
                .id(order.getId())
                .orderNumber(order.getOrderNumber())
                .customerInfo(order.getCustomerInfo())
                .deliveryInfo(order.getDeliveryInfo())
                .items(order.getItems())
                .subtotal(order.getSubtotal())
                .deliveryCost(order.getDeliveryCost())
                .total(order.getTotal())
                .status(order.getStatus())
                .paymentStatus(order.getPaymentStatus())
                .mercadoPagoPreferenceId(preferenceId)
                .mercadoPagoPaymentId(order.getMercadoPagoPaymentId())
                .createdAt(order.getCreatedAt())
                .updatedAt(order.getUpdatedAt())
                .build();

        orderRepository.save(updatedOrder);

        PaymentPreferenceResponse response = new PaymentPreferenceResponse(
                preferenceId,
                "https://www.mercadopago.com.ar/checkout/v1/redirect?pref_id=" + preferenceId
        );

        return ResponseEntity.ok(ApiResponse.success(response, "Payment preference created"));
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/catalog/dto/CategoryDto.java ==========
package com.flavia.dermobeauty.catalog.dto;

import com.flavia.dermobeauty.catalog.entity.CategoryEntity;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO for category data transfer.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CategoryDto {

    private Long id;
    private String name;
    private String slug;
    private String description;
    private CategoryEntity.CategoryType type;

    public static CategoryDto fromEntity(CategoryEntity entity) {
        return CategoryDto.builder()
                .id(entity.getId())
                .name(entity.getName())
                .slug(entity.getSlug())
                .description(entity.getDescription())
                .type(entity.getType())
                .build();
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/catalog/dto/ServiceDto.java ==========
package com.flavia.dermobeauty.catalog.dto;

import com.flavia.dermobeauty.catalog.entity.ServiceEntity;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

/**
 * DTO for service data transfer with validation.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ServiceDto {

    private Long id;

    @NotBlank(message = "Name is required")
    private String name;

    private String slug;

    @NotBlank(message = "Description is required")
    private String description;

    private String shortDescription;

    @NotNull(message = "Duration is required")
    @Min(value = 1, message = "Duration must be at least 1 minute")
    private Integer durationMinutes;

    @NotNull(message = "Price is required")
    @DecimalMin(value = "0.0", inclusive = false, message = "Price must be greater than 0")
    private BigDecimal price;

    @NotNull(message = "Category ID is required")
    private Long categoryId;

    private String categoryName;

    private String imageUrl;

    private Boolean isFeatured;

    private Boolean isActive;

    public static ServiceDto fromEntity(ServiceEntity entity) {
        return ServiceDto.builder()
                .id(entity.getId())
                .name(entity.getName())
                .slug(entity.getSlug())
                .description(entity.getDescription())
                .shortDescription(entity.getShortDescription())
                .durationMinutes(entity.getDurationMinutes())
                .price(entity.getPrice())
                .categoryId(entity.getCategory().getId())
                .categoryName(entity.getCategory().getName())
                .imageUrl(entity.getImageUrl())
                .isFeatured(entity.getIsFeatured())
                .isActive(entity.getIsActive())
                .build();
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/catalog/dto/ProductDto.java ==========
package com.flavia.dermobeauty.catalog.dto;

import com.flavia.dermobeauty.catalog.entity.ProductEntity;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

/**
 * DTO for product data transfer with validation.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProductDto {

    private Long id;

    @NotBlank(message = "Name is required")
    private String name;

    private String slug;

    @NotBlank(message = "Description is required")
    private String description;

    private String shortDescription;

    @NotNull(message = "Price is required")
    @DecimalMin(value = "0.0", inclusive = false, message = "Price must be greater than 0")
    private BigDecimal price;

    @NotNull(message = "Stock is required")
    @Min(value = 0, message = "Stock cannot be negative")
    private Integer stock;

    @NotNull(message = "Category ID is required")
    private Long categoryId;

    private String categoryName;

    private String imageUrl;

    private Boolean isFeatured;

    private Boolean isOffer;

    private Boolean isTrending;

    private Boolean isActive;

    public static ProductDto fromEntity(ProductEntity entity) {
        return ProductDto.builder()
                .id(entity.getId())
                .name(entity.getName())
                .slug(entity.getSlug())
                .description(entity.getDescription())
                .shortDescription(entity.getShortDescription())
                .price(entity.getPrice())
                .stock(entity.getStock())
                .categoryId(entity.getCategory().getId())
                .categoryName(entity.getCategory().getName())
                .imageUrl(entity.getImageUrl())
                .isFeatured(entity.getIsFeatured())
                .isOffer(entity.getIsOffer())
                .isTrending(entity.getIsTrending())
                .isActive(entity.getIsActive())
                .build();
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/catalog/repository/ProductRepository.java ==========
package com.flavia.dermobeauty.catalog.repository;

import com.flavia.dermobeauty.catalog.entity.ProductEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

/**
 * Repository for product operations with custom queries for filtering.
 */
@Repository
public interface ProductRepository extends JpaRepository<ProductEntity, Long> {

    Optional<ProductEntity> findBySlug(String slug);

    List<ProductEntity> findByIsActiveTrueOrderByCreatedAtDesc();

    List<ProductEntity> findByIsFeaturedTrueAndIsActiveTrueOrderByCreatedAtDesc();

    List<ProductEntity> findByIsOfferTrueAndIsActiveTrueOrderByCreatedAtDesc();

    List<ProductEntity> findByIsTrendingTrueAndIsActiveTrueOrderByCreatedAtDesc();

    @Query("SELECT p FROM ProductEntity p WHERE p.category.id = :categoryId AND p.isActive = true ORDER BY p.createdAt DESC")
    List<ProductEntity> findByCategoryIdAndIsActiveTrue(@Param("categoryId") Long categoryId);

    @Modifying(clearAutomatically = true)
    @Query("UPDATE ProductEntity p SET p.stock = p.stock - :quantity WHERE p.id = :id AND p.stock >= :quantity")
    int decrementStock(@Param("id") Long id, @Param("quantity") Integer quantity);

}

========== FILE: src/main/java/com/flavia/dermobeauty/catalog/repository/ServiceRepository.java ==========
package com.flavia.dermobeauty.catalog.repository;

import com.flavia.dermobeauty.catalog.entity.ServiceEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

/**
 * Repository for service operations with custom queries for filtering.
 */
@Repository
public interface ServiceRepository extends JpaRepository<ServiceEntity, Long> {

    Optional<ServiceEntity> findBySlug(String slug);

    List<ServiceEntity> findByIsActiveTrueOrderByCreatedAtDesc();

    List<ServiceEntity> findByIsFeaturedTrueAndIsActiveTrueOrderByCreatedAtDesc();

    @Query("SELECT s FROM ServiceEntity s WHERE s.category.id = :categoryId AND s.isActive = true ORDER BY s.createdAt DESC")
    List<ServiceEntity> findByCategoryIdAndIsActiveTrue(@Param("categoryId") Long categoryId);
}

========== FILE: src/main/java/com/flavia/dermobeauty/catalog/repository/CategoryRepository.java ==========
package com.flavia.dermobeauty.catalog.repository;

import com.flavia.dermobeauty.catalog.entity.CategoryEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

/**
 * Repository for category operations.
 */
@Repository
public interface CategoryRepository extends JpaRepository<CategoryEntity, Long> {

    Optional<CategoryEntity> findBySlug(String slug);

    List<CategoryEntity> findByType(CategoryEntity.CategoryType type);
}

========== FILE: src/main/java/com/flavia/dermobeauty/catalog/entity/CategoryEntity.java ==========
package com.flavia.dermobeauty.catalog.entity;

import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDateTime;

/**
 * JPA entity for categories table.
 * Categories are used to organize both services and products.
 */
@Entity
@Table(name = "categories")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CategoryEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(nullable = false, unique = true, length = 100)
    private String slug;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private CategoryType type;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }

    public enum CategoryType {
        SERVICE, PRODUCT
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/catalog/entity/ProductEntity.java ==========
package com.flavia.dermobeauty.catalog.entity;

import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * JPA entity for products table.
 * Represents beauty/dermatology products for sale.
 */
@Entity
@Table(name = "products")
@Getter@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProductEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 200)
    private String name;

    @Column(nullable = false, unique = true, length = 200)
    private String slug;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Column(name = "short_description", length = 500)
    private String shortDescription;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal price;

    @Column(nullable = false)
    private Integer stock = 0;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id", nullable = false)
    @ToString.Exclude
    private CategoryEntity category;

    @Column(name = "image_url", length = 500)
    private String imageUrl;

    @Column(name = "is_featured", nullable = false)
    private Boolean isFeatured = false;

    @Column(name = "is_offer", nullable = false)
    private Boolean isOffer = false;

    @Column(name = "is_trending", nullable = false)
    private Boolean isTrending = false;

    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/catalog/entity/ServiceEntity.java ==========
package com.flavia.dermobeauty.catalog.entity;

import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * JPA entity for services table.
 * Represents professional services offered (e.g., facial treatments, peels).
 */
@Entity
@Table(name = "services")
@Getter@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ServiceEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 200)
    private String name;

    @Column(nullable = false, unique = true, length = 200)
    private String slug;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Column(name = "short_description", length = 500)
    private String shortDescription;

    @Column(name = "duration_minutes", nullable = false)
    private Integer durationMinutes;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal price;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id", nullable = false)
    @ToString.Exclude
    private CategoryEntity category;

    @Column(name = "image_url", length = 500)
    private String imageUrl;

    @Column(name = "is_featured", nullable = false)
    private Boolean isFeatured = false;

    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/catalog/service/ProductCatalogService.java ==========
package com.flavia.dermobeauty.catalog.service;

import com.flavia.dermobeauty.catalog.dto.ProductDto;
import com.flavia.dermobeauty.catalog.entity.CategoryEntity;
import com.flavia.dermobeauty.catalog.entity.ProductEntity;
import com.flavia.dermobeauty.catalog.repository.CategoryRepository;
import com.flavia.dermobeauty.catalog.repository.ProductRepository;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Service for managing product catalog operations.
 * Provides CRUD operations for beauty/dermatology products.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class ProductCatalogService {

    private final ProductRepository productRepository;
    private final CategoryRepository categoryRepository;

    @Transactional(readOnly = true)
    public List<ProductDto> getAllActive() {
        log.debug("Fetching all active products");
        return productRepository.findByIsActiveTrueOrderByCreatedAtDesc()
                .stream()
                .map(ProductDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<ProductDto> getAllForAdmin() {
        log.debug("Fetching all products for admin");
        // Usamos findAll() estándar de JPA para traer todo
        return productRepository.findAll()
                .stream()
                .map(ProductDto::fromEntity)
                // Ordenamos por ID o fecha para que no salten en la tabla
                .sorted((a, b) -> b.getId().compareTo(a.getId()))
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<ProductDto> getFeatured() {
        log.debug("Fetching featured products");
        return productRepository.findByIsFeaturedTrueAndIsActiveTrueOrderByCreatedAtDesc()
                .stream()
                .map(ProductDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<ProductDto> getOffers() {
        log.debug("Fetching products on offer");
        return productRepository.findByIsOfferTrueAndIsActiveTrueOrderByCreatedAtDesc()
                .stream()
                .map(ProductDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<ProductDto> getTrending() {
        log.debug("Fetching trending products");
        return productRepository.findByIsTrendingTrueAndIsActiveTrueOrderByCreatedAtDesc()
                .stream()
                .map(ProductDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public ProductDto getById(Long id) {
        log.debug("Fetching product by id: {}", id);
        ProductEntity entity = productRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Product", id));
        return ProductDto.fromEntity(entity);
    }

    @Transactional(readOnly = true)
    public ProductDto getBySlug(String slug) {
        log.debug("Fetching product by slug: {}", slug);
        ProductEntity entity = productRepository.findBySlug(slug)
                .orElseThrow(() -> new ResourceNotFoundException("Product with slug '" + slug + "' not found"));
        return ProductDto.fromEntity(entity);
    }

    @Transactional(readOnly = true)
    public List<ProductDto> getByCategory(Long categoryId) {
        log.debug("Fetching products by category: {}", categoryId);
        return productRepository.findByCategoryIdAndIsActiveTrue(categoryId)
                .stream()
                .map(ProductDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional
    public ProductDto create(ProductDto dto) {
        log.info("Creating new product: {}", dto.getName());

        CategoryEntity category = categoryRepository.findById(dto.getCategoryId())
                .orElseThrow(() -> new ResourceNotFoundException("Category", dto.getCategoryId()));

        ProductEntity entity = ProductEntity.builder()
                .name(dto.getName())
                .slug(generateSlug(dto.getName()))
                .description(dto.getDescription())
                .shortDescription(dto.getShortDescription())
                .price(dto.getPrice())
                .stock(dto.getStock() != null ? dto.getStock() : 0)
                .category(category)
                .imageUrl(dto.getImageUrl())
                .isFeatured(dto.getIsFeatured() != null ? dto.getIsFeatured() : false)
                .isOffer(dto.getIsOffer() != null ? dto.getIsOffer() : false)
                .isTrending(dto.getIsTrending() != null ? dto.getIsTrending() : false)
                .isActive(dto.getIsActive() != null ? dto.getIsActive() : true)
                .build();

        ProductEntity saved = productRepository.save(entity);
        return ProductDto.fromEntity(saved);
    }

    @Transactional
    public ProductDto update(Long id, ProductDto dto) {
        log.info("Updating product: {}", id);

        ProductEntity entity = productRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Product", id));

        if (dto.getCategoryId() != null && !dto.getCategoryId().equals(entity.getCategory().getId())) {
            CategoryEntity category = categoryRepository.findById(dto.getCategoryId())
                    .orElseThrow(() -> new ResourceNotFoundException("Category", dto.getCategoryId()));
            entity.setCategory(category);
        }

        entity.setName(dto.getName());
        entity.setDescription(dto.getDescription());
        entity.setShortDescription(dto.getShortDescription());
        entity.setPrice(dto.getPrice());
        entity.setStock(dto.getStock());
        entity.setImageUrl(dto.getImageUrl());
        entity.setIsFeatured(dto.getIsFeatured());
        entity.setIsOffer(dto.getIsOffer());
        entity.setIsTrending(dto.getIsTrending());
        entity.setIsActive(dto.getIsActive());

        ProductEntity updated = productRepository.save(entity);
        return ProductDto.fromEntity(updated);
    }

    @Transactional
    public void delete(Long id) {
        log.info("Deleting product: {}", id);
        if (!productRepository.existsById(id)) {
            throw new ResourceNotFoundException("Product", id);
        }
        productRepository.deleteById(id);
    }

    private String generateSlug(String name) {
        return name.toLowerCase()
                .replaceAll("[^a-z0-9\\s-]", "")
                .replaceAll("\\s+", "-")
                .replaceAll("-+", "-");
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/catalog/service/ServiceCatalogService.java ==========
package com.flavia.dermobeauty.catalog.service;

import com.flavia.dermobeauty.catalog.dto.ServiceDto;
import com.flavia.dermobeauty.catalog.entity.CategoryEntity;
import com.flavia.dermobeauty.catalog.entity.ServiceEntity;
import com.flavia.dermobeauty.catalog.repository.CategoryRepository;
import com.flavia.dermobeauty.catalog.repository.ServiceRepository;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Service for managing service catalog operations.
 * Provides CRUD operations for beauty/dermatology services.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class ServiceCatalogService {

    private final ServiceRepository serviceRepository;
    private final CategoryRepository categoryRepository;

    @Transactional(readOnly = true)
    public List<ServiceDto> getAllActive() {
        log.debug("Fetching all active services");
        return serviceRepository.findByIsActiveTrueOrderByCreatedAtDesc()
                .stream()
                .map(ServiceDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<ServiceDto> getAllForAdmin() {
        log.debug("Fetching all services for admin");
        return serviceRepository.findAll()
                .stream()
                .map(ServiceDto::fromEntity)
                .sorted((a, b) -> b.getId().compareTo(a.getId()))
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<ServiceDto> getFeatured() {
        log.debug("Fetching featured services");
        return serviceRepository.findByIsFeaturedTrueAndIsActiveTrueOrderByCreatedAtDesc()
                .stream()
                .map(ServiceDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public ServiceDto getById(Long id) {
        log.debug("Fetching service by id: {}", id);
        ServiceEntity entity = serviceRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Service", id));
        return ServiceDto.fromEntity(entity);
    }

    @Transactional(readOnly = true)
    public ServiceDto getBySlug(String slug) {
        log.debug("Fetching service by slug: {}", slug);
        ServiceEntity entity = serviceRepository.findBySlug(slug)
                .orElseThrow(() -> new ResourceNotFoundException("Service with slug '" + slug + "' not found"));
        return ServiceDto.fromEntity(entity);
    }

    @Transactional(readOnly = true)
    public List<ServiceDto> getByCategory(Long categoryId) {
        log.debug("Fetching services by category: {}", categoryId);
        return serviceRepository.findByCategoryIdAndIsActiveTrue(categoryId)
                .stream()
                .map(ServiceDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional
    public ServiceDto create(ServiceDto dto) {
        log.info("Creating new service: {}", dto.getName());

        CategoryEntity category = categoryRepository.findById(dto.getCategoryId())
                .orElseThrow(() -> new ResourceNotFoundException("Category", dto.getCategoryId()));

        ServiceEntity entity = ServiceEntity.builder()
                .name(dto.getName())
                .slug(generateSlug(dto.getName()))
                .description(dto.getDescription())
                .shortDescription(dto.getShortDescription())
                .durationMinutes(dto.getDurationMinutes())
                .price(dto.getPrice())
                .category(category)
                .imageUrl(dto.getImageUrl())
                .isFeatured(dto.getIsFeatured() != null ? dto.getIsFeatured() : false)
                .isActive(dto.getIsActive() != null ? dto.getIsActive() : true)
                .build();

        ServiceEntity saved = serviceRepository.save(entity);
        return ServiceDto.fromEntity(saved);
    }

    @Transactional
    public ServiceDto update(Long id, ServiceDto dto) {
        log.info("Updating service: {}", id);

        ServiceEntity entity = serviceRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Service", id));

        if (dto.getCategoryId() != null && !dto.getCategoryId().equals(entity.getCategory().getId())) {
            CategoryEntity category = categoryRepository.findById(dto.getCategoryId())
                    .orElseThrow(() -> new ResourceNotFoundException("Category", dto.getCategoryId()));
            entity.setCategory(category);
        }

        entity.setName(dto.getName());
        entity.setDescription(dto.getDescription());
        entity.setShortDescription(dto.getShortDescription());
        entity.setDurationMinutes(dto.getDurationMinutes());
        entity.setPrice(dto.getPrice());
        entity.setImageUrl(dto.getImageUrl());
        entity.setIsFeatured(dto.getIsFeatured());
        entity.setIsActive(dto.getIsActive());

        ServiceEntity updated = serviceRepository.save(entity);
        return ServiceDto.fromEntity(updated);
    }

    @Transactional
    public void delete(Long id) {
        log.info("Deleting service: {}", id);
        if (!serviceRepository.existsById(id)) {
            throw new ResourceNotFoundException("Service", id);
        }
        serviceRepository.deleteById(id);
    }

    private String generateSlug(String name) {
        return name.toLowerCase()
                .replaceAll("[^a-z0-9\\s-]", "")
                .replaceAll("\\s+", "-")
                .replaceAll("-+", "-");
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/catalog/controller/ProductController.java ==========
package com.flavia.dermobeauty.catalog.controller;

import com.flavia.dermobeauty.catalog.dto.ProductDto;
import com.flavia.dermobeauty.catalog.service.ProductCatalogService;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * Public REST controller for product catalog operations.
 * Provides endpoints for browsing available products.
 */
@RestController
@RequestMapping("/api/public/products")
@RequiredArgsConstructor
public class ProductController {

    private final ProductCatalogService productCatalogService;

    @GetMapping
    public ResponseEntity<ApiResponse<List<ProductDto>>> getAllProducts() {
        List<ProductDto> products = productCatalogService.getAllActive();
        return ResponseEntity.ok(ApiResponse.success(products));
    }

    @GetMapping("/featured")
    public ResponseEntity<ApiResponse<List<ProductDto>>> getFeaturedProducts() {
        List<ProductDto> products = productCatalogService.getFeatured();
        return ResponseEntity.ok(ApiResponse.success(products));
    }

    @GetMapping("/offers")
    public ResponseEntity<ApiResponse<List<ProductDto>>> getOfferProducts() {
        List<ProductDto> products = productCatalogService.getOffers();
        return ResponseEntity.ok(ApiResponse.success(products));
    }

    @GetMapping("/trending")
    public ResponseEntity<ApiResponse<List<ProductDto>>> getTrendingProducts() {
        List<ProductDto> products = productCatalogService.getTrending();
        return ResponseEntity.ok(ApiResponse.success(products));
    }

    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<ProductDto>> getProductById(@PathVariable Long id) {
        ProductDto product = productCatalogService.getById(id);
        return ResponseEntity.ok(ApiResponse.success(product));
    }

    @GetMapping("/slug/{slug}")
    public ResponseEntity<ApiResponse<ProductDto>> getProductBySlug(@PathVariable String slug) {
        ProductDto product = productCatalogService.getBySlug(slug);
        return ResponseEntity.ok(ApiResponse.success(product));
    }

    @GetMapping("/category/{categoryId}")
    public ResponseEntity<ApiResponse<List<ProductDto>>> getProductsByCategory(@PathVariable Long categoryId) {
        List<ProductDto> products = productCatalogService.getByCategory(categoryId);
        return ResponseEntity.ok(ApiResponse.success(products));
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/catalog/controller/AdminCatalogController.java ==========
package com.flavia.dermobeauty.catalog.controller;

import com.flavia.dermobeauty.catalog.dto.CategoryDto;
import com.flavia.dermobeauty.catalog.dto.ProductDto;
import com.flavia.dermobeauty.catalog.dto.ServiceDto;
import com.flavia.dermobeauty.catalog.entity.CategoryEntity;
import com.flavia.dermobeauty.catalog.repository.CategoryRepository;
import com.flavia.dermobeauty.catalog.service.ProductCatalogService;
import com.flavia.dermobeauty.catalog.service.ServiceCatalogService;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

@Slf4j
@RestController
@RequestMapping("/api/admin")
@RequiredArgsConstructor
public class AdminCatalogController {

    private final ServiceCatalogService serviceService;
    private final ProductCatalogService productService;
    private final CategoryRepository categoryRepository;

    // ==================== SERVICES ====================

    @GetMapping("/services")
    public ResponseEntity<ApiResponse<List<ServiceDto>>> getAllServices() {
        return ResponseEntity.ok(ApiResponse.success(serviceService.getAllForAdmin()));
    }

    @GetMapping("/services/{id}")
    public ResponseEntity<ApiResponse<ServiceDto>> getService(@PathVariable Long id) {
        return ResponseEntity.ok(ApiResponse.success(serviceService.getById(id)));
    }

    @PostMapping("/services")
    public ResponseEntity<ApiResponse<ServiceDto>> createService(@Valid @RequestBody ServiceDto dto) {
        return ResponseEntity.ok(ApiResponse.success(serviceService.create(dto), "Servicio creado"));
    }

    @PutMapping("/services/{id}")
    public ResponseEntity<ApiResponse<ServiceDto>> updateService(@PathVariable Long id, @Valid @RequestBody ServiceDto dto) {
        return ResponseEntity.ok(ApiResponse.success(serviceService.update(id, dto), "Servicio actualizado"));
    }

    @DeleteMapping("/services/{id}")
    public ResponseEntity<ApiResponse<Void>> deleteService(@PathVariable Long id) {
        serviceService.delete(id);
        return ResponseEntity.ok(ApiResponse.success("Servicio eliminado"));
    }

    @PatchMapping("/services/{id}/featured")
    public ResponseEntity<ApiResponse<ServiceDto>> toggleServiceFeatured(@PathVariable Long id) {
        // Obtenemos actual, invertimos flag y guardamos
        ServiceDto current = serviceService.getById(id);
        current.setIsFeatured(!current.getIsFeatured());
        return ResponseEntity.ok(ApiResponse.success(serviceService.update(id, current)));
    }

    // ==================== PRODUCTS ====================

    @GetMapping("/products")
    public ResponseEntity<ApiResponse<List<ProductDto>>> getAllProducts() {
        return ResponseEntity.ok(ApiResponse.success(productService.getAllForAdmin()));
    }

    @GetMapping("/products/{id}")
    public ResponseEntity<ApiResponse<ProductDto>> getProduct(@PathVariable Long id) {
        return ResponseEntity.ok(ApiResponse.success(productService.getById(id)));
    }

    @PostMapping("/products")
    public ResponseEntity<ApiResponse<ProductDto>> createProduct(@Valid @RequestBody ProductDto dto) {
        return ResponseEntity.ok(ApiResponse.success(productService.create(dto), "Producto creado"));
    }

    @PutMapping("/products/{id}")
    public ResponseEntity<ApiResponse<ProductDto>> updateProduct(@PathVariable Long id, @Valid @RequestBody ProductDto dto) {
        return ResponseEntity.ok(ApiResponse.success(productService.update(id, dto), "Producto actualizado"));
    }

    @DeleteMapping("/products/{id}")
    public ResponseEntity<ApiResponse<Void>> deleteProduct(@PathVariable Long id) {
        productService.delete(id);
        return ResponseEntity.ok(ApiResponse.success("Producto eliminado"));
    }

    @PatchMapping("/products/{id}/featured")
    public ResponseEntity<ApiResponse<ProductDto>> toggleProductFeatured(@PathVariable Long id) {
        ProductDto current = productService.getById(id);
        current.setIsFeatured(!current.getIsFeatured());
        return ResponseEntity.ok(ApiResponse.success(productService.update(id, current)));
    }

    // ==================== CATEGORIES ====================

    @GetMapping("/categories")
    public ResponseEntity<ApiResponse<List<CategoryDto>>> getAllCategories() {
        List<CategoryDto> categories = categoryRepository.findAll().stream()
                .map(CategoryDto::fromEntity)
                .collect(Collectors.toList());
        return ResponseEntity.ok(ApiResponse.success(categories));
    }

    @PostMapping("/categories")
    public ResponseEntity<ApiResponse<CategoryDto>> createCategory(@RequestBody CategoryEntity category) {
        // Simplificación: Guardamos directo la entidad (mejorar con DTO/Service en futuro)
        // Generar slug simple
        category.setSlug(category.getName().toLowerCase().replace(" ", "-"));
        CategoryEntity saved = categoryRepository.save(category);
        return ResponseEntity.ok(ApiResponse.success(CategoryDto.fromEntity(saved)));
    }

    @DeleteMapping("/categories/{id}")
    public ResponseEntity<ApiResponse<Void>> deleteCategory(@PathVariable Long id) {
        categoryRepository.deleteById(id);
        return ResponseEntity.ok(ApiResponse.success("Categoría eliminada"));
    }
}
========== FILE: src/main/java/com/flavia/dermobeauty/catalog/controller/CategoryController.java ==========
package com.flavia.dermobeauty.catalog.controller;

import com.flavia.dermobeauty.catalog.dto.CategoryDto;
import com.flavia.dermobeauty.catalog.entity.CategoryEntity;
import com.flavia.dermobeauty.catalog.repository.CategoryRepository;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Public REST controller for category operations.
 * Provides endpoints for browsing categories.
 */
@RestController
@RequestMapping("/api/public/categories")
@RequiredArgsConstructor
public class CategoryController {

    private final CategoryRepository categoryRepository;

    @GetMapping
    public ResponseEntity<ApiResponse<List<CategoryDto>>> getAllCategories() {
        List<CategoryDto> categories = categoryRepository.findAll()
                .stream()
                .map(CategoryDto::fromEntity)
                .collect(Collectors.toList());
        return ResponseEntity.ok(ApiResponse.success(categories));
    }

    @GetMapping("/type/{type}")
    public ResponseEntity<ApiResponse<List<CategoryDto>>> getCategoriesByType(@PathVariable CategoryEntity.CategoryType type) {
        List<CategoryDto> categories = categoryRepository.findByType(type)
                .stream()
                .map(CategoryDto::fromEntity)
                .collect(Collectors.toList());
        return ResponseEntity.ok(ApiResponse.success(categories));
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/catalog/controller/FileUploadController.java ==========
package com.flavia.dermobeauty.catalog.controller;

import com.flavia.dermobeauty.shared.exception.ValidationException;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.net.MalformedURLException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;

/**
 * Controller for file upload and retrieval.
 * Handles image uploads for services and products.
 */
@Slf4j
@RestController
@RequestMapping("/api")
public class FileUploadController {

    private static final List<String> ALLOWED_CONTENT_TYPES = Arrays.asList(
            "image/jpeg", "image/jpg", "image/png", "image/webp"
    );
    private static final long MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB

    private final Path uploadPath;

    public FileUploadController(@Value("${app.upload-dir}") String uploadDir) {
        this.uploadPath = Paths.get(uploadDir).toAbsolutePath().normalize();
        try {
            Files.createDirectories(this.uploadPath);
            log.info("Upload directory created at: {}", this.uploadPath);
        } catch (IOException e) {
            throw new RuntimeException("Could not create upload directory", e);
        }
    }

    @PostMapping("/admin/uploads")
    public ResponseEntity<ApiResponse<String>> uploadFile(@RequestParam("file") MultipartFile file) {
        validateFile(file);

        try {
            String originalFilename = file.getOriginalFilename();
            String extension = originalFilename != null && originalFilename.contains(".")
                    ? originalFilename.substring(originalFilename.lastIndexOf("."))
                    : ".jpg";

            String filename = UUID.randomUUID().toString() + extension;
            Path targetLocation = uploadPath.resolve(filename);

            Files.copy(file.getInputStream(), targetLocation, StandardCopyOption.REPLACE_EXISTING);
            log.info("File uploaded successfully: {}", filename);

            String fileUrl = "/api/uploads/" + filename;
            return ResponseEntity.ok(ApiResponse.success(fileUrl, "File uploaded successfully"));

        } catch (IOException e) {
            log.error("Failed to upload file", e);
            throw new ValidationException("Failed to upload file: " + e.getMessage());
        }
    }

    @GetMapping("/uploads/{filename:.+}")
    public ResponseEntity<Resource> getFile(@PathVariable String filename) {
        try {
            Path filePath = uploadPath.resolve(filename).normalize();
            Resource resource = new UrlResource(filePath.toUri());

            if (!resource.exists() || !resource.isReadable()) {
                throw new ValidationException("File not found: " + filename);
            }

            String contentType = Files.probeContentType(filePath);
            if (contentType == null) {
                contentType = "application/octet-stream";
            }

            return ResponseEntity.ok()
                    .contentType(MediaType.parseMediaType(contentType))
                    .header(HttpHeaders.CONTENT_DISPOSITION, "inline; filename=\"" + resource.getFilename() + "\"")
                    .body(resource);

        } catch (MalformedURLException e) {
            log.error("Invalid file path: {}", filename, e);
            throw new ValidationException("Invalid file path");
        } catch (IOException e) {
            log.error("Error reading file: {}", filename, e);
            throw new ValidationException("Error reading file");
        }
    }

    private void validateFile(MultipartFile file) {
        if (file.isEmpty()) {
            throw new ValidationException("File is empty");
        }

        if (file.getSize() > MAX_FILE_SIZE) {
            throw new ValidationException("File size exceeds maximum allowed (5MB)");
        }

        String contentType = file.getContentType();
        if (contentType == null || !ALLOWED_CONTENT_TYPES.contains(contentType)) {
            throw new ValidationException("Invalid file type. Allowed types: JPEG, PNG, WebP");
        }
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/catalog/controller/ServiceController.java ==========
package com.flavia.dermobeauty.catalog.controller;

import com.flavia.dermobeauty.catalog.dto.ServiceDto;
import com.flavia.dermobeauty.catalog.service.ServiceCatalogService;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * Public REST controller for service catalog operations.
 * Provides endpoints for browsing available services.
 */
@RestController
@RequestMapping("/api/public/services")
@RequiredArgsConstructor
public class ServiceController {

    private final ServiceCatalogService serviceCatalogService;

    @GetMapping
    public ResponseEntity<ApiResponse<List<ServiceDto>>> getAllServices() {
        List<ServiceDto> services = serviceCatalogService.getAllActive();
        return ResponseEntity.ok(ApiResponse.success(services));
    }

    @GetMapping("/featured")
    public ResponseEntity<ApiResponse<List<ServiceDto>>> getFeaturedServices() {
        List<ServiceDto> services = serviceCatalogService.getFeatured();
        return ResponseEntity.ok(ApiResponse.success(services));
    }

    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<ServiceDto>> getServiceById(@PathVariable Long id) {
        ServiceDto service = serviceCatalogService.getById(id);
        return ResponseEntity.ok(ApiResponse.success(service));
    }

    @GetMapping("/slug/{slug}")
    public ResponseEntity<ApiResponse<ServiceDto>> getServiceBySlug(@PathVariable String slug) {
        ServiceDto service = serviceCatalogService.getBySlug(slug);
        return ResponseEntity.ok(ApiResponse.success(service));
    }

    @GetMapping("/category/{categoryId}")
    public ResponseEntity<ApiResponse<List<ServiceDto>>> getServicesByCategory(@PathVariable Long categoryId) {
        List<ServiceDto> services = serviceCatalogService.getByCategory(categoryId);
        return ResponseEntity.ok(ApiResponse.success(services));
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/booking/infrastructure/persistence/JpaBookingRepository.java ==========
package com.flavia.dermobeauty.booking.infrastructure.persistence;

import com.flavia.dermobeauty.booking.domain.BookingStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.List;
import java.util.Optional;

/**
 * Spring Data JPA repository for BookingEntity.
 * Infrastructure implementation detail.
 */
@Repository
public interface JpaBookingRepository extends JpaRepository<BookingEntity, Long> {

    Optional<BookingEntity> findByBookingNumber(String bookingNumber);

    Optional<BookingEntity> findByMercadoPagoPaymentId(String paymentId);

    List<BookingEntity> findByStatus(BookingStatus status);

    List<BookingEntity> findByBookingDateAndStatusNot(LocalDate bookingDate, BookingStatus status);

    // Un turno se solapa si: (StartA < EndB) y (StartB < EndA)
    @Query(value = """
           SELECT CASE WHEN COUNT(*) > 0 THEN true ELSE false END
           FROM bookings b
           WHERE b.service_id = :serviceId
           AND b.booking_date = :date
           AND b.status != 'CANCELLED'
           AND (
               b.booking_time < :endTime
               AND :startTime < (b.booking_time + (b.duration_minutes * interval '1 minute'))
           )
           """, nativeQuery = true)
    boolean existsOverlappingBooking(
            @Param("serviceId") Long serviceId,
            @Param("date") LocalDate date,
            @Param("startTime") LocalTime startTime,
            @Param("endTime") LocalTime endTime
    );
}
========== FILE: src/main/java/com/flavia/dermobeauty/booking/infrastructure/persistence/BookingEntity.java ==========
package com.flavia.dermobeauty.booking.infrastructure.persistence;

import com.flavia.dermobeauty.booking.domain.BookingStatus;
import com.flavia.dermobeauty.booking.domain.PaymentStatus;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;

/**
 * JPA entity for bookings table.
 * Infrastructure layer representation of Booking aggregate.
 */
@Entity
@Table(name = "bookings")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class BookingEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "booking_number", nullable = false, unique = true, length = 50)
    private String bookingNumber;

    @Column(name = "service_id", nullable = false)
    private Long serviceId;

    // Customer information (embedded fields)
    @Column(name = "customer_name", nullable = false, length = 200)
    private String customerName;

    @Column(name = "customer_email", nullable = false, length = 200)
    private String customerEmail;

    @Column(name = "customer_whatsapp", nullable = false, length = 50)
    private String customerWhatsapp;

    @Column(name = "customer_comments", columnDefinition = "TEXT")
    private String customerComments;

    // Time slot (embedded fields)
    @Column(name = "booking_date", nullable = false)
    private LocalDate bookingDate;

    @Column(name = "booking_time", nullable = false)
    private LocalTime bookingTime;

    @Column(name = "duration_minutes", nullable = false)
    private Integer durationMinutes;

    // Status tracking
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private BookingStatus status;

    // Payment information
    @Enumerated(EnumType.STRING)
    @Column(name = "payment_status", nullable = false, length = 20)
    private PaymentStatus paymentStatus;

    @Column(name = "mercadopago_preference_id", length = 200)
    private String mercadoPagoPreferenceId;

    @Column(name = "mercadopago_payment_id", length = 200)
    private String mercadoPagoPaymentId;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal amount;

    // Timestamps
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @Column(name = "confirmed_at")
    private LocalDateTime confirmedAt;

    @Column(name = "cancelled_at")
    private LocalDateTime cancelledAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = LocalDateTime.now();
        }
        if (updatedAt == null) {
            updatedAt = LocalDateTime.now();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/booking/infrastructure/notification/StubNotificationService.java ==========
package com.flavia.dermobeauty.booking.infrastructure.notification;

import com.flavia.dermobeauty.booking.application.port.NotificationService;
import com.flavia.dermobeauty.booking.domain.Booking;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

/**
 * Stub implementation of NotificationService for Phase 5.
 * Will be replaced with full email implementation in Phase 8.
 */
@Slf4j
@Service
public class StubNotificationService implements NotificationService {

    @Override
    public void sendBookingConfirmation(Booking booking) {
        log.info("STUB: Would send booking confirmation email for {} to {}",
                booking.getBookingNumber(),
                booking.getCustomerInfo().getEmail());

        // No-op for now - will implement email sending in Phase 8
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/booking/config/BookingConfig.java ==========
package com.flavia.dermobeauty.booking.config;

import com.flavia.dermobeauty.booking.application.port.NotificationService;
import com.flavia.dermobeauty.booking.application.usecase.*;
import com.flavia.dermobeauty.booking.domain.BookingRepository;
import com.flavia.dermobeauty.catalog.repository.ServiceRepository;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * Configuration class for Booking module.
 * Wires use cases as Spring beans for dependency injection.
 */
@Configuration
public class BookingConfig {

    @Bean
    public CreateBookingUseCase createBookingUseCase(BookingRepository bookingRepository) {
        return new CreateBookingUseCase(bookingRepository);
    }

    @Bean
    public ConfirmBookingPaymentUseCase confirmBookingPaymentUseCase(
            BookingRepository bookingRepository,
            NotificationService notificationService) {
        return new ConfirmBookingPaymentUseCase(bookingRepository, notificationService);
    }

    @Bean
    public ListBookingsUseCase listBookingsUseCase(BookingRepository bookingRepository) {
        return new ListBookingsUseCase(bookingRepository);
    }

    @Bean
    public CancelBookingUseCase cancelBookingUseCase(BookingRepository bookingRepository) {
        return new CancelBookingUseCase(bookingRepository);
    }

    @Bean
    public GetBookingByNumberUseCase getBookingByNumberUseCase(BookingRepository bookingRepository) {
        return new GetBookingByNumberUseCase(bookingRepository);
    }

    @Bean
    public GetAvailableSlotsUseCase getAvailableSlotsUseCase(
            BookingRepository bookingRepository,
            ServiceRepository serviceRepository
    ) {
        return new GetAvailableSlotsUseCase(bookingRepository, serviceRepository);
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/booking/domain/BookingRepository.java ==========
package com.flavia.dermobeauty.booking.domain;

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.List;
import java.util.Optional;

/**
 * Repository port (interface) for Booking aggregate.
 * Defines operations needed by the domain layer without specifying implementation.
 * Implementation will be provided by infrastructure layer.
 */
public interface BookingRepository {

    /**
     * Save a booking (create or update).
     */
    Booking save(Booking booking);

    /**
     * Find booking by ID.
     */
    Optional<Booking> findById(Long id);

    /**
     * Find booking by booking number.
     */
    Optional<Booking> findByBookingNumber(String bookingNumber);

    /**
     * Find booking by Mercado Pago payment ID.
     */
    Optional<Booking> findByMercadoPagoPaymentId(String paymentId);

    /**
     * Check if a slot is already booked for a service.
     * Returns true if there's an active (non-cancelled) booking for this slot.
     */
    boolean isTimeSlotAvailable(Long serviceId, LocalDate date, LocalTime startTime, LocalTime endTime);

    /**
     * Find all bookings (for admin).
     */
    List<Booking> findAll();

    /**
     * Find bookings by status (for admin filtering).
     */
    List<Booking> findByStatus(BookingStatus status);

    List<Booking> findByDate(LocalDate date);

}

========== FILE: src/main/java/com/flavia/dermobeauty/booking/web/BookingController.java ==========
package com.flavia.dermobeauty.booking.web;

import com.flavia.dermobeauty.booking.application.usecase.CreateBookingUseCase;
import com.flavia.dermobeauty.booking.application.usecase.GetBookingByNumberUseCase;
import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.web.dto.BookingResponse;
import com.flavia.dermobeauty.booking.web.dto.CreateBookingRequest;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

/**
 * REST controller for booking operations.
 * Public endpoints for customers to create and check bookings.
 */
@Slf4j
@RestController
@RequestMapping("/api/public/bookings")
@RequiredArgsConstructor
public class BookingController {

    private final CreateBookingUseCase createBookingUseCase;
    private final GetBookingByNumberUseCase getBookingByNumberUseCase;

    @PostMapping
    public ResponseEntity<ApiResponse<BookingResponse>> createBooking(
            @Valid @RequestBody CreateBookingRequest request) {

        log.info("Creating booking for service {} on {} at {}",
                request.getServiceId(), request.getBookingDate(), request.getBookingTime());

        Booking booking = createBookingUseCase.execute(
                request.getServiceId(),
                request.getCustomerName(),
                request.getCustomerEmail(),
                request.getCustomerWhatsapp(),
                request.getCustomerComments(),
                request.getBookingDate(),
                request.getBookingTime(),
                request.getDurationMinutes(),
                request.getAmount()
        );

        BookingResponse response = BookingResponse.fromDomain(booking);
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.success(response, "Booking created successfully"));
    }

    @GetMapping("/{bookingNumber}")
    public ResponseEntity<ApiResponse<BookingResponse>> getBookingByNumber(
            @PathVariable String bookingNumber) {

        log.debug("Fetching booking: {}", bookingNumber);

        Booking booking = getBookingByNumberUseCase.execute(bookingNumber);
        BookingResponse response = BookingResponse.fromDomain(booking);

        return ResponseEntity.ok(ApiResponse.success(response));
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/booking/web/AvailabilityController.java ==========
package com.flavia.dermobeauty.booking.web;

import com.flavia.dermobeauty.booking.application.usecase.GetAvailableSlotsUseCase;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.List;

@RestController
@RequestMapping("/api/public/availability")
@RequiredArgsConstructor
public class AvailabilityController {

    private final GetAvailableSlotsUseCase getAvailableSlotsUseCase;

    @GetMapping
    public ResponseEntity<ApiResponse<List<LocalTime>>> getAvailability(
            @RequestParam Long serviceId,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate date) {

        List<LocalTime> slots = getAvailableSlotsUseCase.execute(serviceId, date);
        return ResponseEntity.ok(ApiResponse.success(slots));
    }
}
========== FILE: src/main/java/com/flavia/dermobeauty/booking/application/port/NotificationService.java ==========
package com.flavia.dermobeauty.booking.application.port;

import com.flavia.dermobeauty.booking.domain.Booking;

/**
 * Port (interface) for notification operations.
 * Will be implemented by the notification module infrastructure.
 */
public interface NotificationService {

    /**
     * Send booking confirmation email to customer.
     *
     * @param booking The confirmed booking
     */
    void sendBookingConfirmation(Booking booking);
}

========== FILE: src/main/java/com/flavia/dermobeauty/booking/application/port/PaymentService.java ==========
package com.flavia.dermobeauty.booking.application.port;

import com.flavia.dermobeauty.booking.domain.Booking;

/**
 * Port (interface) for payment operations.
 * Will be implemented by the payment module infrastructure.
 */
public interface PaymentService {

    /**
     * Create a Mercado Pago payment preference for a booking.
     *
     * @param booking The booking to create payment for
     * @return Preference ID
     */
    String createBookingPreference(Booking booking);
}

========== FILE: src/main/java/com/flavia/dermobeauty/security/config/SecurityConfig.java ==========
package com.flavia.dermobeauty.security.config;

import com.flavia.dermobeauty.security.jwt.JwtAuthenticationFilter;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.List;

/**
 * Spring Security configuration for the application.
 * Configures CORS, JWT authentication, and endpoint authorization.
 */
@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .cors(cors -> cors.configurationSource(corsConfigurationSource()))
                .csrf(csrf -> csrf.disable())
                .sessionManagement(session ->
                        session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .authorizeHttpRequests(auth -> auth
                        // Public endpoints
                        .requestMatchers("/api/public/**").permitAll()
                        .requestMatchers("/api/mp/webhook").permitAll()
                        .requestMatchers("/api/auth/login").permitAll()
                        .requestMatchers("/api/uploads/**").permitAll()
                        .requestMatchers("/api/test/**").permitAll() // TODO: Remove in production!
                        // Admin endpoints
                        .requestMatchers("/api/admin/**").hasRole("ADMIN")
                        // All other requests require authentication
                        .anyRequest().authenticated()
                )
                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(List.of("http://localhost:5173", "https://flaviadermobeauty.com","https://api.flaviadermobeauty.com"));
        configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(List.of("*"));
        configuration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/security/controller/AuthController.java ==========
package com.flavia.dermobeauty.security.controller;

import com.flavia.dermobeauty.security.dto.LoginRequest;
import com.flavia.dermobeauty.security.dto.LoginResponse;
import com.flavia.dermobeauty.security.jwt.JwtTokenProvider;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * Authentication controller for admin login.
 * Validates hardcoded credentials and returns JWT token.
 */
@Slf4j
@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
public class AuthController {

    private final JwtTokenProvider jwtTokenProvider;
    private final PasswordEncoder passwordEncoder;

    @Value("${admin.username}")
    private String adminUsername;

    @Value("${admin.password}")
    private String adminPasswordHash;

    @PostMapping("/login")
    public ResponseEntity<ApiResponse<LoginResponse>> login(@Valid @RequestBody LoginRequest request) {
        log.info("Login attempt for user: {}", request.getUsername());

        if (!adminUsername.equals(request.getUsername())) {
            log.warn("Login failed: Invalid username");
            return ResponseEntity.status(401)
                    .body(ApiResponse.success(null, "Invalid credentials"));
        }

        if (!passwordEncoder.matches(request.getPassword(), adminPasswordHash)) {
            log.warn("Login failed: Invalid password");
            return ResponseEntity.status(401)
                    .body(ApiResponse.success(null, "Invalid credentials"));
        }

        String token = jwtTokenProvider.generateToken(adminUsername);
        LoginResponse response = new LoginResponse(token, adminUsername, "ADMIN");

        log.info("Login successful for user: {}", adminUsername);
        return ResponseEntity.ok(ApiResponse.success(response));
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/config/repository/ConfigRepository.java ==========
package com.flavia.dermobeauty.config.repository;

import com.flavia.dermobeauty.config.domain.ConfigEntry;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.Optional;

public interface ConfigRepository extends JpaRepository<ConfigEntry, Long> {
    Optional<ConfigEntry> findByKey(String key);
}
========== FILE: src/main/java/com/flavia/dermobeauty/config/web/AdminConfigController.java ==========
package com.flavia.dermobeauty.config.web;

import com.flavia.dermobeauty.config.domain.ConfigEntry;
import com.flavia.dermobeauty.config.repository.ConfigRepository;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/admin/config")
@RequiredArgsConstructor
public class AdminConfigController {

    private final ConfigRepository configRepository;

    @GetMapping
    public ResponseEntity<ApiResponse<List<ConfigEntry>>> getAllConfig() {
        return ResponseEntity.ok(ApiResponse.success(configRepository.findAll()));
    }

    @PutMapping("/{key}")
    public ResponseEntity<ApiResponse<ConfigEntry>> updateConfig(
            @PathVariable String key,
            @RequestBody UpdateConfigRequest request) {

        ConfigEntry config = configRepository.findByKey(key)
                .orElse(ConfigEntry.builder().key(key).build());

        config.setValue(request.getValue());
        // Descripción opcional, solo si es nuevo
        if (config.getDescription() == null) {
            config.setDescription("Configuración dinámica");
        }

        return ResponseEntity.ok(ApiResponse.success(configRepository.save(config)));
    }

    @Data
    public static class UpdateConfigRequest {
        private String value;
    }
}
========== FILE: src/main/java/com/flavia/dermobeauty/shared/web/GlobalExceptionHandler.java ==========
package com.flavia.dermobeauty.shared.web;

import com.flavia.dermobeauty.shared.exception.DomainException;
import com.flavia.dermobeauty.shared.exception.PaymentException;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import com.flavia.dermobeauty.shared.exception.ValidationException;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.HashMap;
import java.util.Map;

/**
 * Global exception handler for all REST controllers.
 * Provides consistent error responses across the application.
 */
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleResourceNotFound(
            ResourceNotFoundException ex,
            HttpServletRequest request) {

        log.warn("Resource not found: {}", ex.getMessage());

        ErrorResponse error = new ErrorResponse(
                "NOT_FOUND",
                ex.getMessage(),
                request.getRequestURI()
        );

        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }

    @ExceptionHandler(ValidationException.class)
    public ResponseEntity<ErrorResponse> handleValidation(
            ValidationException ex,
            HttpServletRequest request) {

        log.warn("Validation error: {}", ex.getMessage());

        ErrorResponse error = new ErrorResponse(
                "VALIDATION_ERROR",
                ex.getMessage(),
                request.getRequestURI()
        );

        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleMethodArgumentNotValid(
            MethodArgumentNotValidException ex,
            HttpServletRequest request) {

        Map<String, String> fieldErrors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach(error -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            fieldErrors.put(fieldName, errorMessage);
        });

        log.warn("Bean validation failed: {}", fieldErrors);

        ErrorResponse error = new ErrorResponse(
                "VALIDATION_ERROR",
                "Invalid request data",
                request.getRequestURI(),
                fieldErrors
        );

        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }

    @ExceptionHandler(PaymentException.class)
    public ResponseEntity<ErrorResponse> handlePayment(
            PaymentException ex,
            HttpServletRequest request) {

        log.error("Payment processing error: {}", ex.getMessage(), ex);

        ErrorResponse error = new ErrorResponse(
                "PAYMENT_ERROR",
                ex.getMessage(),
                request.getRequestURI()
        );

        return ResponseEntity.status(HttpStatus.BAD_GATEWAY).body(error);
    }

    @ExceptionHandler(DomainException.class)
    public ResponseEntity<ErrorResponse> handleDomain(
            DomainException ex,
            HttpServletRequest request) {

        log.warn("Domain exception: {}", ex.getMessage());

        ErrorResponse error = new ErrorResponse(
                "BUSINESS_RULE_VIOLATION",
                ex.getMessage(),
                request.getRequestURI()
        );

        return ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY).body(error);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneral(
            Exception ex,
            HttpServletRequest request) {

        log.error("Unexpected error", ex);

        ErrorResponse error = new ErrorResponse(
                "INTERNAL_ERROR",
                "An unexpected error occurred. Please try again later.",
                request.getRequestURI()
        );

        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/sales/infrastructure/persistence/OrderEntity.java ==========
package com.flavia.dermobeauty.sales.infrastructure.persistence;

import com.flavia.dermobeauty.booking.domain.PaymentStatus;
import com.flavia.dermobeauty.sales.domain.DeliveryType;
import com.flavia.dermobeauty.sales.domain.OrderStatus;
import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

/**
 * JPA entity for orders table.
 * Infrastructure layer representation of Order aggregate.
 */
@Entity
@Table(name = "orders")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class OrderEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "order_number", nullable = false, unique = true, length = 50)
    private String orderNumber;

    // Customer information
    @Column(name = "customer_name", nullable = false, length = 200)
    private String customerName;

    @Column(name = "customer_email", nullable = false, length = 200)
    private String customerEmail;

    @Column(name = "customer_whatsapp", nullable = false, length = 50)
    private String customerWhatsapp;

    // Delivery information
    @Enumerated(EnumType.STRING)
    @Column(name = "delivery_type", nullable = false, length = 20)
    private DeliveryType deliveryType;

    @Column(name = "delivery_address_street", length = 300)
    private String deliveryAddress;

    @Column(name = "delivery_address_city", length = 100)
    private String deliveryCity;

    @Column(name = "delivery_address_postal_code", length = 20)
    private String deliveryPostalCode;

    @Column(name = "delivery_address_state", length = 100)
    private String deliveryProvince;

    @Column(name = "delivery_notes", columnDefinition = "TEXT")
    private String deliveryNotes;

    // Order items (OneToMany relationship)
    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true)
    @Builder.Default
    @ToString.Exclude
    private List<OrderItemEntity> items = new ArrayList<>();

    // Pricing
    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal subtotal;

    @Column(name = "delivery_cost", nullable = false, precision = 10, scale = 2)
    private BigDecimal deliveryCost;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal total;

    // Status tracking
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private OrderStatus status;

    // Payment information
    @Enumerated(EnumType.STRING)
    @Column(name = "payment_status", nullable = false, length = 20)
    private PaymentStatus paymentStatus;

    @Column(name = "mercadopago_preference_id", length = 200)
    private String mercadoPagoPreferenceId;

    @Column(name = "mercadopago_payment_id", length = 200)
    private String mercadoPagoPaymentId;

    // Timestamps
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = LocalDateTime.now();
        }
        if (updatedAt == null) {
            updatedAt = LocalDateTime.now();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }

    /**
     * Helper method to add item and maintain bidirectional relationship.
     */
    public void addItem(OrderItemEntity item) {
        items.add(item);
        item.setOrder(this);
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/sales/infrastructure/persistence/OrderItemEntity.java ==========
package com.flavia.dermobeauty.sales.infrastructure.persistence;

import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * JPA entity for order_items table.
 * Part of Order aggregate in infrastructure layer.
 */
@Entity
@Table(name = "order_items")
@Getter@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class OrderItemEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id", nullable = false)
    @ToString.Exclude
    private OrderEntity order;

    @Column(name = "product_id", nullable = false)
    private Long productId;

    // Snapshot of product at time of order
    @Column(name = "product_name", nullable = false, length = 200)
    private String productName;

    @Column(name = "product_price", nullable = false, precision = 10, scale = 2)
    private BigDecimal productPrice;

    @Column(nullable = false)
    private Integer quantity;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal subtotal;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = LocalDateTime.now();
        }
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/sales/infrastructure/persistence/JpaOrderRepository.java ==========
package com.flavia.dermobeauty.sales.infrastructure.persistence;

import com.flavia.dermobeauty.sales.domain.OrderStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

/**
 * Spring Data JPA repository for OrderEntity.
 * Infrastructure implementation detail.
 */
@Repository
public interface JpaOrderRepository extends JpaRepository<OrderEntity, Long> {

    Optional<OrderEntity> findByOrderNumber(String orderNumber);

    Optional<OrderEntity> findByMercadoPagoPaymentId(String paymentId);

    List<OrderEntity> findByStatus(OrderStatus status);
}

========== FILE: src/main/java/com/flavia/dermobeauty/sales/infrastructure/notification/StubOrderNotificationService.java ==========
package com.flavia.dermobeauty.sales.infrastructure.notification;

import com.flavia.dermobeauty.sales.application.port.NotificationService;
import com.flavia.dermobeauty.sales.domain.Order;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

/**
 * Stub implementation of NotificationService for Phase 6.
 * Will be replaced with full email implementation in Phase 8.
 */
@Slf4j
@Service("orderNotificationService")
public class StubOrderNotificationService implements NotificationService {

    @Override
    public void sendOrderConfirmation(Order order) {
        log.info("STUB: Would send order confirmation email for {} to {}",
                order.getOrderNumber(),
                order.getCustomerInfo().getEmail());

        // No-op for now - will implement email sending in Phase 8
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/sales/config/SalesConfig.java ==========
package com.flavia.dermobeauty.sales.config;

import com.flavia.dermobeauty.catalog.repository.ProductRepository;
import com.flavia.dermobeauty.sales.application.port.DeliveryCostCalculator;
import com.flavia.dermobeauty.sales.application.port.NotificationService;
import com.flavia.dermobeauty.sales.application.port.StockService;
import com.flavia.dermobeauty.sales.application.usecase.*;
import com.flavia.dermobeauty.sales.domain.OrderRepository;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * Configuration class for Sales module.
 * Wires use cases as Spring beans for dependency injection.
 */
@Configuration
public class SalesConfig {

    @Bean
    public CreateOrderUseCase createOrderUseCase(
            OrderRepository orderRepository,
            ProductRepository productRepository,
            StockService stockService,
            DeliveryCostCalculator deliveryCostCalculator) {
        return new CreateOrderUseCase(orderRepository, productRepository, stockService, deliveryCostCalculator);
    }

    @Bean
    public ConfirmOrderPaymentUseCase confirmOrderPaymentUseCase(
            OrderRepository orderRepository,
            StockService stockService,
            @Qualifier("orderNotificationService") NotificationService notificationService) {
        return new ConfirmOrderPaymentUseCase(orderRepository, stockService, notificationService);
    }

    @Bean
    public UpdateOrderStatusUseCase updateOrderStatusUseCase(OrderRepository orderRepository) {
        return new UpdateOrderStatusUseCase(orderRepository);
    }

    @Bean
    public ListOrdersUseCase listOrdersUseCase(OrderRepository orderRepository) {
        return new ListOrdersUseCase(orderRepository);
    }

    @Bean
    public GetOrderByNumberUseCase getOrderByNumberUseCase(OrderRepository orderRepository) {
        return new GetOrderByNumberUseCase(orderRepository);
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/sales/domain/OrderRepository.java ==========
package com.flavia.dermobeauty.sales.domain;

import java.util.List;
import java.util.Optional;

/**
 * Repository port (interface) for Order aggregate.
 * Defines operations needed by the domain layer without specifying implementation.
 * Implementation will be provided by infrastructure layer.
 */
public interface OrderRepository {

    /**
     * Save an order (create or update).
     */
    Order save(Order order);

    /**
     * Find order by ID.
     */
    Optional<Order> findById(Long id);

    /**
     * Find order by order number.
     */
    Optional<Order> findByOrderNumber(String orderNumber);

    /**
     * Find order by Mercado Pago payment ID.
     */
    Optional<Order> findByMercadoPagoPaymentId(String paymentId);

    /**
     * Find all orders (for admin).
     */
    List<Order> findAll();

    /**
     * Find orders by status (for admin filtering).
     */
    List<Order> findByStatus(OrderStatus status);
}

========== FILE: src/main/java/com/flavia/dermobeauty/sales/web/OrderController.java ==========
package com.flavia.dermobeauty.sales.web;

import com.flavia.dermobeauty.sales.application.usecase.CreateOrderUseCase;
import com.flavia.dermobeauty.sales.application.usecase.GetOrderByNumberUseCase;
import com.flavia.dermobeauty.sales.domain.Order;
import com.flavia.dermobeauty.sales.web.dto.CreateOrderRequest;
import com.flavia.dermobeauty.sales.web.dto.OrderItemRequest;
import com.flavia.dermobeauty.sales.web.dto.OrderResponse;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

/**
 * REST controller for order operations.
 * Public endpoints for customers to create and check orders.
 */
@Slf4j
@RestController
@RequestMapping("/api/public/orders")
@RequiredArgsConstructor
public class OrderController {

    private final CreateOrderUseCase createOrderUseCase;
    private final GetOrderByNumberUseCase getOrderByNumberUseCase;

    @PostMapping
    public ResponseEntity<ApiResponse<OrderResponse>> createOrder(
            @Valid @RequestBody CreateOrderRequest request) {

        log.info("Creating order for customer: {}", request.getCustomerEmail());

        List<CreateOrderUseCase.OrderItemRequest> itemRequests = request.getItems().stream()
                .map(item -> new CreateOrderUseCase.OrderItemRequest(item.getProductId(), item.getQuantity()))
                .collect(Collectors.toList());

        Order order = createOrderUseCase.execute(
                request.getCustomerName(),
                request.getCustomerEmail(),
                request.getCustomerWhatsapp(),
                request.getDeliveryType(),
                request.getDeliveryAddress(),
                request.getDeliveryCity(),
                request.getDeliveryPostalCode(),
                request.getDeliveryProvince(),
                request.getDeliveryNotes(),
                itemRequests
        );

        OrderResponse response = OrderResponse.fromDomain(order);
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.success(response, "Order created successfully"));
    }

    @GetMapping("/{orderNumber}")
    public ResponseEntity<ApiResponse<OrderResponse>> getOrderByNumber(
            @PathVariable String orderNumber) {

        log.debug("Fetching order: {}", orderNumber);

        Order order = getOrderByNumberUseCase.execute(orderNumber);
        OrderResponse response = OrderResponse.fromDomain(order);

        return ResponseEntity.ok(ApiResponse.success(response));
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/sales/web/AdminOperationsController.java ==========
package com.flavia.dermobeauty.sales.web;

import com.flavia.dermobeauty.booking.application.usecase.CancelBookingUseCase;
import com.flavia.dermobeauty.booking.application.usecase.ListBookingsUseCase;
import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.web.dto.BookingResponse;
import com.flavia.dermobeauty.sales.application.usecase.ListOrdersUseCase;
import com.flavia.dermobeauty.sales.application.usecase.UpdateOrderStatusUseCase;
import com.flavia.dermobeauty.sales.domain.Order;
import com.flavia.dermobeauty.sales.domain.OrderStatus;
import com.flavia.dermobeauty.sales.web.dto.OrderResponse;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/admin")
@RequiredArgsConstructor
public class AdminOperationsController {

    private final ListBookingsUseCase listBookingsUseCase;
    private final CancelBookingUseCase cancelBookingUseCase;
    private final ListOrdersUseCase listOrdersUseCase;
    private final UpdateOrderStatusUseCase updateOrderStatusUseCase;

    // ==================== BOOKINGS ====================

    @GetMapping("/bookings")
    public ResponseEntity<ApiResponse<List<BookingResponse>>> getBookings() {
        List<BookingResponse> bookings = listBookingsUseCase.execute().stream()
                .map(BookingResponse::fromDomain)
                .collect(Collectors.toList());
        return ResponseEntity.ok(ApiResponse.success(bookings));
    }

    @DeleteMapping("/bookings/{id}")
    public ResponseEntity<ApiResponse<Void>> cancelBooking(@PathVariable Long id) {
        cancelBookingUseCase.execute(id);
        return ResponseEntity.ok(ApiResponse.success("Turno cancelado"));
    }

    // ==================== ORDERS ====================

    @GetMapping("/orders")
    public ResponseEntity<ApiResponse<List<OrderResponse>>> getOrders() {
        List<OrderResponse> orders = listOrdersUseCase.execute().stream()
                .map(OrderResponse::fromDomain)
                .collect(Collectors.toList());
        return ResponseEntity.ok(ApiResponse.success(orders));
    }

    @PatchMapping("/orders/{id}/status")
    public ResponseEntity<ApiResponse<OrderResponse>> updateOrderStatus(
            @PathVariable Long id,
            @RequestBody UpdateStatusRequest request) {

        Order updated = updateOrderStatusUseCase.execute(id, request.getStatus());
        return ResponseEntity.ok(ApiResponse.success(OrderResponse.fromDomain(updated)));
    }

    @Data
    public static class UpdateStatusRequest {
        private OrderStatus status;
    }
}
========== FILE: src/main/java/com/flavia/dermobeauty/sales/application/port/StockService.java ==========
package com.flavia.dermobeauty.sales.application.port;

/**
 * Port (interface) for stock management operations.
 * Will be implemented by the catalog infrastructure.
 */
public interface StockService {

    /**
     * Check if sufficient stock is available for a product.
     *
     * @param productId Product ID
     * @param quantity  Requested quantity
     * @return true if stock available, false otherwise
     */
    boolean checkAvailability(Long productId, Integer quantity);

    /**
     * Decrement stock for a product.
     * Should be called after payment confirmation.
     *
     * @param productId Product ID
     * @param quantity  Quantity to decrement
     */
    void decrementStock(Long productId, Integer quantity);
}

========== FILE: src/main/java/com/flavia/dermobeauty/sales/application/port/NotificationService.java ==========
package com.flavia.dermobeauty.sales.application.port;

import com.flavia.dermobeauty.sales.domain.Order;

/**
 * Port (interface) for notification operations.
 * Will be implemented by the notification module infrastructure.
 */
public interface NotificationService {

    /**
     * Send order confirmation email to customer.
     *
     * @param order The confirmed order
     */
    void sendOrderConfirmation(Order order);
}

========== FILE: src/main/java/com/flavia/dermobeauty/sales/application/port/PaymentService.java ==========
package com.flavia.dermobeauty.sales.application.port;

import com.flavia.dermobeauty.sales.domain.Order;

/**
 * Port (interface) for payment operations.
 * Will be implemented by the payment module infrastructure.
 */
public interface PaymentService {

    /**
     * Create a Mercado Pago payment preference for an order.
     *
     * @param order The order to create payment for
     * @return Preference ID
     */
    String createOrderPreference(Order order);
}

========== FILE: src/main/resources/application-dev.yml ==========
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/dermobeauty_dev
    username: dermobeauty
    password: dermobeauty
    driver-class-name: org.postgresql.Driver
  jpa:
    show-sql: true
    properties:
      hibernate:
        format_sql: true
  mail:
    host: smtp.gmail.com
    port: 587
    username: 'flavia.dermobeauty@gmail.com'
    password: 'qajp ptwr gdjg uozl'
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true
            required: true
          connectiontimeout: 5000
          timeout: 5000
          writetimeout: 5000

# Admin credentials (change in production!)
admin:
  username: admin
  # BCrypt hash for "admin123" (verified)
  password: $2a$10$OQlalRpvK3/0ikEa3xO62ujds5OHSF723wIXh3gIk7ca7nJmp0c9q

# JWT configuration
jwt:
  secret: flavia-dermobeauty-jwt-secret-key-change-in-production-2024
  expiration: 86400000 # 24 hours in milliseconds

# Mercado Pago configuration
mercadopago:
  access-token: APP_USR-3480197543728175-092819-981988e8773a0af18511e1e610ba5f23-2719878562
  base-url: https://flaviadermobeauty.com

# Application settings
app:
  api-url: https://api.flaviadermobeauty.com
  upload-dir: ./uploads
  email:
    from: flavia.dermobeauty@gmail.com
    from-name: Flavia Dermobeauty
  delivery:
    fixed-cost: 1500.00

# Logging
logging:
  level:
    com.flavia.dermobeauty: DEBUG
    org.springframework.web: INFO
    org.hibernate.SQL: DEBUG

========== FILE: src/main/resources/application.yml ==========
spring:
  application:
    name: dermobeauty
  profiles:
    active: dev
  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: false
    open-in-view: false
  flyway:
    enabled: true
    baseline-on-migrate: true
  servlet:
    multipart:
      max-file-size: 5MB
      max-request-size: 10MB

server:
  port: 8080
  error:
    include-message: always
    include-binding-errors: always


========== FILE: ./.gitignore ==========
HELP.md
target/
!.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/

### Application ###
/uploads/
*.log


========== FILE: ./pom.xml ==========
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.3.5</version>
        <relativePath/>
    </parent>

    <groupId>com.flavia</groupId>
    <artifactId>dermobeauty</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <name>Flavia Dermobeauty</name>
    <description>Beauty and dermatology booking and e-commerce platform</description>

    <properties>
        <java.version>17</java.version>
        <mercadopago.version>2.1.28</mercadopago.version>
        <jjwt.version>0.12.6</jjwt.version>
    </properties>

    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>

        <!-- Database -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- Flyway -->
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-core</artifactId>
        </dependency>

        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-database-postgresql</artifactId>
        </dependency>

        <!-- Mercado Pago SDK -->
        <dependency>
            <groupId>com.mercadopago</groupId>
            <artifactId>sdk-java</artifactId>
            <version>${mercadopago.version}</version>
        </dependency>

        <!-- JWT -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>${jjwt.version}</version>
        </dependency>

        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>

        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>

        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- Testing -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/application/port/NotificationService.java ==========
package com.flavia.dermobeauty.booking.application.port;

import com.flavia.dermobeauty.booking.domain.Booking;

/**
 * Port (interface) for notification operations.
 * Will be implemented by the notification module infrastructure.
 */
public interface NotificationService {

    /**
     * Send booking confirmation email to customer.
     *
     * @param booking The confirmed booking
     */
    void sendBookingConfirmation(Booking booking);
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/application/port/PaymentService.java ==========
package com.flavia.dermobeauty.booking.application.port;

import com.flavia.dermobeauty.booking.domain.Booking;

/**
 * Port (interface) for payment operations.
 * Will be implemented by the payment module infrastructure.
 */
public interface PaymentService {

    /**
     * Create a Mercado Pago payment preference for a booking.
     *
     * @param booking The booking to create payment for
     * @return Preference ID
     */
    String createBookingPreference(Booking booking);
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/application/usecase/CancelBookingUseCase.java ==========
package com.flavia.dermobeauty.booking.application.usecase;

import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.domain.BookingRepository;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Use Case: Cancel a booking.
 * Can be initiated by admin or customer.
 */
@Slf4j
@RequiredArgsConstructor
public class CancelBookingUseCase {

    private final BookingRepository bookingRepository;

    public Booking execute(Long bookingId) {
        log.info("Cancelling booking: {}", bookingId);

        Booking booking = bookingRepository.findById(bookingId)
                .orElseThrow(() -> new ResourceNotFoundException("Booking", bookingId));

        // Cancel (domain logic validates business rules)
        booking.cancel();

        // Persist
        Booking updated = bookingRepository.save(booking);
        log.info("Booking cancelled: {}", updated.getBookingNumber());

        return updated;
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/application/usecase/ConfirmBookingPaymentUseCase.java ==========
package com.flavia.dermobeauty.booking.application.usecase;

import com.flavia.dermobeauty.booking.application.port.NotificationService;
import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.domain.BookingRepository;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Use Case: Confirm booking payment.
 * Called from Mercado Pago webhook when payment is approved.
 */
@Slf4j
@RequiredArgsConstructor
public class ConfirmBookingPaymentUseCase {

    private final BookingRepository bookingRepository;
    private final NotificationService notificationService;

    public Booking execute(String paymentId) {
        log.info("Confirming payment for payment ID: {}", paymentId);

        // Find booking by payment ID
        Booking booking = bookingRepository.findByMercadoPagoPaymentId(paymentId)
                .orElseThrow(() -> new ResourceNotFoundException("Booking with payment ID '" + paymentId + "' not found"));

        // Confirm payment (domain logic)
        booking.confirmPayment(paymentId);

        // Persist
        Booking updated = bookingRepository.save(booking);
        log.info("Payment confirmed for booking: {}", updated.getBookingNumber());

        // Send confirmation email (async, non-blocking)
        try {
            notificationService.sendBookingConfirmation(updated);
        } catch (Exception e) {
            log.error("Failed to send booking confirmation email for {}", updated.getBookingNumber(), e);
            // Don't throw - email failure should not break payment confirmation
        }

        return updated;
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/application/usecase/CreateBookingUseCase.java ==========
package com.flavia.dermobeauty.booking.application.usecase;

import com.flavia.dermobeauty.booking.domain.*;
import com.flavia.dermobeauty.shared.exception.ValidationException;
import lombok.RequiredArgsConstructor; // <--- IMPORTANTE
import lombok.extern.slf4j.Slf4j;     // <--- IMPORTANTE

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;

@SuppressWarnings("ClassCanBeRecord")
@Slf4j // <--- Soluciona el error "Cannot resolve symbol 'log'"
@RequiredArgsConstructor // <--- Soluciona el error del "bookingRepository" no inicializado
public class CreateBookingUseCase {

    private final BookingRepository bookingRepository;

    public Booking execute(
            Long serviceId,
            String customerName,
            String customerEmail,
            String customerWhatsapp,
            String customerComments,
            LocalDate bookingDate,
            LocalTime bookingTime,
            Integer durationMinutes,
            BigDecimal amount) {

        log.info("Creating booking for service {} on {} at {}", serviceId, bookingDate, bookingTime);

        // Calcular hora de fin
        LocalTime bookingEndTime = bookingTime.plusMinutes(durationMinutes);

        // Validar disponibilidad real (rangos de tiempo)
        if (!bookingRepository.isTimeSlotAvailable(serviceId, bookingDate, bookingTime, bookingEndTime)) {
            throw new ValidationException(
                    "El horario seleccionado (" + bookingTime + " - " + bookingEndTime + ") no está disponible."
            );
        }

        // Crear value objects
        CustomerInfo customerInfo = new CustomerInfo(
                customerName,
                customerEmail,
                customerWhatsapp,
                customerComments
        );

        TimeSlot timeSlot = new TimeSlot(bookingDate, bookingTime);

        // Crear booking aggregate
        Booking booking = Booking.builder()
                .bookingNumber(generateBookingNumber())
                .serviceId(serviceId)
                .customerInfo(customerInfo)
                .timeSlot(timeSlot)
                .durationMinutes(durationMinutes)
                .status(BookingStatus.PENDING)
                .paymentStatus(PaymentStatus.PENDING)
                .amount(amount)
                .createdAt(LocalDateTime.now())
                .updatedAt(LocalDateTime.now())
                .build();

        // Persistir
        Booking saved = bookingRepository.save(booking);
        log.info("Booking created successfully: {}", saved.getBookingNumber());

        return saved;
    }

    private String generateBookingNumber() {
        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd-HHmmss"));
        return "BOOK-" + timestamp;
    }
}

========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/application/usecase/GetAvailableSlotsUseCase.java ==========
package com.flavia.dermobeauty.booking.application.usecase;

import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.domain.BookingRepository;
import com.flavia.dermobeauty.catalog.entity.ServiceEntity;
import com.flavia.dermobeauty.catalog.repository.ServiceRepository;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component; // Usamos Component o Service para inyección

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.List;

@Slf4j
@Component
@RequiredArgsConstructor
public class GetAvailableSlotsUseCase {

    private final BookingRepository bookingRepository;
    private final ServiceRepository serviceRepository;

    // TODO: Mover esto a ConfigService en el futuro
    private static final LocalTime OPEN_TIME = LocalTime.of(9, 0);
    private static final LocalTime CLOSE_TIME = LocalTime.of(19, 0);
    private static final int SLOT_INTERVAL_MINUTES = 30;

    public List<LocalTime> execute(Long serviceId, LocalDate date) {
        log.debug("Calculating availability for service {} on {}", serviceId, date);

        // 1. Obtener duración del servicio
        ServiceEntity service = serviceRepository.findById(serviceId)
                .orElseThrow(() -> new ResourceNotFoundException("Service", serviceId));
        int durationMinutes = service.getDurationMinutes();

        // 2. Obtener reservas existentes del día (Confirmadas o Pendientes)
        List<Booking> existingBookings = bookingRepository.findByDate(date);

        // 3. Calcular slots
        List<LocalTime> availableSlots = new ArrayList<>();
        LocalTime currentSlot = OPEN_TIME;

        // Iteramos mientras el servicio termine antes o a la hora de cierre
        while (canServiceFit(currentSlot, durationMinutes, CLOSE_TIME)) {

            LocalTime endSlot = currentSlot.plusMinutes(durationMinutes);

            if (isSlotFree(currentSlot, endSlot, existingBookings)) {
                availableSlots.add(currentSlot);
            }

            // Avanzamos 30 minutos
            currentSlot = currentSlot.plusMinutes(SLOT_INTERVAL_MINUTES);
        }

        return availableSlots;
    }

    private boolean canServiceFit(LocalTime start, int duration, LocalTime closeTime) {
        // Validación segura de overflow de día
        if (start.plusMinutes(duration).isBefore(start)) return false; // Pasó medianoche
        return !start.plusMinutes(duration).isAfter(closeTime);
    }

    private boolean isSlotFree(LocalTime newStart, LocalTime newEnd, List<Booking> bookings) {
        for (Booking b : bookings) {
            LocalTime bStart = b.getTimeSlot().getTime();
            LocalTime bEnd = bStart.plusMinutes(b.getDurationMinutes());

            // Lógica de solapamiento:
            // (StartA < EndB) y (EndA > StartB)
            if (newStart.isBefore(bEnd) && newEnd.isAfter(bStart)) {
                return false; // Hay colisión
            }
        }
        return true;
    }
}

========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/application/usecase/GetBookingByNumberUseCase.java ==========
package com.flavia.dermobeauty.booking.application.usecase;

import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.domain.BookingRepository;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Use Case: Get booking by booking number.
 * Used by customers to check their booking status.
 */
@Slf4j
@RequiredArgsConstructor
public class GetBookingByNumberUseCase {

    private final BookingRepository bookingRepository;

    public Booking execute(String bookingNumber) {
        log.debug("Fetching booking by number: {}", bookingNumber);

        return bookingRepository.findByBookingNumber(bookingNumber)
                .orElseThrow(() -> new ResourceNotFoundException("Booking with number '" + bookingNumber + "' not found"));
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/application/usecase/ListBookingsUseCase.java ==========
package com.flavia.dermobeauty.booking.application.usecase;

import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.domain.BookingRepository;
import com.flavia.dermobeauty.booking.domain.BookingStatus;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.util.List;

/**
 * Use Case: List bookings for admin panel.
 * Supports filtering by status.
 */
@Slf4j
@RequiredArgsConstructor
public class ListBookingsUseCase {

    private final BookingRepository bookingRepository;

    public List<Booking> execute() {
        log.debug("Fetching all bookings");
        return bookingRepository.findAll();
    }

    public List<Booking> executeByStatus(BookingStatus status) {
        log.debug("Fetching bookings with status: {}", status);
        return bookingRepository.findByStatus(status);
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/config/BookingConfig.java ==========
package com.flavia.dermobeauty.booking.config;

import com.flavia.dermobeauty.booking.application.port.NotificationService;
import com.flavia.dermobeauty.booking.application.usecase.*;
import com.flavia.dermobeauty.booking.domain.BookingRepository;
import com.flavia.dermobeauty.catalog.repository.ServiceRepository;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * Configuration class for Booking module.
 * Wires use cases as Spring beans for dependency injection.
 */
@Configuration
public class BookingConfig {

    @Bean
    public CreateBookingUseCase createBookingUseCase(BookingRepository bookingRepository) {
        return new CreateBookingUseCase(bookingRepository);
    }

    @Bean
    public ConfirmBookingPaymentUseCase confirmBookingPaymentUseCase(
            BookingRepository bookingRepository,
            NotificationService notificationService) {
        return new ConfirmBookingPaymentUseCase(bookingRepository, notificationService);
    }

    @Bean
    public ListBookingsUseCase listBookingsUseCase(BookingRepository bookingRepository) {
        return new ListBookingsUseCase(bookingRepository);
    }

    @Bean
    public CancelBookingUseCase cancelBookingUseCase(BookingRepository bookingRepository) {
        return new CancelBookingUseCase(bookingRepository);
    }

    @Bean
    public GetBookingByNumberUseCase getBookingByNumberUseCase(BookingRepository bookingRepository) {
        return new GetBookingByNumberUseCase(bookingRepository);
    }

    @Bean
    public GetAvailableSlotsUseCase getAvailableSlotsUseCase(
            BookingRepository bookingRepository,
            ServiceRepository serviceRepository
    ) {
        return new GetAvailableSlotsUseCase(bookingRepository, serviceRepository);
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/domain/Booking.java ==========
package com.flavia.dermobeauty.booking.domain;

import com.flavia.dermobeauty.shared.exception.DomainException;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;

import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * Booking Aggregate Root.
 * Represents a service booking/appointment with business rules enforcement.
 */
@Getter
@AllArgsConstructor
@Builder
public class Booking {

    private Long id;
    private String bookingNumber;
    private Long serviceId;
    private CustomerInfo customerInfo;
    private TimeSlot timeSlot;
    private Integer durationMinutes;
    private BookingStatus status;
    private PaymentStatus paymentStatus;
    private String mercadoPagoPreferenceId;
    private String mercadoPagoPaymentId;
    private BigDecimal amount;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    private LocalDateTime confirmedAt;
    private LocalDateTime cancelledAt;

    /**
     * Confirms payment for this booking.
     * Business rule: can only confirm payment once, and only from PENDING status.
     *
     * @param paymentId Mercado Pago payment ID
     */
    public void confirmPayment(String paymentId) {
        if (this.paymentStatus == PaymentStatus.PAID) {
            throw new DomainException("Payment already confirmed for booking " + bookingNumber);
        }

        if (this.status == BookingStatus.CANCELLED) {
            throw new DomainException("Cannot confirm payment for cancelled booking " + bookingNumber);
        }

        if (paymentId == null || paymentId.isBlank()) {
            throw new IllegalArgumentException("Payment ID cannot be empty");
        }

        this.mercadoPagoPaymentId = paymentId;
        this.paymentStatus = PaymentStatus.PAID;
        this.status = BookingStatus.CONFIRMED;
        this.confirmedAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Cancels this booking.
     * Business rule: cannot cancel already completed bookings, cannot cancel twice.
     */
    public void cancel() {
        if (this.status == BookingStatus.CANCELLED) {
            throw new DomainException("Booking " + bookingNumber + " is already cancelled");
        }

        if (this.status == BookingStatus.COMPLETED) {
            throw new DomainException("Cannot cancel completed booking " + bookingNumber);
        }

        this.status = BookingStatus.CANCELLED;
        this.cancelledAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Marks booking as completed (service was provided).
     * Business rule: can only complete confirmed bookings.
     */
    public void complete() {
        if (this.status != BookingStatus.CONFIRMED) {
            throw new DomainException("Can only complete confirmed bookings. Current status: " + status);
        }

        this.status = BookingStatus.COMPLETED;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Validates that the booking slot is available (business rule).
     *
     * @return true if slot is valid for booking
     */
    public boolean isSlotAvailable() {
        return timeSlot.isFuture() && status != BookingStatus.CANCELLED;
    }

    /**
     * Checks if this booking can be cancelled.
     */
    public boolean isCancellable() {
        return status != BookingStatus.CANCELLED && status != BookingStatus.COMPLETED;
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/domain/BookingRepository.java ==========
package com.flavia.dermobeauty.booking.domain;

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.List;
import java.util.Optional;

/**
 * Repository port (interface) for Booking aggregate.
 * Defines operations needed by the domain layer without specifying implementation.
 * Implementation will be provided by infrastructure layer.
 */
public interface BookingRepository {

    /**
     * Save a booking (create or update).
     */
    Booking save(Booking booking);

    /**
     * Find booking by ID.
     */
    Optional<Booking> findById(Long id);

    /**
     * Find booking by booking number.
     */
    Optional<Booking> findByBookingNumber(String bookingNumber);

    /**
     * Find booking by Mercado Pago payment ID.
     */
    Optional<Booking> findByMercadoPagoPaymentId(String paymentId);

    /**
     * Check if a slot is already booked for a service.
     * Returns true if there's an active (non-cancelled) booking for this slot.
     */
    boolean isTimeSlotAvailable(Long serviceId, LocalDate date, LocalTime startTime, LocalTime endTime);

    /**
     * Find all bookings (for admin).
     */
    List<Booking> findAll();

    /**
     * Find bookings by status (for admin filtering).
     */
    List<Booking> findByStatus(BookingStatus status);

    List<Booking> findByDate(LocalDate date);

}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/domain/BookingStatus.java ==========
package com.flavia.dermobeauty.booking.domain;

/**
 * Domain enum representing the lifecycle status of a booking.
 */
public enum BookingStatus {
    PENDING,    // Initial state, payment not yet completed
    CONFIRMED,  // Payment completed, booking confirmed
    CANCELLED,  // Booking cancelled (by admin or customer)
    COMPLETED   // Service was provided
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/domain/CustomerInfo.java ==========
package com.flavia.dermobeauty.booking.domain;

import lombok.Value;

/**
 * Value Object representing customer information for a booking.
 * Immutable to ensure consistency.
 */
@Value
public class CustomerInfo {
    String name;
    String email;
    String whatsapp;
    String comments;

    public CustomerInfo(String name, String email, String whatsapp, String comments) {
        if (name == null || name.isBlank()) {
            throw new IllegalArgumentException("Customer name cannot be empty");
        }
        if (email == null || email.isBlank()) {
            throw new IllegalArgumentException("Customer email cannot be empty");
        }
        if (whatsapp == null || whatsapp.isBlank()) {
            throw new IllegalArgumentException("Customer whatsapp cannot be empty");
        }

        this.name = name;
        this.email = email;
        this.whatsapp = whatsapp;
        this.comments = comments;
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/domain/PaymentStatus.java ==========
package com.flavia.dermobeauty.booking.domain;

/**
 * Domain enum representing the payment status of a booking.
 */
public enum PaymentStatus {
    PENDING,   // Payment not yet initiated or in progress
    PAID,      // Payment successfully completed
    FAILED,    // Payment failed
    REFUNDED   // Payment was refunded
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/domain/TimeSlot.java ==========
package com.flavia.dermobeauty.booking.domain;

import lombok.Value;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;

/**
 * Value Object representing a specific date and time slot for a booking.
 * Immutable to ensure consistency.
 */
@Value
public class TimeSlot {
    LocalDate date;
    LocalTime time;

    public TimeSlot(LocalDate date, LocalTime time) {
        if (date == null) {
            throw new IllegalArgumentException("Date cannot be null");
        }
        if (time == null) {
            throw new IllegalArgumentException("Time cannot be null");
        }
        if (date.isBefore(LocalDate.now())) {
            throw new IllegalArgumentException("Cannot book appointments in the past");
        }

        this.date = date;
        this.time = time;
    }

    public LocalDateTime toDateTime() {
        return LocalDateTime.of(date, time);
    }

    public boolean isFuture() {
        return toDateTime().isAfter(LocalDateTime.now());
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/infrastructure/mapper/BookingMapper.java ==========
package com.flavia.dermobeauty.booking.infrastructure.mapper;

import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.domain.CustomerInfo;
import com.flavia.dermobeauty.booking.domain.TimeSlot;
import com.flavia.dermobeauty.booking.infrastructure.persistence.BookingEntity;
import org.springframework.stereotype.Component;

/**
 * Mapper between Booking domain model and BookingEntity JPA entity.
 * Handles conversion in both directions.
 */
@Component
public class BookingMapper {

    /**
     * Convert domain Booking to JPA BookingEntity.
     */
    public BookingEntity toEntity(Booking booking) {
        return BookingEntity.builder()
                .id(booking.getId())
                .bookingNumber(booking.getBookingNumber())
                .serviceId(booking.getServiceId())
                .customerName(booking.getCustomerInfo().getName())
                .customerEmail(booking.getCustomerInfo().getEmail())
                .customerWhatsapp(booking.getCustomerInfo().getWhatsapp())
                .customerComments(booking.getCustomerInfo().getComments())
                .bookingDate(booking.getTimeSlot().getDate())
                .bookingTime(booking.getTimeSlot().getTime())
                .durationMinutes(booking.getDurationMinutes())
                .status(booking.getStatus())
                .paymentStatus(booking.getPaymentStatus())
                .mercadoPagoPreferenceId(booking.getMercadoPagoPreferenceId())
                .mercadoPagoPaymentId(booking.getMercadoPagoPaymentId())
                .amount(booking.getAmount())
                .createdAt(booking.getCreatedAt())
                .updatedAt(booking.getUpdatedAt())
                .confirmedAt(booking.getConfirmedAt())
                .cancelledAt(booking.getCancelledAt())
                .build();
    }

    /**
     * Convert JPA BookingEntity to domain Booking.
     */
    public Booking toDomain(BookingEntity entity) {
        CustomerInfo customerInfo = new CustomerInfo(
                entity.getCustomerName(),
                entity.getCustomerEmail(),
                entity.getCustomerWhatsapp(),
                entity.getCustomerComments()
        );

        TimeSlot timeSlot = new TimeSlot(
                entity.getBookingDate(),
                entity.getBookingTime()
        );

        return Booking.builder()
                .id(entity.getId())
                .bookingNumber(entity.getBookingNumber())
                .serviceId(entity.getServiceId())
                .customerInfo(customerInfo)
                .timeSlot(timeSlot)
                .durationMinutes(entity.getDurationMinutes())
                .status(entity.getStatus())
                .paymentStatus(entity.getPaymentStatus())
                .mercadoPagoPreferenceId(entity.getMercadoPagoPreferenceId())
                .mercadoPagoPaymentId(entity.getMercadoPagoPaymentId())
                .amount(entity.getAmount())
                .createdAt(entity.getCreatedAt())
                .updatedAt(entity.getUpdatedAt())
                .confirmedAt(entity.getConfirmedAt())
                .cancelledAt(entity.getCancelledAt())
                .build();
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/infrastructure/notification/StubNotificationService.java ==========
package com.flavia.dermobeauty.booking.infrastructure.notification;

import com.flavia.dermobeauty.booking.application.port.NotificationService;
import com.flavia.dermobeauty.booking.domain.Booking;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

/**
 * Stub implementation of NotificationService for Phase 5.
 * Will be replaced with full email implementation in Phase 8.
 */
@Slf4j
@Service
public class StubNotificationService implements NotificationService {

    @Override
    public void sendBookingConfirmation(Booking booking) {
        log.info("STUB: Would send booking confirmation email for {} to {}",
                booking.getBookingNumber(),
                booking.getCustomerInfo().getEmail());

        // No-op for now - will implement email sending in Phase 8
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/infrastructure/persistence/BookingEntity.java ==========
package com.flavia.dermobeauty.booking.infrastructure.persistence;

import com.flavia.dermobeauty.booking.domain.BookingStatus;
import com.flavia.dermobeauty.booking.domain.PaymentStatus;
import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;

/**
 * JPA entity for bookings table.
 * Infrastructure layer representation of Booking aggregate.
 */
@Entity
@Table(name = "bookings")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class BookingEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @EqualsAndHashCode.Include
    private Long id;

    @Column(name = "booking_number", nullable = false, unique = true, length = 50)
    private String bookingNumber;

    @Column(name = "service_id", nullable = false)
    private Long serviceId;

    // Customer information (embedded fields)
    @Column(name = "customer_name", nullable = false, length = 200)
    private String customerName;

    @Column(name = "customer_email", nullable = false, length = 200)
    private String customerEmail;

    @Column(name = "customer_whatsapp", nullable = false, length = 50)
    private String customerWhatsapp;

    @Column(name = "customer_comments", columnDefinition = "TEXT")
    private String customerComments;

    // Time slot (embedded fields)
    @Column(name = "booking_date", nullable = false)
    private LocalDate bookingDate;

    @Column(name = "booking_time", nullable = false)
    private LocalTime bookingTime;

    @Column(name = "duration_minutes", nullable = false)
    private Integer durationMinutes;

    // Status tracking
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private BookingStatus status;

    // Payment information
    @Enumerated(EnumType.STRING)
    @Column(name = "payment_status", nullable = false, length = 20)
    private PaymentStatus paymentStatus;

    @Column(name = "mercadopago_preference_id", length = 200)
    private String mercadoPagoPreferenceId;

    @Column(name = "mercadopago_payment_id", length = 200)
    private String mercadoPagoPaymentId;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal amount;

    // Timestamps
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @Column(name = "confirmed_at")
    private LocalDateTime confirmedAt;

    @Column(name = "cancelled_at")
    private LocalDateTime cancelledAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = LocalDateTime.now();
        }
        if (updatedAt == null) {
            updatedAt = LocalDateTime.now();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/infrastructure/persistence/BookingRepositoryAdapter.java ==========
package com.flavia.dermobeauty.booking.infrastructure.persistence;

import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.domain.BookingRepository;
import com.flavia.dermobeauty.booking.domain.BookingStatus;
import com.flavia.dermobeauty.booking.infrastructure.mapper.BookingMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Adapter that implements the domain BookingRepository port using JPA.
 * Bridges between domain layer and infrastructure layer.
 */
@Component
@RequiredArgsConstructor
public class BookingRepositoryAdapter implements BookingRepository {

    private final JpaBookingRepository jpaRepository;
    private final BookingMapper mapper;

    @Override
    public Booking save(Booking booking) {
        BookingEntity entity = mapper.toEntity(booking);
        BookingEntity saved = jpaRepository.save(entity);
        return mapper.toDomain(saved);
    }

    @Override
    public Optional<Booking> findById(Long id) {
        return jpaRepository.findById(id)
                .map(mapper::toDomain);
    }

    @Override
    public List<Booking> findByDate(LocalDate date) {
        // Buscamos por fecha y excluimos los CANCELLED
        return jpaRepository.findByBookingDateAndStatusNot(date, BookingStatus.CANCELLED)
                .stream()
                .map(mapper::toDomain)
                .collect(Collectors.toList());
    }

    @Override
    public Optional<Booking> findByBookingNumber(String bookingNumber) {
        return jpaRepository.findByBookingNumber(bookingNumber)
                .map(mapper::toDomain);
    }

    @Override
    public Optional<Booking> findByMercadoPagoPaymentId(String paymentId) {
        return jpaRepository.findByMercadoPagoPaymentId(paymentId)
                .map(mapper::toDomain);
    }

    @Override
    public boolean isTimeSlotAvailable(Long serviceId, LocalDate date, LocalTime startTime, LocalTime endTime) {
        return !jpaRepository.existsOverlappingBooking(serviceId, date, startTime, endTime);
    }

    @Override
    public List<Booking> findAll() {
        return jpaRepository.findAll()
                .stream()
                .map(mapper::toDomain)
                .collect(Collectors.toList());
    }

    @Override
    public List<Booking> findByStatus(BookingStatus status) {
        return jpaRepository.findByStatus(status)
                .stream()
                .map(mapper::toDomain)
                .collect(Collectors.toList());
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/infrastructure/persistence/JpaBookingRepository.java ==========
package com.flavia.dermobeauty.booking.infrastructure.persistence;

import com.flavia.dermobeauty.booking.domain.BookingStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.List;
import java.util.Optional;

/**
 * Spring Data JPA repository for BookingEntity.
 * Infrastructure implementation detail.
 */
@Repository
public interface JpaBookingRepository extends JpaRepository<BookingEntity, Long> {

    Optional<BookingEntity> findByBookingNumber(String bookingNumber);

    Optional<BookingEntity> findByMercadoPagoPaymentId(String paymentId);

    List<BookingEntity> findByStatus(BookingStatus status);

    List<BookingEntity> findByBookingDateAndStatusNot(LocalDate bookingDate, BookingStatus status);

    // Un turno se solapa si: (StartA < EndB) y (StartB < EndA)
    @Query(value = """
           SELECT CASE WHEN COUNT(*) > 0 THEN true ELSE false END
           FROM bookings b
           WHERE b.service_id = :serviceId
           AND b.booking_date = :date
           AND b.status != 'CANCELLED'
           AND (
               b.booking_time < :endTime
               AND :startTime < (b.booking_time + (b.duration_minutes * interval '1 minute'))
           )
           """, nativeQuery = true)
    boolean existsOverlappingBooking(
            @Param("serviceId") Long serviceId,
            @Param("date") LocalDate date,
            @Param("startTime") LocalTime startTime,
            @Param("endTime") LocalTime endTime
    );
}

========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/web/AvailabilityController.java ==========
package com.flavia.dermobeauty.booking.web;

import com.flavia.dermobeauty.booking.application.usecase.GetAvailableSlotsUseCase;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.List;

@RestController
@RequestMapping("/api/public/availability")
@RequiredArgsConstructor
public class AvailabilityController {

    private final GetAvailableSlotsUseCase getAvailableSlotsUseCase;

    @GetMapping
    public ResponseEntity<ApiResponse<List<LocalTime>>> getAvailability(
            @RequestParam Long serviceId,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate date) {

        List<LocalTime> slots = getAvailableSlotsUseCase.execute(serviceId, date);
        return ResponseEntity.ok(ApiResponse.success(slots));
    }
}

========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/web/BookingController.java ==========
package com.flavia.dermobeauty.booking.web;

import com.flavia.dermobeauty.booking.application.usecase.CreateBookingUseCase;
import com.flavia.dermobeauty.booking.application.usecase.GetBookingByNumberUseCase;
import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.web.dto.BookingResponse;
import com.flavia.dermobeauty.booking.web.dto.CreateBookingRequest;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

/**
 * REST controller for booking operations.
 * Public endpoints for customers to create and check bookings.
 */
@Slf4j
@RestController
@RequestMapping("/api/public/bookings")
@RequiredArgsConstructor
public class BookingController {

    private final CreateBookingUseCase createBookingUseCase;
    private final GetBookingByNumberUseCase getBookingByNumberUseCase;

    @PostMapping
    public ResponseEntity<ApiResponse<BookingResponse>> createBooking(
            @Valid @RequestBody CreateBookingRequest request) {

        log.info("Creating booking for service {} on {} at {}",
                request.getServiceId(), request.getBookingDate(), request.getBookingTime());

        Booking booking = createBookingUseCase.execute(
                request.getServiceId(),
                request.getCustomerName(),
                request.getCustomerEmail(),
                request.getCustomerWhatsapp(),
                request.getCustomerComments(),
                request.getBookingDate(),
                request.getBookingTime(),
                request.getDurationMinutes(),
                request.getAmount()
        );

        BookingResponse response = BookingResponse.fromDomain(booking);
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.success(response, "Booking created successfully"));
    }

    @GetMapping("/{bookingNumber}")
    public ResponseEntity<ApiResponse<BookingResponse>> getBookingByNumber(
            @PathVariable String bookingNumber) {

        log.debug("Fetching booking: {}", bookingNumber);

        Booking booking = getBookingByNumberUseCase.execute(bookingNumber);
        BookingResponse response = BookingResponse.fromDomain(booking);

        return ResponseEntity.ok(ApiResponse.success(response));
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/web/dto/BookingResponse.java ==========
package com.flavia.dermobeauty.booking.web.dto;

import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.domain.BookingStatus;
import com.flavia.dermobeauty.booking.domain.PaymentStatus;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;

/**
 * DTO for booking response.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class BookingResponse {

    private Long id;
    private String bookingNumber;
    private Long serviceId;
    private String customerName;
    private String customerEmail;
    private String customerWhatsapp;
    private String customerComments;
    private LocalDate bookingDate;
    private LocalTime bookingTime;
    private Integer durationMinutes;
    private BookingStatus status;
    private PaymentStatus paymentStatus;
    private String mercadoPagoPreferenceId;
    private BigDecimal amount;
    private LocalDateTime createdAt;
    private LocalDateTime confirmedAt;

    public static BookingResponse fromDomain(Booking booking) {
        return BookingResponse.builder()
                .id(booking.getId())
                .bookingNumber(booking.getBookingNumber())
                .serviceId(booking.getServiceId())
                .customerName(booking.getCustomerInfo().getName())
                .customerEmail(booking.getCustomerInfo().getEmail())
                .customerWhatsapp(booking.getCustomerInfo().getWhatsapp())
                .customerComments(booking.getCustomerInfo().getComments())
                .bookingDate(booking.getTimeSlot().getDate())
                .bookingTime(booking.getTimeSlot().getTime())
                .durationMinutes(booking.getDurationMinutes())
                .status(booking.getStatus())
                .paymentStatus(booking.getPaymentStatus())
                .mercadoPagoPreferenceId(booking.getMercadoPagoPreferenceId())
                .amount(booking.getAmount())
                .createdAt(booking.getCreatedAt())
                .confirmedAt(booking.getConfirmedAt())
                .build();
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/web/dto/CreateBookingRequest.java ==========
package com.flavia.dermobeauty.booking.web.dto;

import jakarta.validation.constraints.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalTime;

/**
 * DTO for creating a new booking request.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateBookingRequest {

    @NotNull(message = "Service ID is required")
    private Long serviceId;

    @NotBlank(message = "Customer name is required")
    private String customerName;

    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    private String customerEmail;

    @NotBlank(message = "WhatsApp number is required")
    private String customerWhatsapp;

    private String customerComments;

    @NotNull(message = "Booking date is required")
    @Future(message = "Booking date must be in the future")
    private LocalDate bookingDate;

    @NotNull(message = "Booking time is required")
    private LocalTime bookingTime;

    @NotNull(message = "Duration is required")
    @Min(value = 1, message = "Duration must be at least 1 minute")
    private Integer durationMinutes;

    @NotNull(message = "Amount is required")
    @DecimalMin(value = "0.0", inclusive = false, message = "Amount must be greater than 0")
    private BigDecimal amount;
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/controller/AdminCatalogController.java ==========
package com.flavia.dermobeauty.catalog.controller;

import com.flavia.dermobeauty.catalog.dto.CategoryDto;
import com.flavia.dermobeauty.catalog.dto.ProductDto;
import com.flavia.dermobeauty.catalog.dto.ServiceDto;
import com.flavia.dermobeauty.catalog.entity.CategoryEntity;
import com.flavia.dermobeauty.catalog.repository.CategoryRepository;
import com.flavia.dermobeauty.catalog.service.ProductCatalogService;
import com.flavia.dermobeauty.catalog.service.ServiceCatalogService;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

@Slf4j
@RestController
@RequestMapping("/api/admin")
@RequiredArgsConstructor
public class AdminCatalogController {

    private final ServiceCatalogService serviceService;
    private final ProductCatalogService productService;
    private final CategoryRepository categoryRepository;

    // ==================== SERVICES ====================

    @GetMapping("/services")
    public ResponseEntity<ApiResponse<List<ServiceDto>>> getAllServices() {
        return ResponseEntity.ok(ApiResponse.success(serviceService.getAllForAdmin()));
    }

    @GetMapping("/services/{id}")
    public ResponseEntity<ApiResponse<ServiceDto>> getService(@PathVariable Long id) {
        return ResponseEntity.ok(ApiResponse.success(serviceService.getById(id)));
    }

    @PostMapping("/services")
    public ResponseEntity<ApiResponse<ServiceDto>> createService(@Valid @RequestBody ServiceDto dto) {
        return ResponseEntity.ok(ApiResponse.success(serviceService.create(dto), "Servicio creado"));
    }

    @PutMapping("/services/{id}")
    public ResponseEntity<ApiResponse<ServiceDto>> updateService(@PathVariable Long id, @Valid @RequestBody ServiceDto dto) {
        return ResponseEntity.ok(ApiResponse.success(serviceService.update(id, dto), "Servicio actualizado"));
    }

    @DeleteMapping("/services/{id}")
    public ResponseEntity<ApiResponse<Void>> deleteService(@PathVariable Long id) {
        serviceService.delete(id);
        return ResponseEntity.ok(ApiResponse.success("Servicio eliminado"));
    }

    @PatchMapping("/services/{id}/featured")
    public ResponseEntity<ApiResponse<ServiceDto>> toggleServiceFeatured(@PathVariable Long id) {
        // Obtenemos actual, invertimos flag y guardamos
        ServiceDto current = serviceService.getById(id);
        current.setIsFeatured(!current.getIsFeatured());
        return ResponseEntity.ok(ApiResponse.success(serviceService.update(id, current)));
    }

    // ==================== PRODUCTS ====================

    @GetMapping("/products")
    public ResponseEntity<ApiResponse<List<ProductDto>>> getAllProducts() {
        return ResponseEntity.ok(ApiResponse.success(productService.getAllForAdmin()));
    }

    @GetMapping("/products/{id}")
    public ResponseEntity<ApiResponse<ProductDto>> getProduct(@PathVariable Long id) {
        return ResponseEntity.ok(ApiResponse.success(productService.getById(id)));
    }

    @PostMapping("/products")
    public ResponseEntity<ApiResponse<ProductDto>> createProduct(@Valid @RequestBody ProductDto dto) {
        return ResponseEntity.ok(ApiResponse.success(productService.create(dto), "Producto creado"));
    }

    @PutMapping("/products/{id}")
    public ResponseEntity<ApiResponse<ProductDto>> updateProduct(@PathVariable Long id, @Valid @RequestBody ProductDto dto) {
        return ResponseEntity.ok(ApiResponse.success(productService.update(id, dto), "Producto actualizado"));
    }

    @DeleteMapping("/products/{id}")
    public ResponseEntity<ApiResponse<Void>> deleteProduct(@PathVariable Long id) {
        productService.delete(id);
        return ResponseEntity.ok(ApiResponse.success("Producto eliminado"));
    }

    @PatchMapping("/products/{id}/featured")
    public ResponseEntity<ApiResponse<ProductDto>> toggleProductFeatured(@PathVariable Long id) {
        ProductDto current = productService.getById(id);
        current.setIsFeatured(!current.getIsFeatured());
        return ResponseEntity.ok(ApiResponse.success(productService.update(id, current)));
    }

    // ==================== CATEGORIES ====================

    @GetMapping("/categories")
    public ResponseEntity<ApiResponse<List<CategoryDto>>> getAllCategories() {
        List<CategoryDto> categories = categoryRepository.findAll().stream()
                .map(CategoryDto::fromEntity)
                .collect(Collectors.toList());
        return ResponseEntity.ok(ApiResponse.success(categories));
    }

    @PostMapping("/categories")
    public ResponseEntity<ApiResponse<CategoryDto>> createCategory(@RequestBody CategoryEntity category) {
        // Simplificación: Guardamos directo la entidad (mejorar con DTO/Service en futuro)
        // Generar slug simple
        category.setSlug(category.getName().toLowerCase().replace(" ", "-"));
        CategoryEntity saved = categoryRepository.save(category);
        return ResponseEntity.ok(ApiResponse.success(CategoryDto.fromEntity(saved)));
    }

    @DeleteMapping("/categories/{id}")
    public ResponseEntity<ApiResponse<Void>> deleteCategory(@PathVariable Long id) {
        categoryRepository.deleteById(id);
        return ResponseEntity.ok(ApiResponse.success("Categoría eliminada"));
    }
}

========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/controller/CategoryController.java ==========
package com.flavia.dermobeauty.catalog.controller;

import com.flavia.dermobeauty.catalog.dto.CategoryDto;
import com.flavia.dermobeauty.catalog.entity.CategoryEntity;
import com.flavia.dermobeauty.catalog.repository.CategoryRepository;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Public REST controller for category operations.
 * Provides endpoints for browsing categories.
 */
@RestController
@RequestMapping("/api/public/categories")
@RequiredArgsConstructor
public class CategoryController {

    private final CategoryRepository categoryRepository;

    @GetMapping
    public ResponseEntity<ApiResponse<List<CategoryDto>>> getAllCategories() {
        List<CategoryDto> categories = categoryRepository.findAll()
                .stream()
                .map(CategoryDto::fromEntity)
                .collect(Collectors.toList());
        return ResponseEntity.ok(ApiResponse.success(categories));
    }

    @GetMapping("/type/{type}")
    public ResponseEntity<ApiResponse<List<CategoryDto>>> getCategoriesByType(@PathVariable CategoryEntity.CategoryType type) {
        List<CategoryDto> categories = categoryRepository.findByType(type)
                .stream()
                .map(CategoryDto::fromEntity)
                .collect(Collectors.toList());
        return ResponseEntity.ok(ApiResponse.success(categories));
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/controller/FileUploadController.java ==========
package com.flavia.dermobeauty.catalog.controller;

import com.flavia.dermobeauty.shared.exception.ValidationException;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.net.MalformedURLException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;

/**
 * Controller for file upload and retrieval.
 * Handles image uploads for services and products.
 */
@Slf4j
@RestController
@RequestMapping("/api")
public class FileUploadController {

    private static final List<String> ALLOWED_CONTENT_TYPES = Arrays.asList(
            "image/jpeg", "image/jpg", "image/png", "image/webp"
    );
    private static final long MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB

    private final Path uploadPath;

    public FileUploadController(@Value("${app.upload-dir}") String uploadDir) {
        this.uploadPath = Paths.get(uploadDir).toAbsolutePath().normalize();
        try {
            Files.createDirectories(this.uploadPath);
            log.info("Upload directory created at: {}", this.uploadPath);
        } catch (IOException e) {
            throw new RuntimeException("Could not create upload directory", e);
        }
    }

    @PostMapping("/admin/uploads")
    public ResponseEntity<ApiResponse<String>> uploadFile(@RequestParam("file") MultipartFile file) {
        validateFile(file);

        try {
            String originalFilename = file.getOriginalFilename();
            String extension = originalFilename != null && originalFilename.contains(".")
                    ? originalFilename.substring(originalFilename.lastIndexOf("."))
                    : ".jpg";

            String filename = UUID.randomUUID().toString() + extension;
            Path targetLocation = uploadPath.resolve(filename);

            Files.copy(file.getInputStream(), targetLocation, StandardCopyOption.REPLACE_EXISTING);
            log.info("File uploaded successfully: {}", filename);

            String fileUrl = "/api/uploads/" + filename;
            return ResponseEntity.ok(ApiResponse.success(fileUrl, "File uploaded successfully"));

        } catch (IOException e) {
            log.error("Failed to upload file", e);
            throw new ValidationException("Failed to upload file: " + e.getMessage());
        }
    }

    @GetMapping("/uploads/{filename:.+}")
    public ResponseEntity<Resource> getFile(@PathVariable String filename) {
        try {
            Path filePath = uploadPath.resolve(filename).normalize();
            Resource resource = new UrlResource(filePath.toUri());

            if (!resource.exists() || !resource.isReadable()) {
                throw new ValidationException("File not found: " + filename);
            }

            String contentType = Files.probeContentType(filePath);
            if (contentType == null) {
                contentType = "application/octet-stream";
            }

            return ResponseEntity.ok()
                    .contentType(MediaType.parseMediaType(contentType))
                    .header(HttpHeaders.CONTENT_DISPOSITION, "inline; filename=\"" + resource.getFilename() + "\"")
                    .body(resource);

        } catch (MalformedURLException e) {
            log.error("Invalid file path: {}", filename, e);
            throw new ValidationException("Invalid file path");
        } catch (IOException e) {
            log.error("Error reading file: {}", filename, e);
            throw new ValidationException("Error reading file");
        }
    }

    private void validateFile(MultipartFile file) {
        if (file.isEmpty()) {
            throw new ValidationException("File is empty");
        }

        if (file.getSize() > MAX_FILE_SIZE) {
            throw new ValidationException("File size exceeds maximum allowed (5MB)");
        }

        String contentType = file.getContentType();
        if (contentType == null || !ALLOWED_CONTENT_TYPES.contains(contentType)) {
            throw new ValidationException("Invalid file type. Allowed types: JPEG, PNG, WebP");
        }
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/controller/ProductController.java ==========
package com.flavia.dermobeauty.catalog.controller;

import com.flavia.dermobeauty.catalog.dto.ProductDto;
import com.flavia.dermobeauty.catalog.service.ProductCatalogService;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * Public REST controller for product catalog operations.
 * Provides endpoints for browsing available products.
 */
@RestController
@RequestMapping("/api/public/products")
@RequiredArgsConstructor
public class ProductController {

    private final ProductCatalogService productCatalogService;

    @GetMapping
    public ResponseEntity<ApiResponse<List<ProductDto>>> getAllProducts() {
        List<ProductDto> products = productCatalogService.getAllActive();
        return ResponseEntity.ok(ApiResponse.success(products));
    }

    @GetMapping("/featured")
    public ResponseEntity<ApiResponse<List<ProductDto>>> getFeaturedProducts() {
        List<ProductDto> products = productCatalogService.getFeatured();
        return ResponseEntity.ok(ApiResponse.success(products));
    }

    @GetMapping("/offers")
    public ResponseEntity<ApiResponse<List<ProductDto>>> getOfferProducts() {
        List<ProductDto> products = productCatalogService.getOffers();
        return ResponseEntity.ok(ApiResponse.success(products));
    }

    @GetMapping("/trending")
    public ResponseEntity<ApiResponse<List<ProductDto>>> getTrendingProducts() {
        List<ProductDto> products = productCatalogService.getTrending();
        return ResponseEntity.ok(ApiResponse.success(products));
    }

    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<ProductDto>> getProductById(@PathVariable Long id) {
        ProductDto product = productCatalogService.getById(id);
        return ResponseEntity.ok(ApiResponse.success(product));
    }

    @GetMapping("/slug/{slug}")
    public ResponseEntity<ApiResponse<ProductDto>> getProductBySlug(@PathVariable String slug) {
        ProductDto product = productCatalogService.getBySlug(slug);
        return ResponseEntity.ok(ApiResponse.success(product));
    }

    @GetMapping("/category/{categoryId}")
    public ResponseEntity<ApiResponse<List<ProductDto>>> getProductsByCategory(@PathVariable Long categoryId) {
        List<ProductDto> products = productCatalogService.getByCategory(categoryId);
        return ResponseEntity.ok(ApiResponse.success(products));
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/controller/ServiceController.java ==========
package com.flavia.dermobeauty.catalog.controller;

import com.flavia.dermobeauty.catalog.dto.ServiceDto;
import com.flavia.dermobeauty.catalog.service.ServiceCatalogService;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * Public REST controller for service catalog operations.
 * Provides endpoints for browsing available services.
 */
@RestController
@RequestMapping("/api/public/services")
@RequiredArgsConstructor
public class ServiceController {

    private final ServiceCatalogService serviceCatalogService;

    @GetMapping
    public ResponseEntity<ApiResponse<List<ServiceDto>>> getAllServices() {
        List<ServiceDto> services = serviceCatalogService.getAllActive();
        return ResponseEntity.ok(ApiResponse.success(services));
    }

    @GetMapping("/featured")
    public ResponseEntity<ApiResponse<List<ServiceDto>>> getFeaturedServices() {
        List<ServiceDto> services = serviceCatalogService.getFeatured();
        return ResponseEntity.ok(ApiResponse.success(services));
    }

    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<ServiceDto>> getServiceById(@PathVariable Long id) {
        ServiceDto service = serviceCatalogService.getById(id);
        return ResponseEntity.ok(ApiResponse.success(service));
    }

    @GetMapping("/slug/{slug}")
    public ResponseEntity<ApiResponse<ServiceDto>> getServiceBySlug(@PathVariable String slug) {
        ServiceDto service = serviceCatalogService.getBySlug(slug);
        return ResponseEntity.ok(ApiResponse.success(service));
    }

    @GetMapping("/category/{categoryId}")
    public ResponseEntity<ApiResponse<List<ServiceDto>>> getServicesByCategory(@PathVariable Long categoryId) {
        List<ServiceDto> services = serviceCatalogService.getByCategory(categoryId);
        return ResponseEntity.ok(ApiResponse.success(services));
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/dto/CategoryDto.java ==========
package com.flavia.dermobeauty.catalog.dto;

import com.flavia.dermobeauty.catalog.entity.CategoryEntity;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO for category data transfer.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CategoryDto {

    private Long id;
    private String name;
    private String slug;
    private String description;
    private CategoryEntity.CategoryType type;

    public static CategoryDto fromEntity(CategoryEntity entity) {
        return CategoryDto.builder()
                .id(entity.getId())
                .name(entity.getName())
                .slug(entity.getSlug())
                .description(entity.getDescription())
                .type(entity.getType())
                .build();
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/dto/ProductDto.java ==========
package com.flavia.dermobeauty.catalog.dto;

import com.flavia.dermobeauty.catalog.entity.ProductEntity;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

/**
 * DTO for product data transfer with validation.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProductDto {

    private Long id;

    @NotBlank(message = "Name is required")
    private String name;

    private String slug;

    @NotBlank(message = "Description is required")
    private String description;

    private String shortDescription;

    @NotNull(message = "Price is required")
    @DecimalMin(value = "0.0", inclusive = false, message = "Price must be greater than 0")
    private BigDecimal price;

    @NotNull(message = "Stock is required")
    @Min(value = 0, message = "Stock cannot be negative")
    private Integer stock;

    @NotNull(message = "Category ID is required")
    private Long categoryId;

    private String categoryName;

    private String imageUrl;

    private Boolean isFeatured;

    private Boolean isOffer;

    private Boolean isTrending;

    private Boolean isActive;

    public static ProductDto fromEntity(ProductEntity entity) {
        return ProductDto.builder()
                .id(entity.getId())
                .name(entity.getName())
                .slug(entity.getSlug())
                .description(entity.getDescription())
                .shortDescription(entity.getShortDescription())
                .price(entity.getPrice())
                .stock(entity.getStock())
                .categoryId(entity.getCategory().getId())
                .categoryName(entity.getCategory().getName())
                .imageUrl(entity.getImageUrl())
                .isFeatured(entity.getIsFeatured())
                .isOffer(entity.getIsOffer())
                .isTrending(entity.getIsTrending())
                .isActive(entity.getIsActive())
                .build();
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/dto/ServiceDto.java ==========
package com.flavia.dermobeauty.catalog.dto;

import com.flavia.dermobeauty.catalog.entity.ServiceEntity;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

/**
 * DTO for service data transfer with validation.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ServiceDto {

    private Long id;

    @NotBlank(message = "Name is required")
    private String name;

    private String slug;

    @NotBlank(message = "Description is required")
    private String description;

    private String shortDescription;

    @NotNull(message = "Duration is required")
    @Min(value = 1, message = "Duration must be at least 1 minute")
    private Integer durationMinutes;

    @NotNull(message = "Price is required")
    @DecimalMin(value = "0.0", inclusive = false, message = "Price must be greater than 0")
    private BigDecimal price;

    @NotNull(message = "Category ID is required")
    private Long categoryId;

    private String categoryName;

    private String imageUrl;

    private Boolean isFeatured;

    private Boolean isActive;

    public static ServiceDto fromEntity(ServiceEntity entity) {
        return ServiceDto.builder()
                .id(entity.getId())
                .name(entity.getName())
                .slug(entity.getSlug())
                .description(entity.getDescription())
                .shortDescription(entity.getShortDescription())
                .durationMinutes(entity.getDurationMinutes())
                .price(entity.getPrice())
                .categoryId(entity.getCategory().getId())
                .categoryName(entity.getCategory().getName())
                .imageUrl(entity.getImageUrl())
                .isFeatured(entity.getIsFeatured())
                .isActive(entity.getIsActive())
                .build();
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/entity/CategoryEntity.java ==========
package com.flavia.dermobeauty.catalog.entity;

import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDateTime;

/**
 * JPA entity for categories table.
 * Categories are used to organize both services and products.
 */
@Entity
@Table(name = "categories")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class CategoryEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @EqualsAndHashCode.Include
    private Long id;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(nullable = false, unique = true, length = 100)
    private String slug;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private CategoryType type;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }

    public enum CategoryType {
        SERVICE, PRODUCT
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/entity/ProductEntity.java ==========
package com.flavia.dermobeauty.catalog.entity;

import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * JPA entity for products table.
 * Represents beauty/dermatology products for sale.
 */
@Entity
@Table(name = "products")
@Getter@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class ProductEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @EqualsAndHashCode.Include
    private Long id;

    @Column(nullable = false, length = 200)
    private String name;

    @Column(nullable = false, unique = true, length = 200)
    private String slug;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Column(name = "short_description", length = 500)
    private String shortDescription;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal price;

    @Column(nullable = false)
    private Integer stock = 0;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id", nullable = false)
    @ToString.Exclude
    private CategoryEntity category;

    @Column(name = "image_url", length = 500)
    private String imageUrl;

    @Column(name = "is_featured", nullable = false)
    private Boolean isFeatured = false;

    @Column(name = "is_offer", nullable = false)
    private Boolean isOffer = false;

    @Column(name = "is_trending", nullable = false)
    private Boolean isTrending = false;

    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/entity/ServiceEntity.java ==========
package com.flavia.dermobeauty.catalog.entity;

import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * JPA entity for services table.
 * Represents professional services offered (e.g., facial treatments, peels).
 */
@Entity
@Table(name = "services")
@Getter@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class ServiceEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @EqualsAndHashCode.Include
    private Long id;

    @Column(nullable = false, length = 200)
    private String name;

    @Column(nullable = false, unique = true, length = 200)
    private String slug;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Column(name = "short_description", length = 500)
    private String shortDescription;

    @Column(name = "duration_minutes", nullable = false)
    private Integer durationMinutes;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal price;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id", nullable = false)
    @ToString.Exclude
    private CategoryEntity category;

    @Column(name = "image_url", length = 500)
    private String imageUrl;

    @Column(name = "is_featured", nullable = false)
    private Boolean isFeatured = false;

    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/repository/CategoryRepository.java ==========
package com.flavia.dermobeauty.catalog.repository;

import com.flavia.dermobeauty.catalog.entity.CategoryEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

/**
 * Repository for category operations.
 */
@Repository
public interface CategoryRepository extends JpaRepository<CategoryEntity, Long> {

    Optional<CategoryEntity> findBySlug(String slug);

    List<CategoryEntity> findByType(CategoryEntity.CategoryType type);
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/repository/ProductRepository.java ==========
package com.flavia.dermobeauty.catalog.repository;

import com.flavia.dermobeauty.catalog.entity.ProductEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

/**
 * Repository for product operations with custom queries for filtering.
 */
@Repository
public interface ProductRepository extends JpaRepository<ProductEntity, Long> {

    Optional<ProductEntity> findBySlug(String slug);

    List<ProductEntity> findByIsActiveTrueOrderByCreatedAtDesc();

    List<ProductEntity> findByIsFeaturedTrueAndIsActiveTrueOrderByCreatedAtDesc();

    List<ProductEntity> findByIsOfferTrueAndIsActiveTrueOrderByCreatedAtDesc();

    List<ProductEntity> findByIsTrendingTrueAndIsActiveTrueOrderByCreatedAtDesc();

    @Query("SELECT p FROM ProductEntity p WHERE p.category.id = :categoryId AND p.isActive = true ORDER BY p.createdAt DESC")
    List<ProductEntity> findByCategoryIdAndIsActiveTrue(@Param("categoryId") Long categoryId);

    @Modifying(clearAutomatically = true)
    @Query("UPDATE ProductEntity p SET p.stock = p.stock - :quantity WHERE p.id = :id AND p.stock >= :quantity")
    int decrementStock(@Param("id") Long id, @Param("quantity") Integer quantity);

}


========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/repository/ServiceRepository.java ==========
package com.flavia.dermobeauty.catalog.repository;

import com.flavia.dermobeauty.catalog.entity.ServiceEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

/**
 * Repository for service operations with custom queries for filtering.
 */
@Repository
public interface ServiceRepository extends JpaRepository<ServiceEntity, Long> {

    Optional<ServiceEntity> findBySlug(String slug);

    List<ServiceEntity> findByIsActiveTrueOrderByCreatedAtDesc();

    List<ServiceEntity> findByIsFeaturedTrueAndIsActiveTrueOrderByCreatedAtDesc();

    @Query("SELECT s FROM ServiceEntity s WHERE s.category.id = :categoryId AND s.isActive = true ORDER BY s.createdAt DESC")
    List<ServiceEntity> findByCategoryIdAndIsActiveTrue(@Param("categoryId") Long categoryId);
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/service/ProductCatalogService.java ==========
package com.flavia.dermobeauty.catalog.service;

import com.flavia.dermobeauty.catalog.dto.ProductDto;
import com.flavia.dermobeauty.catalog.entity.CategoryEntity;
import com.flavia.dermobeauty.catalog.entity.ProductEntity;
import com.flavia.dermobeauty.catalog.repository.CategoryRepository;
import com.flavia.dermobeauty.catalog.repository.ProductRepository;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Service for managing product catalog operations.
 * Provides CRUD operations for beauty/dermatology products.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class ProductCatalogService {

    private final ProductRepository productRepository;
    private final CategoryRepository categoryRepository;

    @Transactional(readOnly = true)
    public List<ProductDto> getAllActive() {
        log.debug("Fetching all active products");
        return productRepository.findByIsActiveTrueOrderByCreatedAtDesc()
                .stream()
                .map(ProductDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<ProductDto> getAllForAdmin() {
        log.debug("Fetching all products for admin");
        // Usamos findAll() estándar de JPA para traer todo
        return productRepository.findAll()
                .stream()
                .map(ProductDto::fromEntity)
                // Ordenamos por ID o fecha para que no salten en la tabla
                .sorted((a, b) -> b.getId().compareTo(a.getId()))
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<ProductDto> getFeatured() {
        log.debug("Fetching featured products");
        return productRepository.findByIsFeaturedTrueAndIsActiveTrueOrderByCreatedAtDesc()
                .stream()
                .map(ProductDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<ProductDto> getOffers() {
        log.debug("Fetching products on offer");
        return productRepository.findByIsOfferTrueAndIsActiveTrueOrderByCreatedAtDesc()
                .stream()
                .map(ProductDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<ProductDto> getTrending() {
        log.debug("Fetching trending products");
        return productRepository.findByIsTrendingTrueAndIsActiveTrueOrderByCreatedAtDesc()
                .stream()
                .map(ProductDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public ProductDto getById(Long id) {
        log.debug("Fetching product by id: {}", id);
        ProductEntity entity = productRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Product", id));
        return ProductDto.fromEntity(entity);
    }

    @Transactional(readOnly = true)
    public ProductDto getBySlug(String slug) {
        log.debug("Fetching product by slug: {}", slug);
        ProductEntity entity = productRepository.findBySlug(slug)
                .orElseThrow(() -> new ResourceNotFoundException("Product with slug '" + slug + "' not found"));
        return ProductDto.fromEntity(entity);
    }

    @Transactional(readOnly = true)
    public List<ProductDto> getByCategory(Long categoryId) {
        log.debug("Fetching products by category: {}", categoryId);
        return productRepository.findByCategoryIdAndIsActiveTrue(categoryId)
                .stream()
                .map(ProductDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional
    public ProductDto create(ProductDto dto) {
        log.info("Creating new product: {}", dto.getName());

        CategoryEntity category = categoryRepository.findById(dto.getCategoryId())
                .orElseThrow(() -> new ResourceNotFoundException("Category", dto.getCategoryId()));

        ProductEntity entity = ProductEntity.builder()
                .name(dto.getName())
                .slug(generateSlug(dto.getName()))
                .description(dto.getDescription())
                .shortDescription(dto.getShortDescription())
                .price(dto.getPrice())
                .stock(dto.getStock() != null ? dto.getStock() : 0)
                .category(category)
                .imageUrl(dto.getImageUrl())
                .isFeatured(dto.getIsFeatured() != null ? dto.getIsFeatured() : false)
                .isOffer(dto.getIsOffer() != null ? dto.getIsOffer() : false)
                .isTrending(dto.getIsTrending() != null ? dto.getIsTrending() : false)
                .isActive(dto.getIsActive() != null ? dto.getIsActive() : true)
                .build();

        ProductEntity saved = productRepository.save(entity);
        return ProductDto.fromEntity(saved);
    }

    @Transactional
    public ProductDto update(Long id, ProductDto dto) {
        log.info("Updating product: {}", id);

        ProductEntity entity = productRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Product", id));

        if (dto.getCategoryId() != null && !dto.getCategoryId().equals(entity.getCategory().getId())) {
            CategoryEntity category = categoryRepository.findById(dto.getCategoryId())
                    .orElseThrow(() -> new ResourceNotFoundException("Category", dto.getCategoryId()));
            entity.setCategory(category);
        }

        entity.setName(dto.getName());
        entity.setDescription(dto.getDescription());
        entity.setShortDescription(dto.getShortDescription());
        entity.setPrice(dto.getPrice());
        entity.setStock(dto.getStock());
        entity.setImageUrl(dto.getImageUrl());
        entity.setIsFeatured(dto.getIsFeatured());
        entity.setIsOffer(dto.getIsOffer());
        entity.setIsTrending(dto.getIsTrending());
        entity.setIsActive(dto.getIsActive());

        ProductEntity updated = productRepository.save(entity);
        return ProductDto.fromEntity(updated);
    }

    @Transactional
    public void delete(Long id) {
        log.info("Deleting product: {}", id);
        if (!productRepository.existsById(id)) {
            throw new ResourceNotFoundException("Product", id);
        }
        productRepository.deleteById(id);
    }

    private String generateSlug(String name) {
        return name.toLowerCase()
                .replaceAll("[^a-z0-9\\s-]", "")
                .replaceAll("\\s+", "-")
                .replaceAll("-+", "-");
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/service/ServiceCatalogService.java ==========
package com.flavia.dermobeauty.catalog.service;

import com.flavia.dermobeauty.catalog.dto.ServiceDto;
import com.flavia.dermobeauty.catalog.entity.CategoryEntity;
import com.flavia.dermobeauty.catalog.entity.ServiceEntity;
import com.flavia.dermobeauty.catalog.repository.CategoryRepository;
import com.flavia.dermobeauty.catalog.repository.ServiceRepository;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Service for managing service catalog operations.
 * Provides CRUD operations for beauty/dermatology services.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class ServiceCatalogService {

    private final ServiceRepository serviceRepository;
    private final CategoryRepository categoryRepository;

    @Transactional(readOnly = true)
    public List<ServiceDto> getAllActive() {
        log.debug("Fetching all active services");
        return serviceRepository.findByIsActiveTrueOrderByCreatedAtDesc()
                .stream()
                .map(ServiceDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<ServiceDto> getAllForAdmin() {
        log.debug("Fetching all services for admin");
        return serviceRepository.findAll()
                .stream()
                .map(ServiceDto::fromEntity)
                .sorted((a, b) -> b.getId().compareTo(a.getId()))
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<ServiceDto> getFeatured() {
        log.debug("Fetching featured services");
        return serviceRepository.findByIsFeaturedTrueAndIsActiveTrueOrderByCreatedAtDesc()
                .stream()
                .map(ServiceDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public ServiceDto getById(Long id) {
        log.debug("Fetching service by id: {}", id);
        ServiceEntity entity = serviceRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Service", id));
        return ServiceDto.fromEntity(entity);
    }

    @Transactional(readOnly = true)
    public ServiceDto getBySlug(String slug) {
        log.debug("Fetching service by slug: {}", slug);
        ServiceEntity entity = serviceRepository.findBySlug(slug)
                .orElseThrow(() -> new ResourceNotFoundException("Service with slug '" + slug + "' not found"));
        return ServiceDto.fromEntity(entity);
    }

    @Transactional(readOnly = true)
    public List<ServiceDto> getByCategory(Long categoryId) {
        log.debug("Fetching services by category: {}", categoryId);
        return serviceRepository.findByCategoryIdAndIsActiveTrue(categoryId)
                .stream()
                .map(ServiceDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional
    public ServiceDto create(ServiceDto dto) {
        log.info("Creating new service: {}", dto.getName());

        CategoryEntity category = categoryRepository.findById(dto.getCategoryId())
                .orElseThrow(() -> new ResourceNotFoundException("Category", dto.getCategoryId()));

        ServiceEntity entity = ServiceEntity.builder()
                .name(dto.getName())
                .slug(generateSlug(dto.getName()))
                .description(dto.getDescription())
                .shortDescription(dto.getShortDescription())
                .durationMinutes(dto.getDurationMinutes())
                .price(dto.getPrice())
                .category(category)
                .imageUrl(dto.getImageUrl())
                .isFeatured(dto.getIsFeatured() != null ? dto.getIsFeatured() : false)
                .isActive(dto.getIsActive() != null ? dto.getIsActive() : true)
                .build();

        ServiceEntity saved = serviceRepository.save(entity);
        return ServiceDto.fromEntity(saved);
    }

    @Transactional
    public ServiceDto update(Long id, ServiceDto dto) {
        log.info("Updating service: {}", id);

        ServiceEntity entity = serviceRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Service", id));

        if (dto.getCategoryId() != null && !dto.getCategoryId().equals(entity.getCategory().getId())) {
            CategoryEntity category = categoryRepository.findById(dto.getCategoryId())
                    .orElseThrow(() -> new ResourceNotFoundException("Category", dto.getCategoryId()));
            entity.setCategory(category);
        }

        entity.setName(dto.getName());
        entity.setDescription(dto.getDescription());
        entity.setShortDescription(dto.getShortDescription());
        entity.setDurationMinutes(dto.getDurationMinutes());
        entity.setPrice(dto.getPrice());
        entity.setImageUrl(dto.getImageUrl());
        entity.setIsFeatured(dto.getIsFeatured());
        entity.setIsActive(dto.getIsActive());

        ServiceEntity updated = serviceRepository.save(entity);
        return ServiceDto.fromEntity(updated);
    }

    @Transactional
    public void delete(Long id) {
        log.info("Deleting service: {}", id);
        if (!serviceRepository.existsById(id)) {
            throw new ResourceNotFoundException("Service", id);
        }
        serviceRepository.deleteById(id);
    }

    private String generateSlug(String name) {
        return name.toLowerCase()
                .replaceAll("[^a-z0-9\\s-]", "")
                .replaceAll("\\s+", "-")
                .replaceAll("-+", "-");
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/config/domain/ConfigEntry.java ==========
package com.flavia.dermobeauty.config.domain;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "app_config")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ConfigEntry {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "config_key", unique = true, nullable = false)
    private String key;

    @Column(name = "config_value", nullable = false)
    private String value;

    private String description;
}

========== FILE: ./src/main/java/com/flavia/dermobeauty/config/repository/ConfigRepository.java ==========
package com.flavia.dermobeauty.config.repository;

import com.flavia.dermobeauty.config.domain.ConfigEntry;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.Optional;

public interface ConfigRepository extends JpaRepository<ConfigEntry, Long> {
    Optional<ConfigEntry> findByKey(String key);
}

========== FILE: ./src/main/java/com/flavia/dermobeauty/config/web/AdminConfigController.java ==========
package com.flavia.dermobeauty.config.web;

import com.flavia.dermobeauty.config.domain.ConfigEntry;
import com.flavia.dermobeauty.config.repository.ConfigRepository;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/admin/config")
@RequiredArgsConstructor
public class AdminConfigController {

    private final ConfigRepository configRepository;

    @GetMapping
    public ResponseEntity<ApiResponse<List<ConfigEntry>>> getAllConfig() {
        return ResponseEntity.ok(ApiResponse.success(configRepository.findAll()));
    }

    @PutMapping("/{key}")
    public ResponseEntity<ApiResponse<ConfigEntry>> updateConfig(
            @PathVariable String key,
            @RequestBody UpdateConfigRequest request) {

        ConfigEntry config = configRepository.findByKey(key)
                .orElse(ConfigEntry.builder().key(key).build());

        config.setValue(request.getValue());
        // Descripción opcional, solo si es nuevo
        if (config.getDescription() == null) {
            config.setDescription("Configuración dinámica");
        }

        return ResponseEntity.ok(ApiResponse.success(configRepository.save(config)));
    }

    @Data
    public static class UpdateConfigRequest {
        private String value;
    }
}

========== FILE: ./src/main/java/com/flavia/dermobeauty/DermobeautyApplication.java ==========
package com.flavia.dermobeauty;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class DermobeautyApplication {

    public static void main(String[] args) {
        SpringApplication.run(DermobeautyApplication.class, args);
    }

}


========== FILE: ./src/main/java/com/flavia/dermobeauty/payment/config/MercadoPagoConfiguration.java ==========
package com.flavia.dermobeauty.payment.config;

import com.mercadopago.MercadoPagoConfig;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;

import jakarta.annotation.PostConstruct;

/**
 * Configuration for Mercado Pago SDK.
 * Initializes SDK with access token from application properties.
 */
@Slf4j
@Configuration
public class MercadoPagoConfiguration {

    @Value("${mercadopago.access-token}")
    private String accessToken;

    @PostConstruct
    public void init() {
        MercadoPagoConfig.setAccessToken(accessToken);
        log.info("Mercado Pago SDK configured with access token");
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/payment/controller/MercadoPagoWebhookController.java ==========
package com.flavia.dermobeauty.payment.controller;

import com.flavia.dermobeauty.booking.application.usecase.ConfirmBookingPaymentUseCase;
import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.domain.BookingRepository;
import com.flavia.dermobeauty.sales.application.usecase.ConfirmOrderPaymentUseCase;
import com.flavia.dermobeauty.sales.domain.Order;
import com.flavia.dermobeauty.sales.domain.OrderRepository;
import com.mercadopago.client.payment.PaymentClient;
import com.mercadopago.exceptions.MPApiException;
import com.mercadopago.exceptions.MPException;
import com.mercadopago.resources.payment.Payment;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

/**
 * Controller for Mercado Pago webhook notifications.
 * Handles payment status updates from Mercado Pago.
 *
 * CRITICAL: This endpoint must be publicly accessible (no authentication).
 * Mercado Pago sends IPN notifications here when payment status changes.
 */
@Slf4j
@RestController
@RequestMapping("/api/mp")
@RequiredArgsConstructor
public class MercadoPagoWebhookController {

    private final BookingRepository bookingRepository;
    private final OrderRepository orderRepository;
    private final ConfirmBookingPaymentUseCase confirmBookingPaymentUseCase;
    private final ConfirmOrderPaymentUseCase confirmOrderPaymentUseCase;
    private final PaymentClient paymentClient = new PaymentClient();

    @PostMapping("/webhook")
    public ResponseEntity<Void> handleWebhook(@RequestBody Map<String, Object> payload) {
        try {
            log.info("Received MP webhook: {}", payload);

            String type = (String) payload.get("type");

            if (!"payment".equals(type)) {
                log.debug("Ignoring non-payment notification: {}", type);
                return ResponseEntity.ok().build();
            }

            Map<String, Object> data = (Map<String, Object>) payload.get("data");
            if (data == null) {
                log.warn("Webhook data is null");
                return ResponseEntity.ok().build();
            }

            String paymentIdStr = (String) data.get("id");
            if (paymentIdStr == null) {
                log.warn("Payment ID is null in webhook data");
                return ResponseEntity.ok().build();
            }

            Long paymentId = Long.parseLong(paymentIdStr);
            log.info("Processing payment notification for payment ID: {}", paymentId);

            // Fetch payment details from Mercado Pago
            Payment payment = paymentClient.get(paymentId);
            log.info("Payment status: {}, External reference: {}",
                    payment.getStatus(), payment.getExternalReference());

            // Only process approved payments
            if (!"approved".equals(payment.getStatus())) {
                log.info("Payment {} not approved yet (status: {}), skipping confirmation",
                        paymentId, payment.getStatus());
                return ResponseEntity.ok().build();
            }

            String externalReference = payment.getExternalReference();
            if (externalReference == null) {
                log.warn("External reference is null for payment {}", paymentId);
                return ResponseEntity.ok().build();
            }

            // Update payment ID in booking/order and confirm
            if (externalReference.startsWith("BOOKING-")) {
                confirmBookingPayment(externalReference, String.valueOf(paymentId));
            } else if (externalReference.startsWith("ORDER-")) {
                confirmOrderPayment(externalReference, String.valueOf(paymentId));
            } else {
                log.warn("Unknown external reference format: {}", externalReference);
            }

            return ResponseEntity.ok().build();

        } catch (MPApiException e) {
            log.error("MP API error processing webhook: {} - {}", e.getStatusCode(), e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.OK).build(); // Always return 200 to MP
        } catch (MPException e) {
            log.error("MP error processing webhook: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.OK).build();
        } catch (Exception e) {
            log.error("Unexpected error processing webhook", e);
            return ResponseEntity.status(HttpStatus.OK).build(); // Always return 200 to MP
        }
    }

    private void confirmBookingPayment(String externalReference, String paymentId) {
        try {
            String bookingNumber = externalReference.replace("BOOKING-", "");
            log.info("Confirming payment for booking: {}", bookingNumber);

            // Find booking and update payment ID first
            Booking booking = bookingRepository.findByBookingNumber(bookingNumber)
                    .orElseThrow(() -> new RuntimeException("Booking not found: " + bookingNumber));

            // Update booking with payment ID
            Booking updatedBooking = Booking.builder()
                    .id(booking.getId())
                    .bookingNumber(booking.getBookingNumber())
                    .serviceId(booking.getServiceId())
                    .customerInfo(booking.getCustomerInfo())
                    .timeSlot(booking.getTimeSlot())
                    .durationMinutes(booking.getDurationMinutes())
                    .status(booking.getStatus())
                    .paymentStatus(booking.getPaymentStatus())
                    .mercadoPagoPreferenceId(booking.getMercadoPagoPreferenceId())
                    .mercadoPagoPaymentId(paymentId)
                    .amount(booking.getAmount())
                    .createdAt(booking.getCreatedAt())
                    .updatedAt(booking.getUpdatedAt())
                    .confirmedAt(booking.getConfirmedAt())
                    .cancelledAt(booking.getCancelledAt())
                    .build();

            bookingRepository.save(updatedBooking);

            // Confirm payment via use case
            confirmBookingPaymentUseCase.execute(paymentId);
            log.info("Booking payment confirmed successfully: {}", bookingNumber);

        } catch (Exception e) {
            log.error("Error confirming booking payment", e);
            throw new RuntimeException("Error confirming booking payment", e);
        }
    }

    private void confirmOrderPayment(String externalReference, String paymentId) {
        try {
            String orderNumber = externalReference.replace("ORDER-", "");
            log.info("Confirming payment for order: {}", orderNumber);

            // Find order and update payment ID first
            Order order = orderRepository.findByOrderNumber(orderNumber)
                    .orElseThrow(() -> new RuntimeException("Order not found: " + orderNumber));

            // Update order with payment ID
            Order updatedOrder = Order.builder()
                    .id(order.getId())
                    .orderNumber(order.getOrderNumber())
                    .customerInfo(order.getCustomerInfo())
                    .deliveryInfo(order.getDeliveryInfo())
                    .items(order.getItems())
                    .subtotal(order.getSubtotal())
                    .deliveryCost(order.getDeliveryCost())
                    .total(order.getTotal())
                    .status(order.getStatus())
                    .paymentStatus(order.getPaymentStatus())
                    .mercadoPagoPreferenceId(order.getMercadoPagoPreferenceId())
                    .mercadoPagoPaymentId(paymentId)
                    .createdAt(order.getCreatedAt())
                    .updatedAt(order.getUpdatedAt())
                    .build();

            orderRepository.save(updatedOrder);

            // Confirm payment via use case (decrements stock, sends email)
            confirmOrderPaymentUseCase.execute(paymentId);
            log.info("Order payment confirmed successfully: {}", orderNumber);

        } catch (Exception e) {
            log.error("Error confirming order payment", e);
            throw new RuntimeException("Error confirming order payment", e);
        }
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/payment/controller/PaymentController.java ==========
package com.flavia.dermobeauty.payment.controller;

import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.domain.BookingRepository;
import com.flavia.dermobeauty.payment.dto.PaymentPreferenceResponse;
import com.flavia.dermobeauty.payment.service.MercadoPagoClient;
import com.flavia.dermobeauty.sales.domain.Order;
import com.flavia.dermobeauty.sales.domain.OrderRepository;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

/**
 * Controller for payment preference creation.
 * Public endpoints to initiate payment for bookings and orders.
 */
@Slf4j
@RestController
@RequestMapping("/api/public/payments")
@RequiredArgsConstructor
public class PaymentController {

    private final MercadoPagoClient mercadoPagoClient;
    private final BookingRepository bookingRepository;
    private final OrderRepository orderRepository;

    @PostMapping("/bookings/{bookingId}/preference")
    public ResponseEntity<ApiResponse<PaymentPreferenceResponse>> createBookingPreference(
            @PathVariable Long bookingId) {

        log.info("Creating payment preference for booking: {}", bookingId);

        Booking booking = bookingRepository.findById(bookingId)
                .orElseThrow(() -> new ResourceNotFoundException("Booking", bookingId));

        String preferenceId = mercadoPagoClient.createPreferenceForBooking(booking);

        // Update booking with preference ID
        Booking updatedBooking = Booking.builder()
                .id(booking.getId())
                .bookingNumber(booking.getBookingNumber())
                .serviceId(booking.getServiceId())
                .customerInfo(booking.getCustomerInfo())
                .timeSlot(booking.getTimeSlot())
                .durationMinutes(booking.getDurationMinutes())
                .status(booking.getStatus())
                .paymentStatus(booking.getPaymentStatus())
                .mercadoPagoPreferenceId(preferenceId)
                .mercadoPagoPaymentId(booking.getMercadoPagoPaymentId())
                .amount(booking.getAmount())
                .createdAt(booking.getCreatedAt())
                .updatedAt(booking.getUpdatedAt())
                .confirmedAt(booking.getConfirmedAt())
                .cancelledAt(booking.getCancelledAt())
                .build();

        bookingRepository.save(updatedBooking);

        PaymentPreferenceResponse response = new PaymentPreferenceResponse(
                preferenceId,
                "https://www.mercadopago.com.ar/checkout/v1/redirect?pref_id=" + preferenceId
        );

        return ResponseEntity.ok(ApiResponse.success(response, "Payment preference created"));
    }

    @PostMapping("/orders/{orderId}/preference")
    public ResponseEntity<ApiResponse<PaymentPreferenceResponse>> createOrderPreference(
            @PathVariable Long orderId) {

        log.info("Creating payment preference for order: {}", orderId);

        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new ResourceNotFoundException("Order", orderId));

        String preferenceId = mercadoPagoClient.createPreferenceForOrder(order);

        // Update order with preference ID
        Order updatedOrder = Order.builder()
                .id(order.getId())
                .orderNumber(order.getOrderNumber())
                .customerInfo(order.getCustomerInfo())
                .deliveryInfo(order.getDeliveryInfo())
                .items(order.getItems())
                .subtotal(order.getSubtotal())
                .deliveryCost(order.getDeliveryCost())
                .total(order.getTotal())
                .status(order.getStatus())
                .paymentStatus(order.getPaymentStatus())
                .mercadoPagoPreferenceId(preferenceId)
                .mercadoPagoPaymentId(order.getMercadoPagoPaymentId())
                .createdAt(order.getCreatedAt())
                .updatedAt(order.getUpdatedAt())
                .build();

        orderRepository.save(updatedOrder);

        PaymentPreferenceResponse response = new PaymentPreferenceResponse(
                preferenceId,
                "https://www.mercadopago.com.ar/checkout/v1/redirect?pref_id=" + preferenceId
        );

        return ResponseEntity.ok(ApiResponse.success(response, "Payment preference created"));
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/payment/dto/PaymentPreferenceResponse.java ==========
package com.flavia.dermobeauty.payment.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO for payment preference response.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class PaymentPreferenceResponse {
    private String preferenceId;
    private String initPoint;
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/payment/service/BookingPaymentServiceImpl.java ==========
package com.flavia.dermobeauty.payment.service;

import com.flavia.dermobeauty.booking.application.port.PaymentService;
import com.flavia.dermobeauty.booking.domain.Booking;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

/**
 * Implementation of PaymentService for booking module.
 * Delegates to MercadoPagoClient for preference creation.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class BookingPaymentServiceImpl implements PaymentService {

    private final MercadoPagoClient mercadoPagoClient;

    @Override
    public String createBookingPreference(Booking booking) {
        return mercadoPagoClient.createPreferenceForBooking(booking);
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/payment/service/MercadoPagoClient.java ==========
package com.flavia.dermobeauty.payment.service;

import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.sales.domain.Order;
import com.flavia.dermobeauty.shared.exception.PaymentException;
import com.mercadopago.client.common.IdentificationRequest;
import com.mercadopago.client.preference.*;
import com.mercadopago.exceptions.MPApiException;
import com.mercadopago.exceptions.MPException;
import com.mercadopago.resources.preference.Preference;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

/**
 * Client for Mercado Pago API operations.
 * Creates payment preferences for bookings and orders.
 */
@Slf4j
@Service
public class MercadoPagoClient {

    private final String baseUrl;
    private final String apiUrl;
    private final PreferenceClient preferenceClient;

    public MercadoPagoClient(
            @Value("${mercadopago.base-url}") String baseUrl,
            @Value("${app.api-url}") String apiUrl) {
        this.baseUrl = baseUrl;
        this.apiUrl = apiUrl;
        this.preferenceClient = new PreferenceClient();
        log.info("MercadoPagoClient initialized with base URL: {}", baseUrl);
    }

    /**
     * Create payment preference for a booking.
     *
     * @param booking The booking to create payment for
     * @return Preference ID
     */
    public String createPreferenceForBooking(Booking booking) {
        try {
            log.info("Creating MP preference for booking: {}", booking.getBookingNumber());

            PreferenceItemRequest item = PreferenceItemRequest.builder()
                    .title("Reserva de Servicio - " + booking.getBookingNumber())
                    .description("Servicio profesional de dermocosmiatría")
                    .quantity(1)
                    .currencyId("ARS")
                    .unitPrice(booking.getAmount())
                    .build();

            PreferencePayerRequest payer = PreferencePayerRequest.builder()
                    .name(booking.getCustomerInfo().getName())
                    .email(booking.getCustomerInfo().getEmail())
                    .build();

            PreferenceBackUrlsRequest backUrls = PreferenceBackUrlsRequest.builder()
                    .success(baseUrl + "/reserva/exitosa")
                    .failure(baseUrl + "/reserva/fallida")
                    .pending(baseUrl + "/reserva/pendiente")
                    .build();

            PreferenceRequest request = PreferenceRequest.builder()
                    .items(List.of(item))
                    .payer(payer)
                    .backUrls(backUrls)
                    .autoReturn("approved")
                    .externalReference("BOOKING-" + booking.getBookingNumber())
                    .notificationUrl(baseUrl + "/api/mp/webhook")
                    .statementDescriptor("Flavia Dermobeauty")
                    .build();

            Preference preference = preferenceClient.create(request);
            log.info("Created MP preference for booking {}: {}", booking.getBookingNumber(), preference.getId());

            return preference.getId();

        } catch (MPApiException e) {
            log.error("MP API error creating preference for booking {}: {} - {}",
                    booking.getBookingNumber(), e.getStatusCode(), e.getMessage());
            throw new PaymentException("Error creating payment preference: " + e.getMessage(), e);
        } catch (MPException e) {
            log.error("MP error creating preference for booking {}: {}",
                    booking.getBookingNumber(), e.getMessage());
            throw new PaymentException("Error creating payment preference: " + e.getMessage(), e);
        }
    }

    /**
     * Create payment preference for an order.
     *
     * @param order The order to create payment for
     * @return Preference ID
     */
    public String createPreferenceForOrder(Order order) {
        try {
            log.info("Creating MP preference for order: {}", order.getOrderNumber());

            List<PreferenceItemRequest> items = new ArrayList<>();

            // Add product items
            order.getItems().forEach(orderItem -> {
                PreferenceItemRequest item = PreferenceItemRequest.builder()
                        .title(orderItem.getProductName())
                        .quantity(orderItem.getQuantity())
                        .currencyId("ARS")
                        .unitPrice(orderItem.getProductPrice())
                        .build();
                items.add(item);
            });

            // Add delivery cost as separate item if applicable
            if (order.getDeliveryCost().compareTo(BigDecimal.ZERO) > 0) {
                PreferenceItemRequest deliveryItem = PreferenceItemRequest.builder()
                        .title("Envío a domicilio")
                        .quantity(1)
                        .currencyId("ARS")
                        .unitPrice(order.getDeliveryCost())
                        .build();
                items.add(deliveryItem);
            }

            PreferencePayerRequest payer = PreferencePayerRequest.builder()
                    .name(order.getCustomerInfo().getName())
                    .email(order.getCustomerInfo().getEmail())
                    .build();

            PreferenceBackUrlsRequest backUrls = PreferenceBackUrlsRequest.builder()
                    .success(baseUrl + "/pedido/exitoso")
                    .failure(baseUrl + "/pedido/fallido")
                    .pending(baseUrl + "/pedido/pendiente")
                    .build();

            PreferenceRequest request = PreferenceRequest.builder()
                    .items(items)
                    .payer(payer)
                    .backUrls(backUrls)
                    .autoReturn("approved")
                    .externalReference("ORDER-" + order.getOrderNumber())
                    .notificationUrl(baseUrl + "/api/mp/webhook")
                    .statementDescriptor("Flavia Dermobeauty")
                    .build();

            Preference preference = preferenceClient.create(request);
            log.info("Created MP preference for order {}: {}", order.getOrderNumber(), preference.getId());

            return preference.getId();

        } catch (MPApiException e) {
            log.error("MP API error creating preference for order {}: {} - {}",
                    order.getOrderNumber(), e.getStatusCode(), e.getMessage());
            throw new PaymentException("Error creating payment preference: " + e.getMessage(), e);
        } catch (MPException e) {
            log.error("MP error creating preference for order {}: {}",
                    order.getOrderNumber(), e.getMessage());
            throw new PaymentException("Error creating payment preference: " + e.getMessage(), e);
        }
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/payment/service/OrderPaymentServiceImpl.java ==========
package com.flavia.dermobeauty.payment.service;

import com.flavia.dermobeauty.sales.application.port.PaymentService;
import com.flavia.dermobeauty.sales.domain.Order;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

/**
 * Implementation of PaymentService for sales module.
 * Delegates to MercadoPagoClient for preference creation.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class OrderPaymentServiceImpl implements PaymentService {

    private final MercadoPagoClient mercadoPagoClient;

    @Override
    public String createOrderPreference(Order order) {
        return mercadoPagoClient.createPreferenceForOrder(order);
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/application/port/DeliveryCostCalculator.java ==========
package com.flavia.dermobeauty.sales.application.port;

import com.flavia.dermobeauty.sales.domain.DeliveryType;

import java.math.BigDecimal;

/**
 * Port (interface) for calculating delivery costs.
 * Will be implemented by infrastructure reading from config.
 */
public interface DeliveryCostCalculator {

    /**
     * Calculate delivery cost based on delivery type.
     *
     * @param deliveryType Type of delivery
     * @return Delivery cost (0 for PICKUP)
     */
    BigDecimal calculate(DeliveryType deliveryType);
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/application/port/NotificationService.java ==========
package com.flavia.dermobeauty.sales.application.port;

import com.flavia.dermobeauty.sales.domain.Order;

/**
 * Port (interface) for notification operations.
 * Will be implemented by the notification module infrastructure.
 */
public interface NotificationService {

    /**
     * Send order confirmation email to customer.
     *
     * @param order The confirmed order
     */
    void sendOrderConfirmation(Order order);
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/application/port/PaymentService.java ==========
package com.flavia.dermobeauty.sales.application.port;

import com.flavia.dermobeauty.sales.domain.Order;

/**
 * Port (interface) for payment operations.
 * Will be implemented by the payment module infrastructure.
 */
public interface PaymentService {

    /**
     * Create a Mercado Pago payment preference for an order.
     *
     * @param order The order to create payment for
     * @return Preference ID
     */
    String createOrderPreference(Order order);
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/application/port/StockService.java ==========
package com.flavia.dermobeauty.sales.application.port;

/**
 * Port (interface) for stock management operations.
 * Will be implemented by the catalog infrastructure.
 */
public interface StockService {

    /**
     * Check if sufficient stock is available for a product.
     *
     * @param productId Product ID
     * @param quantity  Requested quantity
     * @return true if stock available, false otherwise
     */
    boolean checkAvailability(Long productId, Integer quantity);

    /**
     * Decrement stock for a product.
     * Should be called after payment confirmation.
     *
     * @param productId Product ID
     * @param quantity  Quantity to decrement
     */
    void decrementStock(Long productId, Integer quantity);
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/application/usecase/ConfirmOrderPaymentUseCase.java ==========
package com.flavia.dermobeauty.sales.application.usecase;

import com.flavia.dermobeauty.sales.application.port.NotificationService;
import com.flavia.dermobeauty.sales.application.port.StockService;
import com.flavia.dermobeauty.sales.domain.Order;
import com.flavia.dermobeauty.sales.domain.OrderRepository;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Use Case: Confirm order payment.
 * Called from Mercado Pago webhook when payment is approved.
 * Decrements stock and sends confirmation email.
 */
@Slf4j
@RequiredArgsConstructor
public class ConfirmOrderPaymentUseCase {

    private final OrderRepository orderRepository;
    private final StockService stockService;
    private final NotificationService notificationService;

    public Order execute(String paymentId) {
        log.info("Confirming payment for payment ID: {}", paymentId);

        // Find order by payment ID
        Order order = orderRepository.findByMercadoPagoPaymentId(paymentId)
                .orElseThrow(() -> new ResourceNotFoundException("Order with payment ID '" + paymentId + "' not found"));

        // Confirm payment (domain logic)
        order.confirmPayment(paymentId);

        // Decrement stock for all items
        order.getItems().forEach(item -> {
            stockService.decrementStock(item.getProductId(), item.getQuantity());
            log.info("Decremented stock for product {}: {} units", item.getProductId(), item.getQuantity());
        });

        // Persist
        Order updated = orderRepository.save(order);
        log.info("Payment confirmed for order: {}", updated.getOrderNumber());

        // Send confirmation email (async, non-blocking)
        try {
            notificationService.sendOrderConfirmation(updated);
        } catch (Exception e) {
            log.error("Failed to send order confirmation email for {}", updated.getOrderNumber(), e);
            // Don't throw - email failure should not break payment confirmation
        }

        return updated;
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/application/usecase/CreateOrderUseCase.java ==========
package com.flavia.dermobeauty.sales.application.usecase;

import com.flavia.dermobeauty.booking.domain.PaymentStatus;
import com.flavia.dermobeauty.catalog.entity.ProductEntity;
import com.flavia.dermobeauty.catalog.repository.ProductRepository;
import com.flavia.dermobeauty.sales.application.port.DeliveryCostCalculator;
import com.flavia.dermobeauty.sales.application.port.StockService;
import com.flavia.dermobeauty.sales.domain.*;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import com.flavia.dermobeauty.shared.exception.ValidationException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;

/**
 * Use Case: Create a new order.
 * Validates stock availability, calculates delivery cost, and creates order in PENDING status.
 */
@Slf4j
@RequiredArgsConstructor
public class CreateOrderUseCase {

    private final OrderRepository orderRepository;
    private final ProductRepository productRepository;
    private final StockService stockService;
    private final DeliveryCostCalculator deliveryCostCalculator;

    public Order execute(
            String customerName,
            String customerEmail,
            String customerWhatsapp,
            DeliveryType deliveryType,
            String deliveryAddress,
            String deliveryCity,
            String deliveryPostalCode,
            String deliveryProvince,
            String deliveryNotes,
            List<OrderItemRequest> itemRequests) {

        log.info("Creating order for customer: {}", customerEmail);

        // Validate stock availability for all items
        for (OrderItemRequest itemRequest : itemRequests) {
            if (!stockService.checkAvailability(itemRequest.productId, itemRequest.quantity)) {
                ProductEntity product = productRepository.findById(itemRequest.productId)
                        .orElseThrow(() -> new ResourceNotFoundException("Product", itemRequest.productId));
                throw new ValidationException(
                        String.format("Insufficient stock for product '%s'. Requested: %d, Available: %d",
                                product.getName(), itemRequest.quantity, product.getStock())
                );
            }
        }

        // Create value objects
        CustomerInfo customerInfo = new CustomerInfo(customerName, customerEmail, customerWhatsapp);

        DeliveryInfo deliveryInfo = new DeliveryInfo(
                deliveryType,
                deliveryAddress,
                deliveryCity,
                deliveryPostalCode,
                deliveryProvince,
                deliveryNotes
        );

        // Calculate delivery cost
        BigDecimal deliveryCost = deliveryCostCalculator.calculate(deliveryType);

        // Create order aggregate
        Order order = Order.builder()
                .orderNumber(generateOrderNumber())
                .customerInfo(customerInfo)
                .deliveryInfo(deliveryInfo)
                .status(OrderStatus.PENDING)
                .paymentStatus(PaymentStatus.PENDING)
                .deliveryCost(deliveryCost)
                .createdAt(LocalDateTime.now())
                .updatedAt(LocalDateTime.now())
                .build();

        // Add items to order
        for (OrderItemRequest itemRequest : itemRequests) {
            ProductEntity product = productRepository.findById(itemRequest.productId)
                    .orElseThrow(() -> new ResourceNotFoundException("Product", itemRequest.productId));

            BigDecimal subtotal = OrderItem.calculateSubtotal(product.getPrice(), itemRequest.quantity);

            OrderItem item = OrderItem.builder()
                    .productId(product.getId())
                    .productName(product.getName())
                    .productPrice(product.getPrice())
                    .quantity(itemRequest.quantity)
                    .subtotal(subtotal)
                    .build();

            order.addItem(item);
        }

        // Validate and recalculate
        order.validate();
        order.recalculateTotal();

        // Persist
        Order saved = orderRepository.save(order);
        log.info("Order created successfully: {}", saved.getOrderNumber());

        return saved;
    }

    private String generateOrderNumber() {
        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd-HHmmss"));
        return "ORD-" + timestamp;
    }

    /**
     * DTO for order item request.
     */
    @RequiredArgsConstructor
    public static class OrderItemRequest {
        public final Long productId;
        public final Integer quantity;
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/application/usecase/GetOrderByNumberUseCase.java ==========
package com.flavia.dermobeauty.sales.application.usecase;

import com.flavia.dermobeauty.sales.domain.Order;
import com.flavia.dermobeauty.sales.domain.OrderRepository;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Use Case: Get order by order number.
 * Used by customers to check their order status.
 */
@Slf4j
@RequiredArgsConstructor
public class GetOrderByNumberUseCase {

    private final OrderRepository orderRepository;

    public Order execute(String orderNumber) {
        log.debug("Fetching order by number: {}", orderNumber);

        return orderRepository.findByOrderNumber(orderNumber)
                .orElseThrow(() -> new ResourceNotFoundException("Order with number '" + orderNumber + "' not found"));
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/application/usecase/ListOrdersUseCase.java ==========
package com.flavia.dermobeauty.sales.application.usecase;

import com.flavia.dermobeauty.sales.domain.Order;
import com.flavia.dermobeauty.sales.domain.OrderRepository;
import com.flavia.dermobeauty.sales.domain.OrderStatus;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

/**
 * Use Case: List orders for admin panel.
 * Supports filtering by status.
 */
@Slf4j
@RequiredArgsConstructor
public class ListOrdersUseCase {

    private final OrderRepository orderRepository;

    @Transactional(readOnly = true)
    public List<Order> execute() {
        log.debug("Fetching all orders");
        return orderRepository.findAll();
    }


    public List<Order> executeByStatus(OrderStatus status) {
        log.debug("Fetching orders with status: {}", status);
        return orderRepository.findByStatus(status);
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/application/usecase/UpdateOrderStatusUseCase.java ==========
package com.flavia.dermobeauty.sales.application.usecase;

import com.flavia.dermobeauty.sales.domain.Order;
import com.flavia.dermobeauty.sales.domain.OrderRepository;
import com.flavia.dermobeauty.sales.domain.OrderStatus;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Use Case: Update order status.
 * Used by admin to move order through fulfillment stages.
 */
@Slf4j
@RequiredArgsConstructor
public class UpdateOrderStatusUseCase {

    private final OrderRepository orderRepository;

    public Order execute(Long orderId, OrderStatus newStatus) {
        log.info("Updating order {} to status: {}", orderId, newStatus);

        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new ResourceNotFoundException("Order", orderId));

        // Update status (domain logic validates transition)
        order.updateStatus(newStatus);

        // Persist
        Order updated = orderRepository.save(order);
        log.info("Order status updated: {} -> {}", updated.getOrderNumber(), newStatus);

        return updated;
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/config/SalesConfig.java ==========
package com.flavia.dermobeauty.sales.config;

import com.flavia.dermobeauty.catalog.repository.ProductRepository;
import com.flavia.dermobeauty.sales.application.port.DeliveryCostCalculator;
import com.flavia.dermobeauty.sales.application.port.NotificationService;
import com.flavia.dermobeauty.sales.application.port.StockService;
import com.flavia.dermobeauty.sales.application.usecase.*;
import com.flavia.dermobeauty.sales.domain.OrderRepository;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * Configuration class for Sales module.
 * Wires use cases as Spring beans for dependency injection.
 */
@Configuration
public class SalesConfig {

    @Bean
    public CreateOrderUseCase createOrderUseCase(
            OrderRepository orderRepository,
            ProductRepository productRepository,
            StockService stockService,
            DeliveryCostCalculator deliveryCostCalculator) {
        return new CreateOrderUseCase(orderRepository, productRepository, stockService, deliveryCostCalculator);
    }

    @Bean
    public ConfirmOrderPaymentUseCase confirmOrderPaymentUseCase(
            OrderRepository orderRepository,
            StockService stockService,
            @Qualifier("orderNotificationService") NotificationService notificationService) {
        return new ConfirmOrderPaymentUseCase(orderRepository, stockService, notificationService);
    }

    @Bean
    public UpdateOrderStatusUseCase updateOrderStatusUseCase(OrderRepository orderRepository) {
        return new UpdateOrderStatusUseCase(orderRepository);
    }

    @Bean
    public ListOrdersUseCase listOrdersUseCase(OrderRepository orderRepository) {
        return new ListOrdersUseCase(orderRepository);
    }

    @Bean
    public GetOrderByNumberUseCase getOrderByNumberUseCase(OrderRepository orderRepository) {
        return new GetOrderByNumberUseCase(orderRepository);
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/domain/CustomerInfo.java ==========
package com.flavia.dermobeauty.sales.domain;

import lombok.Value;

/**
 * Value Object representing customer information for an order.
 * Immutable to ensure consistency.
 */
@Value
public class CustomerInfo {
    String name;
    String email;
    String whatsapp;

    public CustomerInfo(String name, String email, String whatsapp) {
        if (name == null || name.isBlank()) {
            throw new IllegalArgumentException("Customer name cannot be empty");
        }
        if (email == null || email.isBlank()) {
            throw new IllegalArgumentException("Customer email cannot be empty");
        }
        if (whatsapp == null || whatsapp.isBlank()) {
            throw new IllegalArgumentException("Customer whatsapp cannot be empty");
        }

        this.name = name;
        this.email = email;
        this.whatsapp = whatsapp;
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/domain/DeliveryInfo.java ==========
package com.flavia.dermobeauty.sales.domain;

import lombok.Value;

/**
 * Value Object representing delivery information for an order.
 * Immutable to ensure consistency.
 */
@Value
public class DeliveryInfo {
    DeliveryType deliveryType;
    String address;
    String city;
    String postalCode;
    String province;
    String notes;

    public DeliveryInfo(DeliveryType deliveryType, String address, String city,
                        String postalCode, String province, String notes) {
        if (deliveryType == null) {
            throw new IllegalArgumentException("Delivery type cannot be null");
        }

        if (deliveryType == DeliveryType.HOME_DELIVERY) {
            if (address == null || address.isBlank()) {
                throw new IllegalArgumentException("Address is required for home delivery");
            }
            if (city == null || city.isBlank()) {
                throw new IllegalArgumentException("City is required for home delivery");
            }
        }

        this.deliveryType = deliveryType;
        this.address = address;
        this.city = city;
        this.postalCode = postalCode;
        this.province = province;
        this.notes = notes;
    }

    public boolean isHomeDelivery() {
        return deliveryType == DeliveryType.HOME_DELIVERY;
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/domain/DeliveryType.java ==========
package com.flavia.dermobeauty.sales.domain;

/**
 * Domain enum representing delivery method for an order.
 */
public enum DeliveryType {
    PICKUP,         // Customer picks up at location
    HOME_DELIVERY   // Delivery to customer address
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/domain/OrderItem.java ==========
package com.flavia.dermobeauty.sales.domain;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;

import java.math.BigDecimal;

/**
 * Entity representing a single item in an order.
 * Part of the Order aggregate.
 */
@Getter
@AllArgsConstructor
@Builder
public class OrderItem {

    private Long id;
    private Long productId;
    private String productName;  // Snapshot at time of order
    private BigDecimal productPrice;  // Snapshot at time of order
    private Integer quantity;
    private BigDecimal subtotal;

    /**
     * Calculate subtotal based on price and quantity.
     */
    public static BigDecimal calculateSubtotal(BigDecimal price, Integer quantity) {
        if (price == null || quantity == null || quantity <= 0) {
            throw new IllegalArgumentException("Invalid price or quantity for order item");
        }
        return price.multiply(BigDecimal.valueOf(quantity));
    }

    /**
     * Validate order item business rules.
     */
    public void validate() {
        if (productId == null) {
            throw new IllegalArgumentException("Product ID cannot be null");
        }
        if (productName == null || productName.isBlank()) {
            throw new IllegalArgumentException("Product name cannot be empty");
        }
        if (productPrice == null || productPrice.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Product price must be greater than zero");
        }
        if (quantity == null || quantity <= 0) {
            throw new IllegalArgumentException("Quantity must be greater than zero");
        }
        if (subtotal == null || subtotal.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("Subtotal cannot be negative");
        }
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/domain/Order.java ==========
package com.flavia.dermobeauty.sales.domain;

import com.flavia.dermobeauty.booking.domain.PaymentStatus;
import com.flavia.dermobeauty.shared.exception.DomainException;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Order Aggregate Root.
 * Represents a product order with business rules enforcement.
 */
@Getter
@AllArgsConstructor
@Builder
public class Order {

    private Long id;
    private String orderNumber;
    private CustomerInfo customerInfo;
    private DeliveryInfo deliveryInfo;

    @Builder.Default
    private List<OrderItem> items = new ArrayList<>();

    private BigDecimal subtotal;
    private BigDecimal deliveryCost;
    private BigDecimal total;
    private OrderStatus status;
    private PaymentStatus paymentStatus;
    private String mercadoPagoPreferenceId;
    private String mercadoPagoPaymentId;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    /**
     * Add an item to the order.
     * Business rule: can only add items to PENDING orders.
     */
    public void addItem(OrderItem item) {
        if (this.status != OrderStatus.PENDING) {
            throw new DomainException("Cannot add items to order in status: " + status);
        }

        item.validate();
        this.items.add(item);
        recalculateTotal();
    }

    /**
     * Recalculate order totals based on items and delivery cost.
     */
    public void recalculateTotal() {
        this.subtotal = items.stream()
                .map(OrderItem::getSubtotal)
                .reduce(BigDecimal.ZERO, BigDecimal::add);

        BigDecimal deliveryCostValue = deliveryCost != null ? deliveryCost : BigDecimal.ZERO;
        this.total = subtotal.add(deliveryCostValue);
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Set delivery cost for the order.
     */
    public void setDeliveryCost(BigDecimal cost) {
        if (cost == null || cost.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("Delivery cost cannot be negative");
        }
        this.deliveryCost = cost;
        recalculateTotal();
    }

    /**
     * Confirm payment for this order.
     * Business rule: can only confirm payment once, and only from PENDING status.
     */
    public void confirmPayment(String paymentId) {
        if (this.paymentStatus == PaymentStatus.PAID) {
            throw new DomainException("Payment already confirmed for order " + orderNumber);
        }

        if (this.status == OrderStatus.CANCELLED) {
            throw new DomainException("Cannot confirm payment for cancelled order " + orderNumber);
        }

        if (paymentId == null || paymentId.isBlank()) {
            throw new IllegalArgumentException("Payment ID cannot be empty");
        }

        this.mercadoPagoPaymentId = paymentId;
        this.paymentStatus = PaymentStatus.PAID;
        this.status = OrderStatus.PAID;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Update order status.
     * Business rule: cannot update cancelled or certain status transitions.
     */
    public void updateStatus(OrderStatus newStatus) {
        if (this.status == OrderStatus.CANCELLED) {
            throw new DomainException("Cannot update status of cancelled order " + orderNumber);
        }

        if (this.status == OrderStatus.DELIVERED && newStatus != OrderStatus.DELIVERED) {
            throw new DomainException("Cannot change status of delivered order " + orderNumber);
        }

        this.status = newStatus;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Cancel this order.
     * Business rule: cannot cancel delivered orders.
     */
    public void cancel() {
        if (this.status == OrderStatus.CANCELLED) {
            throw new DomainException("Order " + orderNumber + " is already cancelled");
        }

        if (this.status == OrderStatus.DELIVERED) {
            throw new DomainException("Cannot cancel delivered order " + orderNumber);
        }

        this.status = OrderStatus.CANCELLED;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Get immutable copy of items list.
     */
    public List<OrderItem> getItems() {
        return Collections.unmodifiableList(items);
    }

    /**
     * Validate order business rules.
     */
    public void validate() {
        if (items == null || items.isEmpty()) {
            throw new DomainException("Order must have at least one item");
        }

        items.forEach(OrderItem::validate);

        if (subtotal == null || subtotal.compareTo(BigDecimal.ZERO) <= 0) {
            throw new DomainException("Order subtotal must be greater than zero");
        }

        if (total == null || total.compareTo(BigDecimal.ZERO) <= 0) {
            throw new DomainException("Order total must be greater than zero");
        }
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/domain/OrderRepository.java ==========
package com.flavia.dermobeauty.sales.domain;

import java.util.List;
import java.util.Optional;

/**
 * Repository port (interface) for Order aggregate.
 * Defines operations needed by the domain layer without specifying implementation.
 * Implementation will be provided by infrastructure layer.
 */
public interface OrderRepository {

    /**
     * Save an order (create or update).
     */
    Order save(Order order);

    /**
     * Find order by ID.
     */
    Optional<Order> findById(Long id);

    /**
     * Find order by order number.
     */
    Optional<Order> findByOrderNumber(String orderNumber);

    /**
     * Find order by Mercado Pago payment ID.
     */
    Optional<Order> findByMercadoPagoPaymentId(String paymentId);

    /**
     * Find all orders (for admin).
     */
    List<Order> findAll();

    /**
     * Find orders by status (for admin filtering).
     */
    List<Order> findByStatus(OrderStatus status);
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/domain/OrderStatus.java ==========
package com.flavia.dermobeauty.sales.domain;

/**
 * Domain enum representing the lifecycle status of an order.
 */
public enum OrderStatus {
    PENDING,    // Order created, payment not yet completed
    PAID,       // Payment completed
    PREPARING,  // Order being prepared
    READY,      // Order ready for pickup/delivery
    DELIVERED,  // Order delivered to customer
    CANCELLED   // Order cancelled
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/infrastructure/delivery/DeliveryCostCalculatorImpl.java ==========
package com.flavia.dermobeauty.sales.infrastructure.delivery;

import com.flavia.dermobeauty.sales.application.port.DeliveryCostCalculator;
import com.flavia.dermobeauty.sales.domain.DeliveryType;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;

/**
 * Implementation of DeliveryCostCalculator reading from configuration.
 * For MVP, uses fixed cost from application.yml.
 * Future: could read from database config table.
 */
@Slf4j
@Service
public class DeliveryCostCalculatorImpl implements DeliveryCostCalculator {

    private final BigDecimal fixedDeliveryCost;

    public DeliveryCostCalculatorImpl(@Value("${app.delivery.fixed-cost:1500.00}") BigDecimal fixedCost) {
        this.fixedDeliveryCost = fixedCost;
        log.info("Delivery cost configured: {}", fixedCost);
    }

    @Override
    public BigDecimal calculate(DeliveryType deliveryType) {
        if (deliveryType == DeliveryType.PICKUP) {
            log.debug("Delivery cost for PICKUP: 0.00");
            return BigDecimal.ZERO;
        }

        log.debug("Delivery cost for HOME_DELIVERY: {}", fixedDeliveryCost);
        return fixedDeliveryCost;
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/infrastructure/mapper/OrderMapper.java ==========
package com.flavia.dermobeauty.sales.infrastructure.mapper;

import com.flavia.dermobeauty.sales.domain.*;
import com.flavia.dermobeauty.sales.infrastructure.persistence.OrderEntity;
import com.flavia.dermobeauty.sales.infrastructure.persistence.OrderItemEntity;
import org.springframework.stereotype.Component;

import java.util.stream.Collectors;

/**
 * Mapper between Order domain model and OrderEntity JPA entity.
 * Handles conversion in both directions including nested OrderItems.
 */
@Component
public class OrderMapper {

    /**
     * Convert domain Order to JPA OrderEntity.
     */
    public OrderEntity toEntity(Order order) {
        OrderEntity entity = OrderEntity.builder()
                .id(order.getId())
                .orderNumber(order.getOrderNumber())
                .customerName(order.getCustomerInfo().getName())
                .customerEmail(order.getCustomerInfo().getEmail())
                .customerWhatsapp(order.getCustomerInfo().getWhatsapp())
                .deliveryType(order.getDeliveryInfo().getDeliveryType())
                .deliveryAddress(order.getDeliveryInfo().getAddress())
                .deliveryCity(order.getDeliveryInfo().getCity())
                .deliveryPostalCode(order.getDeliveryInfo().getPostalCode())
                .deliveryProvince(order.getDeliveryInfo().getProvince())
                .deliveryNotes(order.getDeliveryInfo().getNotes())
                .subtotal(order.getSubtotal())
                .deliveryCost(order.getDeliveryCost())
                .total(order.getTotal())
                .status(order.getStatus())
                .paymentStatus(order.getPaymentStatus())
                .mercadoPagoPreferenceId(order.getMercadoPagoPreferenceId())
                .mercadoPagoPaymentId(order.getMercadoPagoPaymentId())
                .createdAt(order.getCreatedAt())
                .updatedAt(order.getUpdatedAt())
                .build();

        // Map items
        order.getItems().forEach(item -> {
            OrderItemEntity itemEntity = OrderItemEntity.builder()
                    .id(item.getId())
                    .productId(item.getProductId())
                    .productName(item.getProductName())
                    .productPrice(item.getProductPrice())
                    .quantity(item.getQuantity())
                    .subtotal(item.getSubtotal())
                    .build();
            entity.addItem(itemEntity);
        });

        return entity;
    }

    /**
     * Convert JPA OrderEntity to domain Order.
     */
    public Order toDomain(OrderEntity entity) {
        CustomerInfo customerInfo = new CustomerInfo(
                entity.getCustomerName(),
                entity.getCustomerEmail(),
                entity.getCustomerWhatsapp()
        );

        DeliveryInfo deliveryInfo = new DeliveryInfo(
                entity.getDeliveryType(),
                entity.getDeliveryAddress(),
                entity.getDeliveryCity(),
                entity.getDeliveryPostalCode(),
                entity.getDeliveryProvince(),
                entity.getDeliveryNotes()
        );

        Order order = Order.builder()
                .id(entity.getId())
                .orderNumber(entity.getOrderNumber())
                .customerInfo(customerInfo)
                .deliveryInfo(deliveryInfo)
                .items(entity.getItems().stream()
                        .map(this::itemToDomain)
                        .collect(Collectors.toList()))
                .subtotal(entity.getSubtotal())
                .deliveryCost(entity.getDeliveryCost())
                .total(entity.getTotal())
                .status(entity.getStatus())
                .paymentStatus(entity.getPaymentStatus())
                .mercadoPagoPreferenceId(entity.getMercadoPagoPreferenceId())
                .mercadoPagoPaymentId(entity.getMercadoPagoPaymentId())
                .createdAt(entity.getCreatedAt())
                .updatedAt(entity.getUpdatedAt())
                .build();

        return order;
    }

    private OrderItem itemToDomain(OrderItemEntity entity) {
        return OrderItem.builder()
                .id(entity.getId())
                .productId(entity.getProductId())
                .productName(entity.getProductName())
                .productPrice(entity.getProductPrice())
                .quantity(entity.getQuantity())
                .subtotal(entity.getSubtotal())
                .build();
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/infrastructure/notification/StubOrderNotificationService.java ==========
package com.flavia.dermobeauty.sales.infrastructure.notification;

import com.flavia.dermobeauty.sales.application.port.NotificationService;
import com.flavia.dermobeauty.sales.domain.Order;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

/**
 * Stub implementation of NotificationService for Phase 6.
 * Will be replaced with full email implementation in Phase 8.
 */
@Slf4j
@Service("orderNotificationService")
public class StubOrderNotificationService implements NotificationService {

    @Override
    public void sendOrderConfirmation(Order order) {
        log.info("STUB: Would send order confirmation email for {} to {}",
                order.getOrderNumber(),
                order.getCustomerInfo().getEmail());

        // No-op for now - will implement email sending in Phase 8
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/infrastructure/persistence/JpaOrderRepository.java ==========
package com.flavia.dermobeauty.sales.infrastructure.persistence;

import com.flavia.dermobeauty.sales.domain.OrderStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

/**
 * Spring Data JPA repository for OrderEntity.
 * Infrastructure implementation detail.
 */
@Repository
public interface JpaOrderRepository extends JpaRepository<OrderEntity, Long> {

    Optional<OrderEntity> findByOrderNumber(String orderNumber);

    Optional<OrderEntity> findByMercadoPagoPaymentId(String paymentId);

    List<OrderEntity> findByStatus(OrderStatus status);
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/infrastructure/persistence/OrderEntity.java ==========
package com.flavia.dermobeauty.sales.infrastructure.persistence;

import com.flavia.dermobeauty.booking.domain.PaymentStatus;
import com.flavia.dermobeauty.sales.domain.DeliveryType;
import com.flavia.dermobeauty.sales.domain.OrderStatus;
import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

/**
 * JPA entity for orders table.
 * Infrastructure layer representation of Order aggregate.
 */
@Entity
@Table(name = "orders")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class OrderEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @EqualsAndHashCode.Include
    private Long id;

    @Column(name = "order_number", nullable = false, unique = true, length = 50)
    private String orderNumber;

    // Customer information
    @Column(name = "customer_name", nullable = false, length = 200)
    private String customerName;

    @Column(name = "customer_email", nullable = false, length = 200)
    private String customerEmail;

    @Column(name = "customer_whatsapp", nullable = false, length = 50)
    private String customerWhatsapp;

    // Delivery information
    @Enumerated(EnumType.STRING)
    @Column(name = "delivery_type", nullable = false, length = 20)
    private DeliveryType deliveryType;

    @Column(name = "delivery_address_street", length = 300)
    private String deliveryAddress;

    @Column(name = "delivery_address_city", length = 100)
    private String deliveryCity;

    @Column(name = "delivery_address_postal_code", length = 20)
    private String deliveryPostalCode;

    @Column(name = "delivery_address_state", length = 100)
    private String deliveryProvince;

    @Column(name = "delivery_notes", columnDefinition = "TEXT")
    private String deliveryNotes;

    // Order items (OneToMany relationship)
    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true)
    @Builder.Default
    @ToString.Exclude
    private List<OrderItemEntity> items = new ArrayList<>();

    // Pricing
    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal subtotal;

    @Column(name = "delivery_cost", nullable = false, precision = 10, scale = 2)
    private BigDecimal deliveryCost;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal total;

    // Status tracking
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private OrderStatus status;

    // Payment information
    @Enumerated(EnumType.STRING)
    @Column(name = "payment_status", nullable = false, length = 20)
    private PaymentStatus paymentStatus;

    @Column(name = "mercadopago_preference_id", length = 200)
    private String mercadoPagoPreferenceId;

    @Column(name = "mercadopago_payment_id", length = 200)
    private String mercadoPagoPaymentId;

    // Timestamps
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = LocalDateTime.now();
        }
        if (updatedAt == null) {
            updatedAt = LocalDateTime.now();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }

    /**
     * Helper method to add item and maintain bidirectional relationship.
     */
    public void addItem(OrderItemEntity item) {
        items.add(item);
        item.setOrder(this);
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/infrastructure/persistence/OrderItemEntity.java ==========
package com.flavia.dermobeauty.sales.infrastructure.persistence;

import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * JPA entity for order_items table.
 * Part of Order aggregate in infrastructure layer.
 */
@Entity
@Table(name = "order_items")
@Getter@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class OrderItemEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @EqualsAndHashCode.Include
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id", nullable = false)
    @ToString.Exclude
    private OrderEntity order;

    @Column(name = "product_id", nullable = false)
    private Long productId;

    // Snapshot of product at time of order
    @Column(name = "product_name", nullable = false, length = 200)
    private String productName;

    @Column(name = "product_price", nullable = false, precision = 10, scale = 2)
    private BigDecimal productPrice;

    @Column(nullable = false)
    private Integer quantity;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal subtotal;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = LocalDateTime.now();
        }
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/infrastructure/persistence/OrderRepositoryAdapter.java ==========
package com.flavia.dermobeauty.sales.infrastructure.persistence;

import com.flavia.dermobeauty.sales.domain.Order;
import com.flavia.dermobeauty.sales.domain.OrderRepository;
import com.flavia.dermobeauty.sales.domain.OrderStatus;
import com.flavia.dermobeauty.sales.infrastructure.mapper.OrderMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional; // <--- IMPORTANTE

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Component
@RequiredArgsConstructor
public class OrderRepositoryAdapter implements OrderRepository {

    private final JpaOrderRepository jpaRepository;
    private final OrderMapper mapper;

    @Override
    @Transactional // Para escritura
    public Order save(Order order) {
        OrderEntity entity = mapper.toEntity(order);
        OrderEntity saved = jpaRepository.save(entity);
        return mapper.toDomain(saved);
    }

    @Override
    @Transactional(readOnly = true) // <--- AGREGAR ESTO (Mantiene la sesión DB abierta)
    public Optional<Order> findById(Long id) {
        return jpaRepository.findById(id)
                .map(mapper::toDomain);
    }

    @Override
    @Transactional(readOnly = true) // <--- AGREGAR ESTO
    public Optional<Order> findByOrderNumber(String orderNumber) {
        return jpaRepository.findByOrderNumber(orderNumber)
                .map(mapper::toDomain);
    }

    @Override
    @Transactional(readOnly = true) // <--- AGREGAR ESTO
    public Optional<Order> findByMercadoPagoPaymentId(String paymentId) {
        return jpaRepository.findByMercadoPagoPaymentId(paymentId)
                .map(mapper::toDomain);
    }

    @Override
    @Transactional(readOnly = true) // <--- AGREGAR ESTO (CRÍTICO PARA LA LISTA)
    public List<Order> findAll() {
        return jpaRepository.findAll()
                .stream()
                .map(mapper::toDomain)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true) // <--- AGREGAR ESTO
    public List<Order> findByStatus(OrderStatus status) {
        return jpaRepository.findByStatus(status)
                .stream()
                .map(mapper::toDomain)
                .collect(Collectors.toList());
    }
}

========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/infrastructure/stock/StockServiceImpl.java ==========
package com.flavia.dermobeauty.sales.infrastructure.stock;

import com.flavia.dermobeauty.catalog.repository.ProductRepository;
import com.flavia.dermobeauty.sales.application.port.StockService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

/**
 * Implementation of StockService using product repository.
 * Manages product stock levels with pessimistic locking.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class StockServiceImpl implements StockService {

    private final ProductRepository productRepository;

    @Override
    @Transactional(readOnly = true)
    public boolean checkAvailability(Long productId, Integer quantity) {
        return productRepository.findById(productId)
                .map(p -> p.getStock() >= quantity)
                .orElse(false);
    }

    @Override
    @Transactional
    public void decrementStock(Long productId, Integer quantity) {
        int updatedRows = productRepository.decrementStock(productId, quantity);

        if (updatedRows == 0) {
             log.error("Stock update failed for product {}. Requested: {}", productId, quantity);
            throw new IllegalStateException("No hay stock suficiente para completar la operación o el producto no existe.");
        }

        log.info("Decremented stock for product {}: -{} units", productId, quantity);
    }
}

========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/web/AdminOperationsController.java ==========
package com.flavia.dermobeauty.sales.web;

import com.flavia.dermobeauty.booking.application.usecase.CancelBookingUseCase;
import com.flavia.dermobeauty.booking.application.usecase.ListBookingsUseCase;
import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.web.dto.BookingResponse;
import com.flavia.dermobeauty.sales.application.usecase.ListOrdersUseCase;
import com.flavia.dermobeauty.sales.application.usecase.UpdateOrderStatusUseCase;
import com.flavia.dermobeauty.sales.domain.Order;
import com.flavia.dermobeauty.sales.domain.OrderStatus;
import com.flavia.dermobeauty.sales.web.dto.OrderResponse;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/admin")
@RequiredArgsConstructor
public class AdminOperationsController {

    private final ListBookingsUseCase listBookingsUseCase;
    private final CancelBookingUseCase cancelBookingUseCase;
    private final ListOrdersUseCase listOrdersUseCase;
    private final UpdateOrderStatusUseCase updateOrderStatusUseCase;

    // ==================== BOOKINGS ====================

    @GetMapping("/bookings")
    public ResponseEntity<ApiResponse<List<BookingResponse>>> getBookings() {
        List<BookingResponse> bookings = listBookingsUseCase.execute().stream()
                .map(BookingResponse::fromDomain)
                .collect(Collectors.toList());
        return ResponseEntity.ok(ApiResponse.success(bookings));
    }

    @DeleteMapping("/bookings/{id}")
    public ResponseEntity<ApiResponse<Void>> cancelBooking(@PathVariable Long id) {
        cancelBookingUseCase.execute(id);
        return ResponseEntity.ok(ApiResponse.success("Turno cancelado"));
    }

    // ==================== ORDERS ====================

    @GetMapping("/orders")
    public ResponseEntity<ApiResponse<List<OrderResponse>>> getOrders() {
        List<OrderResponse> orders = listOrdersUseCase.execute().stream()
                .map(OrderResponse::fromDomain)
                .collect(Collectors.toList());
        return ResponseEntity.ok(ApiResponse.success(orders));
    }

    @PatchMapping("/orders/{id}/status")
    public ResponseEntity<ApiResponse<OrderResponse>> updateOrderStatus(
            @PathVariable Long id,
            @RequestBody UpdateStatusRequest request) {

        Order updated = updateOrderStatusUseCase.execute(id, request.getStatus());
        return ResponseEntity.ok(ApiResponse.success(OrderResponse.fromDomain(updated)));
    }

    @Data
    public static class UpdateStatusRequest {
        private OrderStatus status;
    }
}

========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/web/dto/CreateOrderRequest.java ==========
package com.flavia.dermobeauty.sales.web.dto;

import com.flavia.dermobeauty.sales.domain.DeliveryType;
import jakarta.validation.Valid;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

/**
 * DTO for creating a new order request.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateOrderRequest {

    @NotBlank(message = "Customer name is required")
    private String customerName;

    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    private String customerEmail;

    @NotBlank(message = "WhatsApp number is required")
    private String customerWhatsapp;

    @NotNull(message = "Delivery type is required")
    private DeliveryType deliveryType;

    private String deliveryAddress;
    private String deliveryCity;
    private String deliveryPostalCode;
    private String deliveryProvince;
    private String deliveryNotes;

    @NotEmpty(message = "Order must have at least one item")
    @Valid
    private List<OrderItemRequest> items;
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/web/dto/OrderItemRequest.java ==========
package com.flavia.dermobeauty.sales.web.dto;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO for order item in create order request.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderItemRequest {

    @NotNull(message = "Product ID is required")
    private Long productId;

    @NotNull(message = "Quantity is required")
    @Min(value = 1, message = "Quantity must be at least 1")
    private Integer quantity;
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/web/dto/OrderResponse.java ==========
package com.flavia.dermobeauty.sales.web.dto;

import com.flavia.dermobeauty.booking.domain.PaymentStatus;
import com.flavia.dermobeauty.sales.domain.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

/**
 * DTO for order response.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class OrderResponse {

    private Long id;
    private String orderNumber;
    private String customerName;
    private String customerEmail;
    private String customerWhatsapp;
    private DeliveryType deliveryType;
    private String deliveryAddress;
    private String deliveryCity;
    private List<OrderItemResponse> items;
    private BigDecimal subtotal;
    private BigDecimal deliveryCost;
    private BigDecimal total;
    private OrderStatus status;
    private PaymentStatus paymentStatus;
    private String mercadoPagoPreferenceId;
    private LocalDateTime createdAt;

    public static OrderResponse fromDomain(Order order) {
        return OrderResponse.builder()
                .id(order.getId())
                .orderNumber(order.getOrderNumber())
                .customerName(order.getCustomerInfo().getName())
                .customerEmail(order.getCustomerInfo().getEmail())
                .customerWhatsapp(order.getCustomerInfo().getWhatsapp())
                .deliveryType(order.getDeliveryInfo().getDeliveryType())
                .deliveryAddress(order.getDeliveryInfo().getAddress())
                .deliveryCity(order.getDeliveryInfo().getCity())
                .items(order.getItems().stream()
                        .map(OrderItemResponse::fromDomain)
                        .collect(Collectors.toList()))
                .subtotal(order.getSubtotal())
                .deliveryCost(order.getDeliveryCost())
                .total(order.getTotal())
                .status(order.getStatus())
                .paymentStatus(order.getPaymentStatus())
                .mercadoPagoPreferenceId(order.getMercadoPagoPreferenceId())
                .createdAt(order.getCreatedAt())
                .build();
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class OrderItemResponse {
        private Long productId;
        private String productName;
        private BigDecimal productPrice;
        private Integer quantity;
        private BigDecimal subtotal;

        public static OrderItemResponse fromDomain(OrderItem item) {
            return OrderItemResponse.builder()
                    .productId(item.getProductId())
                    .productName(item.getProductName())
                    .productPrice(item.getProductPrice())
                    .quantity(item.getQuantity())
                    .subtotal(item.getSubtotal())
                    .build();
        }
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/web/OrderController.java ==========
package com.flavia.dermobeauty.sales.web;

import com.flavia.dermobeauty.sales.application.usecase.CreateOrderUseCase;
import com.flavia.dermobeauty.sales.application.usecase.GetOrderByNumberUseCase;
import com.flavia.dermobeauty.sales.domain.Order;
import com.flavia.dermobeauty.sales.web.dto.CreateOrderRequest;
import com.flavia.dermobeauty.sales.web.dto.OrderItemRequest;
import com.flavia.dermobeauty.sales.web.dto.OrderResponse;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

/**
 * REST controller for order operations.
 * Public endpoints for customers to create and check orders.
 */
@Slf4j
@RestController
@RequestMapping("/api/public/orders")
@RequiredArgsConstructor
public class OrderController {

    private final CreateOrderUseCase createOrderUseCase;
    private final GetOrderByNumberUseCase getOrderByNumberUseCase;

    @PostMapping
    public ResponseEntity<ApiResponse<OrderResponse>> createOrder(
            @Valid @RequestBody CreateOrderRequest request) {

        log.info("Creating order for customer: {}", request.getCustomerEmail());

        List<CreateOrderUseCase.OrderItemRequest> itemRequests = request.getItems().stream()
                .map(item -> new CreateOrderUseCase.OrderItemRequest(item.getProductId(), item.getQuantity()))
                .collect(Collectors.toList());

        Order order = createOrderUseCase.execute(
                request.getCustomerName(),
                request.getCustomerEmail(),
                request.getCustomerWhatsapp(),
                request.getDeliveryType(),
                request.getDeliveryAddress(),
                request.getDeliveryCity(),
                request.getDeliveryPostalCode(),
                request.getDeliveryProvince(),
                request.getDeliveryNotes(),
                itemRequests
        );

        OrderResponse response = OrderResponse.fromDomain(order);
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.success(response, "Order created successfully"));
    }

    @GetMapping("/{orderNumber}")
    public ResponseEntity<ApiResponse<OrderResponse>> getOrderByNumber(
            @PathVariable String orderNumber) {

        log.debug("Fetching order: {}", orderNumber);

        Order order = getOrderByNumberUseCase.execute(orderNumber);
        OrderResponse response = OrderResponse.fromDomain(order);

        return ResponseEntity.ok(ApiResponse.success(response));
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/security/config/SecurityConfig.java ==========
package com.flavia.dermobeauty.security.config;

import com.flavia.dermobeauty.security.jwt.JwtAuthenticationFilter;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.List;

/**
 * Spring Security configuration for the application.
 * Configures CORS, JWT authentication, and endpoint authorization.
 */
@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .cors(cors -> cors.configurationSource(corsConfigurationSource()))
                .csrf(csrf -> csrf.disable())
                .sessionManagement(session ->
                        session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .authorizeHttpRequests(auth -> auth
                        // Public endpoints
                        .requestMatchers("/api/public/**").permitAll()
                        .requestMatchers("/api/mp/webhook").permitAll()
                        .requestMatchers("/api/auth/login").permitAll()
                        .requestMatchers("/api/uploads/**").permitAll()
                        .requestMatchers("/api/test/**").permitAll() // TODO: Remove in production!
                        // Admin endpoints
                        .requestMatchers("/api/admin/**").hasRole("ADMIN")
                        // All other requests require authentication
                        .anyRequest().authenticated()
                )
                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(List.of("http://localhost:5173", "https://flaviadermobeauty.com","https://api.flaviadermobeauty.com"));
        configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(List.of("*"));
        configuration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/security/controller/AuthController.java ==========
package com.flavia.dermobeauty.security.controller;

import com.flavia.dermobeauty.security.dto.LoginRequest;
import com.flavia.dermobeauty.security.dto.LoginResponse;
import com.flavia.dermobeauty.security.jwt.JwtTokenProvider;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * Authentication controller for admin login.
 * Validates hardcoded credentials and returns JWT token.
 */
@Slf4j
@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
public class AuthController {

    private final JwtTokenProvider jwtTokenProvider;
    private final PasswordEncoder passwordEncoder;

    @Value("${admin.username}")
    private String adminUsername;

    @Value("${admin.password}")
    private String adminPasswordHash;

    @PostMapping("/login")
    public ResponseEntity<ApiResponse<LoginResponse>> login(@Valid @RequestBody LoginRequest request) {
        log.info("Login attempt for user: {}", request.getUsername());

        if (!adminUsername.equals(request.getUsername())) {
            log.warn("Login failed: Invalid username");
            return ResponseEntity.status(401)
                    .body(ApiResponse.success(null, "Invalid credentials"));
        }

        if (!passwordEncoder.matches(request.getPassword(), adminPasswordHash)) {
            log.warn("Login failed: Invalid password");
            return ResponseEntity.status(401)
                    .body(ApiResponse.success(null, "Invalid credentials"));
        }

        String token = jwtTokenProvider.generateToken(adminUsername);
        LoginResponse response = new LoginResponse(token, adminUsername, "ADMIN");

        log.info("Login successful for user: {}", adminUsername);
        return ResponseEntity.ok(ApiResponse.success(response));
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/security/dto/LoginRequest.java ==========
package com.flavia.dermobeauty.security.dto;

import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO for admin login request.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequest {

    @NotBlank(message = "Username is required")
    private String username;

    @NotBlank(message = "Password is required")
    private String password;
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/security/dto/LoginResponse.java ==========
package com.flavia.dermobeauty.security.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO for admin login response containing JWT token.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginResponse {

    private String token;
    private String username;
    private String role;
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/security/jwt/JwtAuthenticationFilter.java ==========
package com.flavia.dermobeauty.security.jwt;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.List;

/**
 * JWT authentication filter that intercepts requests and validates JWT tokens.
 * Runs once per request before Spring Security's filter chain.
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private static final String AUTHORIZATION_HEADER = "Authorization";
    private static final String BEARER_PREFIX = "Bearer ";

    private final JwtTokenProvider jwtTokenProvider;

    @Override
    protected void doFilterInternal(
            HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain) throws ServletException, IOException {

        try {
            String jwt = extractJwtFromRequest(request);

            if (jwt != null && jwtTokenProvider.validateToken(jwt)) {
                String username = jwtTokenProvider.getUsername(jwt);

                UsernamePasswordAuthenticationToken authentication =
                        new UsernamePasswordAuthenticationToken(
                                username,
                                null,
                                List.of(new SimpleGrantedAuthority("ROLE_ADMIN"))
                        );

                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authentication);

                log.debug("Set authentication for user: {}", username);
            }
        } catch (Exception ex) {
            log.error("Could not set user authentication in security context", ex);
        }

        filterChain.doFilter(request, response);
    }

    /**
     * Extract JWT token from Authorization header.
     *
     * @param request HTTP request
     * @return JWT token or null if not present
     */
    private String extractJwtFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader(AUTHORIZATION_HEADER);

        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith(BEARER_PREFIX)) {
            return bearerToken.substring(BEARER_PREFIX.length());
        }

        return null;
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/security/jwt/JwtTokenProvider.java ==========
package com.flavia.dermobeauty.security.jwt;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;

/**
 * Provides JWT token generation and validation functionality.
 * Uses HMAC-SHA256 signing algorithm.
 */
@Slf4j
@Component
public class JwtTokenProvider {

    private final SecretKey secretKey;
    private final long validityInMilliseconds;

    public JwtTokenProvider(
            @Value("${jwt.secret}") String secret,
            @Value("${jwt.expiration}") long validityInMilliseconds) {
        this.secretKey = Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));
        this.validityInMilliseconds = validityInMilliseconds;
    }

    /**
     * Generate JWT token for the given username.
     *
     * @param username Username to encode in the token
     * @return JWT token string
     */
    public String generateToken(String username) {
        Date now = new Date();
        Date validity = new Date(now.getTime() + validityInMilliseconds);

        return Jwts.builder()
                .subject(username)
                .issuedAt(now)
                .expiration(validity)
                .signWith(secretKey, Jwts.SIG.HS256)
                .compact();
    }

    /**
     * Extract username from JWT token.
     *
     * @param token JWT token
     * @return Username encoded in the token
     */
    public String getUsername(String token) {
        Claims claims = Jwts.parser()
                .verifyWith(secretKey)
                .build()
                .parseSignedClaims(token)
                .getPayload();

        return claims.getSubject();
    }

    /**
     * Validate JWT token.
     *
     * @param token JWT token to validate
     * @return true if valid, false otherwise
     */
    public boolean validateToken(String token) {
        try {
            Jwts.parser()
                    .verifyWith(secretKey)
                    .build()
                    .parseSignedClaims(token);
            return true;
        } catch (Exception e) {
            log.warn("Invalid JWT token: {}", e.getMessage());
            return false;
        }
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/shared/exception/DomainException.java ==========
package com.flavia.dermobeauty.shared.exception;

/**
 * Base exception for domain-level business rule violations.
 * Extends RuntimeException to avoid polluting domain layer with checked exceptions.
 */
public class DomainException extends RuntimeException {

    public DomainException(String message) {
        super(message);
    }

    public DomainException(String message, Throwable cause) {
        super(message, cause);
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/shared/exception/PaymentException.java ==========
package com.flavia.dermobeauty.shared.exception;

/**
 * Exception thrown for payment processing failures.
 * Results in HTTP 502 responses (bad gateway from payment provider).
 */
public class PaymentException extends DomainException {

    public PaymentException(String message) {
        super(message);
    }

    public PaymentException(String message, Throwable cause) {
        super(message, cause);
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/shared/exception/ResourceNotFoundException.java ==========
package com.flavia.dermobeauty.shared.exception;

/**
 * Exception thrown when a requested resource is not found.
 * Results in HTTP 404 responses.
 */
public class ResourceNotFoundException extends DomainException {

    public ResourceNotFoundException(String resourceType, Object id) {
        super(String.format("%s with id '%s' not found", resourceType, id));
    }

    public ResourceNotFoundException(String message) {
        super(message);
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/shared/exception/ValidationException.java ==========
package com.flavia.dermobeauty.shared.exception;

/**
 * Exception thrown for domain validation failures.
 * Results in HTTP 400 responses.
 */
public class ValidationException extends DomainException {

    public ValidationException(String message) {
        super(message);
    }

    public ValidationException(String message, Throwable cause) {
        super(message, cause);
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/shared/web/ApiResponse.java ==========
package com.flavia.dermobeauty.shared.web;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Generic wrapper for successful API responses.
 * Provides consistent response structure across all endpoints.
 *
 * @param <T> Type of the response data
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ApiResponse<T> {

    private boolean success;
    private T data;
    private String message;

    public static <T> ApiResponse<T> success(T data) {
        return new ApiResponse<>(true, data, null);
    }

    public static <T> ApiResponse<T> success(T data, String message) {
        return new ApiResponse<>(true, data, message);
    }

    public static <T> ApiResponse<T> success(String message) {
        return new ApiResponse<>(true, null, message);
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/shared/web/ErrorResponse.java ==========
package com.flavia.dermobeauty.shared.web;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.Map;

/**
 * Standardized error response structure for all API errors.
 * Includes timestamp, error details, and optional field-level validation errors.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ErrorResponse {

    private boolean success = false;
    private String error;
    private String message;
    private LocalDateTime timestamp;
    private String path;
    private Map<String, String> fieldErrors;

    public ErrorResponse(String error, String message, String path) {
        this.error = error;
        this.message = message;
        this.timestamp = LocalDateTime.now();
        this.path = path;
    }

    public ErrorResponse(String error, String message, String path, Map<String, String> fieldErrors) {
        this.error = error;
        this.message = message;
        this.timestamp = LocalDateTime.now();
        this.path = path;
        this.fieldErrors = fieldErrors;
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/shared/web/GlobalExceptionHandler.java ==========
package com.flavia.dermobeauty.shared.web;

import com.flavia.dermobeauty.shared.exception.DomainException;
import com.flavia.dermobeauty.shared.exception.PaymentException;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import com.flavia.dermobeauty.shared.exception.ValidationException;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.HashMap;
import java.util.Map;

/**
 * Global exception handler for all REST controllers.
 * Provides consistent error responses across the application.
 */
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleResourceNotFound(
            ResourceNotFoundException ex,
            HttpServletRequest request) {

        log.warn("Resource not found: {}", ex.getMessage());

        ErrorResponse error = new ErrorResponse(
                "NOT_FOUND",
                ex.getMessage(),
                request.getRequestURI()
        );

        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }

    @ExceptionHandler(ValidationException.class)
    public ResponseEntity<ErrorResponse> handleValidation(
            ValidationException ex,
            HttpServletRequest request) {

        log.warn("Validation error: {}", ex.getMessage());

        ErrorResponse error = new ErrorResponse(
                "VALIDATION_ERROR",
                ex.getMessage(),
                request.getRequestURI()
        );

        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleMethodArgumentNotValid(
            MethodArgumentNotValidException ex,
            HttpServletRequest request) {

        Map<String, String> fieldErrors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach(error -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            fieldErrors.put(fieldName, errorMessage);
        });

        log.warn("Bean validation failed: {}", fieldErrors);

        ErrorResponse error = new ErrorResponse(
                "VALIDATION_ERROR",
                "Invalid request data",
                request.getRequestURI(),
                fieldErrors
        );

        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }

    @ExceptionHandler(PaymentException.class)
    public ResponseEntity<ErrorResponse> handlePayment(
            PaymentException ex,
            HttpServletRequest request) {

        log.error("Payment processing error: {}", ex.getMessage(), ex);

        ErrorResponse error = new ErrorResponse(
                "PAYMENT_ERROR",
                ex.getMessage(),
                request.getRequestURI()
        );

        return ResponseEntity.status(HttpStatus.BAD_GATEWAY).body(error);
    }

    @ExceptionHandler(DomainException.class)
    public ResponseEntity<ErrorResponse> handleDomain(
            DomainException ex,
            HttpServletRequest request) {

        log.warn("Domain exception: {}", ex.getMessage());

        ErrorResponse error = new ErrorResponse(
                "BUSINESS_RULE_VIOLATION",
                ex.getMessage(),
                request.getRequestURI()
        );

        return ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY).body(error);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneral(
            Exception ex,
            HttpServletRequest request) {

        log.error("Unexpected error", ex);

        ErrorResponse error = new ErrorResponse(
                "INTERNAL_ERROR",
                "An unexpected error occurred. Please try again later.",
                request.getRequestURI()
        );

        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}


========== FILE: ./src/main/resources/application-dev.yml ==========
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/dermobeauty_dev
    username: dermobeauty
    password: dermobeauty
    driver-class-name: org.postgresql.Driver
  jpa:
    show-sql: true
    properties:
      hibernate:
        format_sql: false
  mail:
    host: smtp.gmail.com
    port: 587
    username: 'flavia.dermobeauty@gmail.com'
    password: 'qajp ptwr gdjg uozl'
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true
            required: true
          connectiontimeout: 5000
          timeout: 5000
          writetimeout: 5000

# Admin credentials (change in production!)
admin:
  username: admin
  # BCrypt hash for "admin123" (verified)
  password: $2a$10$OQlalRpvK3/0ikEa3xO62ujds5OHSF723wIXh3gIk7ca7nJmp0c9q

# JWT configuration
jwt:
  secret: flavia-dermobeauty-jwt-secret-key-change-in-production-2024
  expiration: 86400000 # 24 hours in milliseconds

# Mercado Pago configuration
mercadopago:
  access-token: APP_USR-3480197543728175-092819-981988e8773a0af18511e1e610ba5f23-2719878562
  base-url: https://flaviadermobeauty.com

# Application settings
app:
  api-url: https://api.flaviadermobeauty.com
  upload-dir: ./uploads
  email:
    from: flavia.dermobeauty@gmail.com
    from-name: Flavia Dermobeauty
  delivery:
    fixed-cost: 1500.00

# Logging
logging:
  level:
    com.flavia.dermobeauty: DEBUG
    org.springframework.web: INFO
    org.hibernate.SQL: DEBUG


========== FILE: ./src/main/resources/application.yml ==========
spring:
  application:
    name: dermobeauty
  profiles:
    active: dev
  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: false
    open-in-view: false
  flyway:
    enabled: true
    baseline-on-migrate: true
  servlet:
    multipart:
      max-file-size: 5MB
      max-request-size: 10MB

server:
  port: 8080
  error:
    include-message: always
    include-binding-errors: always


========== FILE: ./src/main/resources/db/migration/V1__create_categories_table.sql ==========
-- Categories table for both services and products
CREATE TABLE categories (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    slug VARCHAR(100) NOT NULL UNIQUE,
    description TEXT,
    type VARCHAR(20) NOT NULL CHECK (type IN ('SERVICE', 'PRODUCT')),
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Indexes
CREATE INDEX idx_categories_type ON categories(type);
CREATE INDEX idx_categories_slug ON categories(slug);

-- Comments
COMMENT ON TABLE categories IS 'Categories for organizing services and products';
COMMENT ON COLUMN categories.type IS 'Type of category: SERVICE or PRODUCT';


========== FILE: ./src/main/resources/db/migration/V2__create_services_table.sql ==========
-- Services table for bookable beauty/dermatology treatments
CREATE TABLE services (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    slug VARCHAR(200) NOT NULL UNIQUE,
    description TEXT NOT NULL,
    short_description VARCHAR(500),
    duration_minutes INTEGER NOT NULL,
    price DECIMAL(10, 2) NOT NULL,
    category_id BIGINT REFERENCES categories(id),
    is_featured BOOLEAN NOT NULL DEFAULT FALSE,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    image_url VARCHAR(500),
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT chk_duration_positive CHECK (duration_minutes > 0),
    CONSTRAINT chk_price_positive CHECK (price >= 0)
);

-- Indexes
CREATE INDEX idx_services_category ON services(category_id);
CREATE INDEX idx_services_featured ON services(is_featured) WHERE is_featured = TRUE;
CREATE INDEX idx_services_active ON services(is_active) WHERE is_active = TRUE;
CREATE INDEX idx_services_slug ON services(slug);

-- Comments
COMMENT ON TABLE services IS 'Beauty and dermatology services available for booking';
COMMENT ON COLUMN services.duration_minutes IS 'Duration of the service in minutes';
COMMENT ON COLUMN services.is_featured IS 'Whether to show this service on the homepage';


========== FILE: ./src/main/resources/db/migration/V3__create_products_table.sql ==========
-- Products table for beauty/dermatology products sold via e-commerce
CREATE TABLE products (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    slug VARCHAR(200) NOT NULL UNIQUE,
    description TEXT NOT NULL,
    short_description VARCHAR(500),
    price DECIMAL(10, 2) NOT NULL,
    stock INTEGER NOT NULL DEFAULT 0,
    category_id BIGINT REFERENCES categories(id),
    is_featured BOOLEAN NOT NULL DEFAULT FALSE,
    is_offer BOOLEAN NOT NULL DEFAULT FALSE,
    is_trending BOOLEAN NOT NULL DEFAULT FALSE,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    image_url VARCHAR(500),
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT chk_stock_non_negative CHECK (stock >= 0),
    CONSTRAINT chk_price_positive CHECK (price >= 0)
);

-- Indexes
CREATE INDEX idx_products_category ON products(category_id);
CREATE INDEX idx_products_featured ON products(is_featured) WHERE is_featured = TRUE;
CREATE INDEX idx_products_trending ON products(is_trending) WHERE is_trending = TRUE;
CREATE INDEX idx_products_offer ON products(is_offer) WHERE is_offer = TRUE;
CREATE INDEX idx_products_active ON products(is_active) WHERE is_active = TRUE;
CREATE INDEX idx_products_slug ON products(slug);

-- Comments
COMMENT ON TABLE products IS 'Beauty and dermatology products available for purchase';
COMMENT ON COLUMN products.stock IS 'Available inventory (decremented on confirmed orders)';
COMMENT ON COLUMN products.is_featured IS 'Whether to show this product on the homepage';
COMMENT ON COLUMN products.is_offer IS 'Whether this product is currently on sale/offer';
COMMENT ON COLUMN products.is_trending IS 'Whether this product is marked as trending';


========== FILE: ./src/main/resources/db/migration/V4__create_bookings_table.sql ==========
-- Bookings table for service appointments
CREATE TABLE bookings (
    id BIGSERIAL PRIMARY KEY,
    booking_number VARCHAR(50) NOT NULL UNIQUE,
    service_id BIGINT NOT NULL REFERENCES services(id),

    -- Customer information
    customer_name VARCHAR(200) NOT NULL,
    customer_email VARCHAR(200) NOT NULL,
    customer_whatsapp VARCHAR(50) NOT NULL,
    customer_comments TEXT,

    -- Booking details
    booking_date DATE NOT NULL,
    booking_time TIME NOT NULL,
    duration_minutes INTEGER NOT NULL,

    -- Status tracking
    status VARCHAR(20) NOT NULL DEFAULT 'PENDING'
        CHECK (status IN ('PENDING', 'CONFIRMED', 'CANCELLED', 'COMPLETED')),

    -- Payment information
    payment_status VARCHAR(20) NOT NULL DEFAULT 'PENDING'
        CHECK (payment_status IN ('PENDING', 'PAID', 'FAILED', 'REFUNDED')),
    mercadopago_preference_id VARCHAR(200),
    mercadopago_payment_id VARCHAR(200),
    amount DECIMAL(10, 2) NOT NULL,

    -- Timestamps
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    confirmed_at TIMESTAMP,
    cancelled_at TIMESTAMP,

    CONSTRAINT chk_amount_positive CHECK (amount >= 0)
);

-- Indexes for performance
CREATE INDEX idx_bookings_number ON bookings(booking_number);
CREATE INDEX idx_bookings_service ON bookings(service_id);
CREATE INDEX idx_bookings_date ON bookings(booking_date);
CREATE INDEX idx_bookings_status ON bookings(status);
CREATE INDEX idx_bookings_payment_status ON bookings(payment_status);
CREATE INDEX idx_bookings_customer_email ON bookings(customer_email);
CREATE INDEX idx_bookings_mp_payment ON bookings(mercadopago_payment_id) WHERE mercadopago_payment_id IS NOT NULL;

-- Prevent double-booking: same service, date, and time (excluding cancelled bookings)
CREATE UNIQUE INDEX idx_bookings_unique_slot ON bookings(service_id, booking_date, booking_time)
    WHERE status != 'CANCELLED';

-- Comments
COMMENT ON TABLE bookings IS 'Service appointments/bookings with payment tracking';
COMMENT ON COLUMN bookings.booking_number IS 'Human-readable booking reference (e.g., BOOK-20241205-001)';
COMMENT ON COLUMN bookings.mercadopago_preference_id IS 'Mercado Pago preference ID for payment';
COMMENT ON COLUMN bookings.mercadopago_payment_id IS 'Mercado Pago payment ID after successful payment';
-- Note: idx_bookings_unique_slot is a unique index that prevents double-booking the same time slot


========== FILE: ./src/main/resources/db/migration/V5__create_orders_table.sql ==========
-- Orders table for product purchases
CREATE TABLE orders (
    id BIGSERIAL PRIMARY KEY,
    order_number VARCHAR(50) NOT NULL UNIQUE,

    -- Customer information
    customer_name VARCHAR(200) NOT NULL,
    customer_email VARCHAR(200) NOT NULL,
    customer_whatsapp VARCHAR(50) NOT NULL,

    -- Delivery information
    delivery_type VARCHAR(20) NOT NULL CHECK (delivery_type IN ('PICKUP', 'HOME_DELIVERY')),
    delivery_address_street VARCHAR(300),
    delivery_address_city VARCHAR(100),
    delivery_address_state VARCHAR(100),
    delivery_address_postal_code VARCHAR(20),
    delivery_notes TEXT,

    -- Pricing
    subtotal DECIMAL(10, 2) NOT NULL,
    delivery_cost DECIMAL(10, 2) NOT NULL DEFAULT 0,
    total DECIMAL(10, 2) NOT NULL,

    -- Status tracking
    status VARCHAR(20) NOT NULL DEFAULT 'PENDING'
        CHECK (status IN ('PENDING', 'PAID', 'PREPARING', 'READY', 'DELIVERED', 'CANCELLED')),
    payment_status VARCHAR(20) NOT NULL DEFAULT 'PENDING'
        CHECK (payment_status IN ('PENDING', 'PAID', 'FAILED', 'REFUNDED')),

    -- Payment information
    mercadopago_preference_id VARCHAR(200),
    mercadopago_payment_id VARCHAR(200),

    -- Timestamps
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    paid_at TIMESTAMP,
    delivered_at TIMESTAMP,

    CONSTRAINT chk_subtotal_positive CHECK (subtotal >= 0),
    CONSTRAINT chk_delivery_cost_non_negative CHECK (delivery_cost >= 0),
    CONSTRAINT chk_total_positive CHECK (total >= 0)
);

-- Indexes for performance
CREATE INDEX idx_orders_number ON orders(order_number);
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_orders_payment_status ON orders(payment_status);
CREATE INDEX idx_orders_customer_email ON orders(customer_email);
CREATE INDEX idx_orders_created_at ON orders(created_at DESC);
CREATE INDEX idx_orders_mp_payment ON orders(mercadopago_payment_id) WHERE mercadopago_payment_id IS NOT NULL;

-- Comments
COMMENT ON TABLE orders IS 'Product orders with delivery and payment tracking';
COMMENT ON COLUMN orders.order_number IS 'Human-readable order reference (e.g., ORD-20241205-001)';
COMMENT ON COLUMN orders.delivery_type IS 'PICKUP: pickup at office, HOME_DELIVERY: delivery to address';
COMMENT ON COLUMN orders.subtotal IS 'Sum of all order items (before delivery cost)';
COMMENT ON COLUMN orders.total IS 'Final amount including delivery cost';


========== FILE: ./src/main/resources/db/migration/V6__create_order_items_table.sql ==========
-- Order items table for products in each order
CREATE TABLE order_items (
    id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
    product_id BIGINT NOT NULL REFERENCES products(id),

    -- Snapshot of product at time of order (preserves historical data)
    product_name VARCHAR(200) NOT NULL,
    product_price DECIMAL(10, 2) NOT NULL,

    -- Quantity and pricing
    quantity INTEGER NOT NULL,
    subtotal DECIMAL(10, 2) NOT NULL,

    -- Timestamps
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT chk_quantity_positive CHECK (quantity > 0),
    CONSTRAINT chk_product_price_non_negative CHECK (product_price >= 0),
    CONSTRAINT chk_subtotal_non_negative CHECK (subtotal >= 0)
);

-- Indexes for performance
CREATE INDEX idx_order_items_order ON order_items(order_id);
CREATE INDEX idx_order_items_product ON order_items(product_id);

-- Comments
COMMENT ON TABLE order_items IS 'Line items for each order with product snapshot';
COMMENT ON COLUMN order_items.product_name IS 'Product name at time of order (snapshot for history)';
COMMENT ON COLUMN order_items.product_price IS 'Product price at time of order (snapshot for history)';
COMMENT ON COLUMN order_items.subtotal IS 'Calculated as quantity * product_price';


========== FILE: ./src/main/resources/db/migration/V7__create_config_table.sql ==========
-- Application configuration table (key-value store)
CREATE TABLE app_config (
    id BIGSERIAL PRIMARY KEY,
    config_key VARCHAR(100) NOT NULL UNIQUE,
    config_value TEXT NOT NULL,
    description TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Indexes
CREATE INDEX idx_config_key ON app_config(config_key);

-- Comments
COMMENT ON TABLE app_config IS 'Application configuration settings (editable via admin panel)';
COMMENT ON COLUMN app_config.config_key IS 'Unique configuration key (e.g., site.name, delivery.fixed_cost)';
COMMENT ON COLUMN app_config.config_value IS 'Configuration value as text (parse as needed)';


========== FILE: ./src/main/resources/db/migration/V8__insert_initial_data.sql ==========
-- =====================================================
-- DATOS INICIALES - FLAVIA DERMOBEAUTY
-- Contenido en ESPAÑOL según especificación del proyecto
-- =====================================================

-- =====================================================
-- CATEGORÍAS
-- =====================================================

INSERT INTO categories (name, slug, description, type) VALUES
    ('Tratamientos Faciales', 'tratamientos-faciales', 'Tratamientos especializados para el cuidado y rejuvenecimiento del rostro', 'SERVICE'),
    ('Tratamientos Corporales', 'tratamientos-corporales', 'Tratamientos para el cuidado y embellecimiento del cuerpo', 'SERVICE'),
    ('Cuidado Facial', 'cuidado-facial', 'Productos especializados para el cuidado de la piel del rostro', 'PRODUCT'),
    ('Cuidado Corporal', 'cuidado-corporal', 'Productos para el cuidado integral de la piel del cuerpo', 'PRODUCT');

-- =====================================================
-- SERVICIOS DE EJEMPLO
-- =====================================================

INSERT INTO services (name, slug, description, short_description, duration_minutes, price, category_id, is_featured, is_active) VALUES
    (
        'Limpieza Facial Profunda',
        'limpieza-facial-profunda',
        'Tratamiento completo de limpieza facial que incluye: exfoliación, extracción de impurezas, aplicación de máscara purificante y hidratación profunda. Ideal para todo tipo de piel.',
        'Limpieza profunda con extracción y máscara purificante',
        60,
        12000.00,
        (SELECT id FROM categories WHERE slug = 'tratamientos-faciales'),
        TRUE,
        TRUE
    ),
    (
        'Peeling Químico',
        'peeling-quimico',
        'Renovación celular mediante la aplicación de ácidos que eliminan las capas superficiales de la piel, reduciendo manchas, líneas de expresión y mejorando la textura cutánea.',
        'Renovación celular para reducir manchas y líneas',
        45,
        18000.00,
        (SELECT id FROM categories WHERE slug = 'tratamientos-faciales'),
        TRUE,
        TRUE
    ),
    (
        'Hidratación Facial Intensiva',
        'hidratacion-facial-intensiva',
        'Tratamiento de hidratación profunda con ácido hialurónico y vitaminas. Aporta luminosidad, suavidad y elasticidad a la piel. Incluye mascarilla y masaje facial relajante.',
        'Hidratación profunda con ácido hialurónico',
        50,
        14500.00,
        (SELECT id FROM categories WHERE slug = 'tratamientos-faciales'),
        TRUE,
        TRUE
    ),
    (
        'Drenaje Linfático Corporal',
        'drenaje-linfatico-corporal',
        'Masaje especializado que estimula el sistema linfático para eliminar toxinas, reducir retención de líquidos y mejorar la circulación. Ideal para piernas cansadas y celulitis.',
        'Masaje para eliminar toxinas y reducir retención',
        75,
        16000.00,
        (SELECT id FROM categories WHERE slug = 'tratamientos-corporales'),
        FALSE,
        TRUE
    );

-- =====================================================
-- PRODUCTOS DE EJEMPLO
-- =====================================================

INSERT INTO products (name, slug, description, short_description, price, stock, category_id, is_featured, is_offer, is_trending, is_active) VALUES
    (
        'Serum Vitamina C - 30ml',
        'serum-vitamina-c-30ml',
        'Serum concentrado con vitamina C pura que aporta luminosidad, reduce manchas y protege contra el daño ambiental. Fórmula ligera de rápida absorción. Apto para todo tipo de piel.',
        'Ilumina y reduce manchas con vitamina C pura',
        8500.00,
        25,
        (SELECT id FROM categories WHERE slug = 'cuidado-facial'),
        TRUE,
        FALSE,
        TRUE,
        TRUE
    ),
    (
        'Crema Hidratante Ácido Hialurónico - 50ml',
        'crema-hidratante-acido-hialuronico-50ml',
        'Crema facial con triple acción: hidrata, rellena y suaviza. Contiene ácido hialurónico de diferentes pesos moleculares para una hidratación profunda y duradera.',
        'Hidratación profunda con ácido hialurónico',
        9800.00,
        30,
        (SELECT id FROM categories WHERE slug = 'cuidado-facial'),
        TRUE,
        FALSE,
        TRUE,
        TRUE
    ),
    (
        'Protector Solar FPS 50+ - 50ml',
        'protector-solar-fps-50-50ml',
        'Protección solar de amplio espectro UVA/UVB. Fórmula oil-free, no comedogénica. Resistente al agua. Textura ligera que no deja residuo blanco. Ideal para uso diario.',
        'Protección solar FPS 50+ sin residuo blanco',
        7200.00,
        40,
        (SELECT id FROM categories WHERE slug = 'cuidado-facial'),
        TRUE,
        TRUE,
        FALSE,
        TRUE
    ),
    (
        'Exfoliante Corporal Enzimático - 200ml',
        'exfoliante-corporal-enzimatico-200ml',
        'Exfoliante suave con enzimas de papaya y partículas de bambú. Elimina células muertas sin agredir la piel. Deja la piel suave, renovada y preparada para absorber tratamientos.',
        'Exfoliación suave con enzimas naturales',
        6500.00,
        20,
        (SELECT id FROM categories WHERE slug = 'cuidado-corporal'),
        FALSE,
        FALSE,
        TRUE,
        TRUE
    ),
    (
        'Aceite Corporal Nutritivo - 100ml',
        'aceite-corporal-nutritivo-100ml',
        'Blend de aceites naturales (rosa mosqueta, jojoba, vitamina E) que nutre profundamente la piel. Mejora la elasticidad y previene estrías. Ideal para masajes.',
        'Nutrición profunda con aceites naturales',
        8900.00,
        15,
        (SELECT id FROM categories WHERE slug = 'cuidado-corporal'),
        FALSE,
        TRUE,
        FALSE,
        TRUE
    );

-- =====================================================
-- CONFIGURACIÓN DEL SITIO
-- =====================================================

INSERT INTO app_config (config_key, config_value, description) VALUES
    -- Información del sitio
    ('site.name', 'Flavia Dermobeauty', 'Nombre del sitio web'),
    ('site.tagline', 'Belleza y Salud Dermatológica', 'Eslogan del sitio'),

    -- Contacto
    ('contact.email', 'contacto@flaviadermobeauty.com', 'Email de contacto'),
    ('contact.whatsapp', '+54 9 11 1234-5678', 'Número de WhatsApp'),
    ('contact.address', 'Av. Santa Fe 1234, CABA, Argentina', 'Dirección física del consultorio'),
    ('contact.phone', '+54 11 4567-8901', 'Teléfono fijo'),

    -- Costos
    ('delivery.fixed_cost', '1500.00', 'Costo fijo de envío a domicilio en ARS'),

    -- Textos del sitio (Hero)
    ('hero.title', 'Belleza que cuida tu piel', 'Título principal del hero'),
    ('hero.subtitle', 'Tratamientos dermatológicos profesionales y productos de alta calidad para realzar tu belleza natural', 'Subtítulo del hero'),
    ('hero.cta_text', 'Conocé nuestros tratamientos', 'Texto del botón CTA del hero'),

    -- Bio de Flavia
    ('bio.title', '¿Quién es Flavia?', 'Título de la sección bio'),
    ('bio.text', 'Soy Flavia, profesional en dermocosmiatría con más de 10 años de experiencia en el cuidado de la piel. Mi objetivo es ayudarte a sentirte bien con vos misma, brindándote tratamientos personalizados y productos de la más alta calidad. En mi consultorio, cada cliente es único y recibe atención especializada según sus necesidades.', 'Biografía de Flavia'),
    ('bio.credentials', 'Dermocosmiatrista matriculada • Especialista en tratamientos faciales • Certificada en peelings químicos', 'Credenciales profesionales'),

    -- Redes sociales
    ('social.instagram', 'https://instagram.com/flaviadermobeauty', 'URL de Instagram'),
    ('social.facebook', 'https://facebook.com/flaviadermobeauty', 'URL de Facebook'),
    ('social.tiktok', '', 'URL de TikTok (opcional)'),

    -- Horarios
    ('schedule.info', 'Lunes a Viernes: 9:00 - 19:00hs | Sábados: 9:00 - 13:00hs', 'Información de horarios de atención'),

    -- Políticas
    ('policy.cancellation', 'Las cancelaciones deben realizarse con al menos 24hs de anticipación. Caso contrario se cobrará el 50% del servicio.', 'Política de cancelación'),
    ('policy.returns', 'Aceptamos devoluciones de productos sin abrir dentro de los 15 días de la compra.', 'Política de devoluciones');

-- =====================================================
-- FIN DE DATOS INICIALES
-- =====================================================


