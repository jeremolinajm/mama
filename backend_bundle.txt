========== FILE: ./backend_debug_bundle.txt ==========

========== FILE: src/main/java/com/flavia/dermobeauty/payment/controller/MercadoPagoWebhookController.java ==========
package com.flavia.dermobeauty.payment.controller;

import com.flavia.dermobeauty.booking.application.usecase.ConfirmBookingPaymentUseCase;
import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.domain.BookingRepository;
import com.flavia.dermobeauty.sales.application.usecase.ConfirmOrderPaymentUseCase;
import com.flavia.dermobeauty.sales.domain.Order;
import com.flavia.dermobeauty.sales.domain.OrderRepository;
import com.mercadopago.client.payment.PaymentClient;
import com.mercadopago.exceptions.MPApiException;
import com.mercadopago.exceptions.MPException;
import com.mercadopago.resources.payment.Payment;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

/**
 * Controller for Mercado Pago webhook notifications.
 * Handles payment status updates from Mercado Pago.
 *
 * CRITICAL: This endpoint must be publicly accessible (no authentication).
 * Mercado Pago sends IPN notifications here when payment status changes.
 */
@Slf4j
@RestController
@RequestMapping("/api/mp")
@RequiredArgsConstructor
public class MercadoPagoWebhookController {

    private final BookingRepository bookingRepository;
    private final OrderRepository orderRepository;
    private final ConfirmBookingPaymentUseCase confirmBookingPaymentUseCase;
    private final ConfirmOrderPaymentUseCase confirmOrderPaymentUseCase;
    private final PaymentClient paymentClient = new PaymentClient();

    @PostMapping("/webhook")
    public ResponseEntity<Void> handleWebhook(@RequestBody Map<String, Object> payload) {
        try {
            log.info("Received MP webhook: {}", payload);

            String type = (String) payload.get("type");

            if (!"payment".equals(type)) {
                log.debug("Ignoring non-payment notification: {}", type);
                return ResponseEntity.ok().build();
            }

            Map<String, Object> data = (Map<String, Object>) payload.get("data");
            if (data == null) {
                log.warn("Webhook data is null");
                return ResponseEntity.ok().build();
            }

            String paymentIdStr = (String) data.get("id");
            if (paymentIdStr == null) {
                log.warn("Payment ID is null in webhook data");
                return ResponseEntity.ok().build();
            }

            Long paymentId = Long.parseLong(paymentIdStr);
            log.info("Processing payment notification for payment ID: {}", paymentId);

            // Fetch payment details from Mercado Pago
            Payment payment = paymentClient.get(paymentId);
            log.info("Payment status: {}, External reference: {}",
                    payment.getStatus(), payment.getExternalReference());

            // Only process approved payments
            if (!"approved".equals(payment.getStatus())) {
                log.info("Payment {} not approved yet (status: {}), skipping confirmation",
                        paymentId, payment.getStatus());
                return ResponseEntity.ok().build();
            }

            String externalReference = payment.getExternalReference();
            if (externalReference == null) {
                log.warn("External reference is null for payment {}", paymentId);
                return ResponseEntity.ok().build();
            }

            // Update payment ID in booking/order and confirm
            if (externalReference.startsWith("BOOKING-")) {
                confirmBookingPayment(externalReference, String.valueOf(paymentId));
            } else if (externalReference.startsWith("ORDER-")) {
                confirmOrderPayment(externalReference, String.valueOf(paymentId));
            } else {
                log.warn("Unknown external reference format: {}", externalReference);
            }

            return ResponseEntity.ok().build();

        } catch (MPApiException e) {
            log.error("MP API error processing webhook: {} - {}", e.getStatusCode(), e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.OK).build(); // Always return 200 to MP
        } catch (MPException e) {
            log.error("MP error processing webhook: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.OK).build();
        } catch (Exception e) {
            log.error("Unexpected error processing webhook", e);
            return ResponseEntity.status(HttpStatus.OK).build(); // Always return 200 to MP
        }
    }

    private void confirmBookingPayment(String externalReference, String paymentId) {
        try {
            String bookingNumber = externalReference.replace("BOOKING-", "");
            log.info("Confirming payment for booking: {}", bookingNumber);

            // Find booking and update payment ID first
            Booking booking = bookingRepository.findByBookingNumber(bookingNumber)
                    .orElseThrow(() -> new RuntimeException("Booking not found: " + bookingNumber));

            // Update booking with payment ID
            Booking updatedBooking = Booking.builder()
                    .id(booking.getId())
                    .bookingNumber(booking.getBookingNumber())
                    .serviceId(booking.getServiceId())
                    .customerInfo(booking.getCustomerInfo())
                    .timeSlot(booking.getTimeSlot())
                    .durationMinutes(booking.getDurationMinutes())
                    .status(booking.getStatus())
                    .paymentStatus(booking.getPaymentStatus())
                    .mercadoPagoPreferenceId(booking.getMercadoPagoPreferenceId())
                    .mercadoPagoPaymentId(paymentId)
                    .amount(booking.getAmount())
                    .createdAt(booking.getCreatedAt())
                    .updatedAt(booking.getUpdatedAt())
                    .confirmedAt(booking.getConfirmedAt())
                    .cancelledAt(booking.getCancelledAt())
                    .build();

            bookingRepository.save(updatedBooking);

            // Confirm payment via use case
            confirmBookingPaymentUseCase.execute(paymentId);
            log.info("Booking payment confirmed successfully: {}", bookingNumber);

        } catch (Exception e) {
            log.error("Error confirming booking payment", e);
            throw new RuntimeException("Error confirming booking payment", e);
        }
    }

    private void confirmOrderPayment(String externalReference, String paymentId) {
        try {
            String orderNumber = externalReference.replace("ORDER-", "");
            log.info("Confirming payment for order: {}", orderNumber);

            // Find order and update payment ID first
            Order order = orderRepository.findByOrderNumber(orderNumber)
                    .orElseThrow(() -> new RuntimeException("Order not found: " + orderNumber));

            // Update order with payment ID
            Order updatedOrder = Order.builder()
                    .id(order.getId())
                    .orderNumber(order.getOrderNumber())
                    .customerInfo(order.getCustomerInfo())
                    .deliveryInfo(order.getDeliveryInfo())
                    .items(order.getItems())
                    .subtotal(order.getSubtotal())
                    .deliveryCost(order.getDeliveryCost())
                    .total(order.getTotal())
                    .status(order.getStatus())
                    .paymentStatus(order.getPaymentStatus())
                    .mercadoPagoPreferenceId(order.getMercadoPagoPreferenceId())
                    .mercadoPagoPaymentId(paymentId)
                    .createdAt(order.getCreatedAt())
                    .updatedAt(order.getUpdatedAt())
                    .build();

            orderRepository.save(updatedOrder);

            // Confirm payment via use case (decrements stock, sends email)
            confirmOrderPaymentUseCase.execute(paymentId);
            log.info("Order payment confirmed successfully: {}", orderNumber);

        } catch (Exception e) {
            log.error("Error confirming order payment", e);
            throw new RuntimeException("Error confirming order payment", e);
        }
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/payment/controller/PaymentController.java ==========
package com.flavia.dermobeauty.payment.controller;

import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.domain.BookingRepository;
import com.flavia.dermobeauty.payment.dto.PaymentPreferenceResponse;
import com.flavia.dermobeauty.payment.service.MercadoPagoClient;
import com.flavia.dermobeauty.sales.domain.Order;
import com.flavia.dermobeauty.sales.domain.OrderRepository;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

/**
 * Controller for payment preference creation.
 * Public endpoints to initiate payment for bookings and orders.
 */
@Slf4j
@RestController
@RequestMapping("/api/public/payments")
@RequiredArgsConstructor
public class PaymentController {

    private final MercadoPagoClient mercadoPagoClient;
    private final BookingRepository bookingRepository;
    private final OrderRepository orderRepository;

    @PostMapping("/bookings/{bookingId}/preference")
    public ResponseEntity<ApiResponse<PaymentPreferenceResponse>> createBookingPreference(
            @PathVariable Long bookingId) {

        log.info("Creating payment preference for booking: {}", bookingId);

        Booking booking = bookingRepository.findById(bookingId)
                .orElseThrow(() -> new ResourceNotFoundException("Booking", bookingId));

        String preferenceId = mercadoPagoClient.createPreferenceForBooking(booking);

        // Update booking with preference ID
        Booking updatedBooking = Booking.builder()
                .id(booking.getId())
                .bookingNumber(booking.getBookingNumber())
                .serviceId(booking.getServiceId())
                .customerInfo(booking.getCustomerInfo())
                .timeSlot(booking.getTimeSlot())
                .durationMinutes(booking.getDurationMinutes())
                .status(booking.getStatus())
                .paymentStatus(booking.getPaymentStatus())
                .mercadoPagoPreferenceId(preferenceId)
                .mercadoPagoPaymentId(booking.getMercadoPagoPaymentId())
                .amount(booking.getAmount())
                .createdAt(booking.getCreatedAt())
                .updatedAt(booking.getUpdatedAt())
                .confirmedAt(booking.getConfirmedAt())
                .cancelledAt(booking.getCancelledAt())
                .build();

        bookingRepository.save(updatedBooking);

        PaymentPreferenceResponse response = new PaymentPreferenceResponse(
                preferenceId,
                "https://www.mercadopago.com.ar/checkout/v1/redirect?pref_id=" + preferenceId
        );

        return ResponseEntity.ok(ApiResponse.success(response, "Payment preference created"));
    }

    @PostMapping("/orders/{orderId}/preference")
    public ResponseEntity<ApiResponse<PaymentPreferenceResponse>> createOrderPreference(
            @PathVariable Long orderId) {

        log.info("Creating payment preference for order: {}", orderId);

        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new ResourceNotFoundException("Order", orderId));

        String preferenceId = mercadoPagoClient.createPreferenceForOrder(order);

        // Update order with preference ID
        Order updatedOrder = Order.builder()
                .id(order.getId())
                .orderNumber(order.getOrderNumber())
                .customerInfo(order.getCustomerInfo())
                .deliveryInfo(order.getDeliveryInfo())
                .items(order.getItems())
                .subtotal(order.getSubtotal())
                .deliveryCost(order.getDeliveryCost())
                .total(order.getTotal())
                .status(order.getStatus())
                .paymentStatus(order.getPaymentStatus())
                .mercadoPagoPreferenceId(preferenceId)
                .mercadoPagoPaymentId(order.getMercadoPagoPaymentId())
                .createdAt(order.getCreatedAt())
                .updatedAt(order.getUpdatedAt())
                .build();

        orderRepository.save(updatedOrder);

        PaymentPreferenceResponse response = new PaymentPreferenceResponse(
                preferenceId,
                "https://www.mercadopago.com.ar/checkout/v1/redirect?pref_id=" + preferenceId
        );

        return ResponseEntity.ok(ApiResponse.success(response, "Payment preference created"));
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/catalog/dto/CategoryDto.java ==========
package com.flavia.dermobeauty.catalog.dto;

import com.flavia.dermobeauty.catalog.entity.CategoryEntity;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO for category data transfer.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CategoryDto {

    private Long id;
    private String name;
    private String slug;
    private String description;
    private CategoryEntity.CategoryType type;

    public static CategoryDto fromEntity(CategoryEntity entity) {
        return CategoryDto.builder()
                .id(entity.getId())
                .name(entity.getName())
                .slug(entity.getSlug())
                .description(entity.getDescription())
                .type(entity.getType())
                .build();
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/catalog/dto/ServiceDto.java ==========
package com.flavia.dermobeauty.catalog.dto;

import com.flavia.dermobeauty.catalog.entity.ServiceEntity;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

/**
 * DTO for service data transfer with validation.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ServiceDto {

    private Long id;

    @NotBlank(message = "Name is required")
    private String name;

    private String slug;

    @NotBlank(message = "Description is required")
    private String description;

    private String shortDescription;

    @NotNull(message = "Duration is required")
    @Min(value = 1, message = "Duration must be at least 1 minute")
    private Integer durationMinutes;

    @NotNull(message = "Price is required")
    @DecimalMin(value = "0.0", inclusive = false, message = "Price must be greater than 0")
    private BigDecimal price;

    @NotNull(message = "Category ID is required")
    private Long categoryId;

    private String categoryName;

    private String imageUrl;

    private Boolean isFeatured;

    private Boolean isActive;

    public static ServiceDto fromEntity(ServiceEntity entity) {
        return ServiceDto.builder()
                .id(entity.getId())
                .name(entity.getName())
                .slug(entity.getSlug())
                .description(entity.getDescription())
                .shortDescription(entity.getShortDescription())
                .durationMinutes(entity.getDurationMinutes())
                .price(entity.getPrice())
                .categoryId(entity.getCategory().getId())
                .categoryName(entity.getCategory().getName())
                .imageUrl(entity.getImageUrl())
                .isFeatured(entity.getIsFeatured())
                .isActive(entity.getIsActive())
                .build();
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/catalog/dto/ProductDto.java ==========
package com.flavia.dermobeauty.catalog.dto;

import com.flavia.dermobeauty.catalog.entity.ProductEntity;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

/**
 * DTO for product data transfer with validation.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProductDto {

    private Long id;

    @NotBlank(message = "Name is required")
    private String name;

    private String slug;

    @NotBlank(message = "Description is required")
    private String description;

    private String shortDescription;

    @NotNull(message = "Price is required")
    @DecimalMin(value = "0.0", inclusive = false, message = "Price must be greater than 0")
    private BigDecimal price;

    @NotNull(message = "Stock is required")
    @Min(value = 0, message = "Stock cannot be negative")
    private Integer stock;

    @NotNull(message = "Category ID is required")
    private Long categoryId;

    private String categoryName;

    private String imageUrl;

    private Boolean isFeatured;

    private Boolean isOffer;

    private Boolean isTrending;

    private Boolean isActive;

    public static ProductDto fromEntity(ProductEntity entity) {
        return ProductDto.builder()
                .id(entity.getId())
                .name(entity.getName())
                .slug(entity.getSlug())
                .description(entity.getDescription())
                .shortDescription(entity.getShortDescription())
                .price(entity.getPrice())
                .stock(entity.getStock())
                .categoryId(entity.getCategory().getId())
                .categoryName(entity.getCategory().getName())
                .imageUrl(entity.getImageUrl())
                .isFeatured(entity.getIsFeatured())
                .isOffer(entity.getIsOffer())
                .isTrending(entity.getIsTrending())
                .isActive(entity.getIsActive())
                .build();
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/catalog/repository/ProductRepository.java ==========
package com.flavia.dermobeauty.catalog.repository;

import com.flavia.dermobeauty.catalog.entity.ProductEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

/**
 * Repository for product operations with custom queries for filtering.
 */
@Repository
public interface ProductRepository extends JpaRepository<ProductEntity, Long> {

    Optional<ProductEntity> findBySlug(String slug);

    List<ProductEntity> findByIsActiveTrueOrderByCreatedAtDesc();

    List<ProductEntity> findByIsFeaturedTrueAndIsActiveTrueOrderByCreatedAtDesc();

    List<ProductEntity> findByIsOfferTrueAndIsActiveTrueOrderByCreatedAtDesc();

    List<ProductEntity> findByIsTrendingTrueAndIsActiveTrueOrderByCreatedAtDesc();

    @Query("SELECT p FROM ProductEntity p WHERE p.category.id = :categoryId AND p.isActive = true ORDER BY p.createdAt DESC")
    List<ProductEntity> findByCategoryIdAndIsActiveTrue(@Param("categoryId") Long categoryId);

    @Modifying(clearAutomatically = true)
    @Query("UPDATE ProductEntity p SET p.stock = p.stock - :quantity WHERE p.id = :id AND p.stock >= :quantity")
    int decrementStock(@Param("id") Long id, @Param("quantity") Integer quantity);

}

========== FILE: src/main/java/com/flavia/dermobeauty/catalog/repository/ServiceRepository.java ==========
package com.flavia.dermobeauty.catalog.repository;

import com.flavia.dermobeauty.catalog.entity.ServiceEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

/**
 * Repository for service operations with custom queries for filtering.
 */
@Repository
public interface ServiceRepository extends JpaRepository<ServiceEntity, Long> {

    Optional<ServiceEntity> findBySlug(String slug);

    List<ServiceEntity> findByIsActiveTrueOrderByCreatedAtDesc();

    List<ServiceEntity> findByIsFeaturedTrueAndIsActiveTrueOrderByCreatedAtDesc();

    @Query("SELECT s FROM ServiceEntity s WHERE s.category.id = :categoryId AND s.isActive = true ORDER BY s.createdAt DESC")
    List<ServiceEntity> findByCategoryIdAndIsActiveTrue(@Param("categoryId") Long categoryId);
}

========== FILE: src/main/java/com/flavia/dermobeauty/catalog/repository/CategoryRepository.java ==========
package com.flavia.dermobeauty.catalog.repository;

import com.flavia.dermobeauty.catalog.entity.CategoryEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

/**
 * Repository for category operations.
 */
@Repository
public interface CategoryRepository extends JpaRepository<CategoryEntity, Long> {

    Optional<CategoryEntity> findBySlug(String slug);

    List<CategoryEntity> findByType(CategoryEntity.CategoryType type);
}

========== FILE: src/main/java/com/flavia/dermobeauty/catalog/entity/CategoryEntity.java ==========
package com.flavia.dermobeauty.catalog.entity;

import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDateTime;

/**
 * JPA entity for categories table.
 * Categories are used to organize both services and products.
 */
@Entity
@Table(name = "categories")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CategoryEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(nullable = false, unique = true, length = 100)
    private String slug;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private CategoryType type;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }

    public enum CategoryType {
        SERVICE, PRODUCT
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/catalog/entity/ProductEntity.java ==========
package com.flavia.dermobeauty.catalog.entity;

import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * JPA entity for products table.
 * Represents beauty/dermatology products for sale.
 */
@Entity
@Table(name = "products")
@Getter@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProductEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 200)
    private String name;

    @Column(nullable = false, unique = true, length = 200)
    private String slug;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Column(name = "short_description", length = 500)
    private String shortDescription;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal price;

    @Column(nullable = false)
    private Integer stock = 0;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id", nullable = false)
    @ToString.Exclude
    private CategoryEntity category;

    @Column(name = "image_url", length = 500)
    private String imageUrl;

    @Column(name = "is_featured", nullable = false)
    private Boolean isFeatured = false;

    @Column(name = "is_offer", nullable = false)
    private Boolean isOffer = false;

    @Column(name = "is_trending", nullable = false)
    private Boolean isTrending = false;

    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/catalog/entity/ServiceEntity.java ==========
package com.flavia.dermobeauty.catalog.entity;

import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * JPA entity for services table.
 * Represents professional services offered (e.g., facial treatments, peels).
 */
@Entity
@Table(name = "services")
@Getter@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ServiceEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 200)
    private String name;

    @Column(nullable = false, unique = true, length = 200)
    private String slug;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Column(name = "short_description", length = 500)
    private String shortDescription;

    @Column(name = "duration_minutes", nullable = false)
    private Integer durationMinutes;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal price;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id", nullable = false)
    @ToString.Exclude
    private CategoryEntity category;

    @Column(name = "image_url", length = 500)
    private String imageUrl;

    @Column(name = "is_featured", nullable = false)
    private Boolean isFeatured = false;

    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/catalog/service/ProductCatalogService.java ==========
package com.flavia.dermobeauty.catalog.service;

import com.flavia.dermobeauty.catalog.dto.ProductDto;
import com.flavia.dermobeauty.catalog.entity.CategoryEntity;
import com.flavia.dermobeauty.catalog.entity.ProductEntity;
import com.flavia.dermobeauty.catalog.repository.CategoryRepository;
import com.flavia.dermobeauty.catalog.repository.ProductRepository;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Service for managing product catalog operations.
 * Provides CRUD operations for beauty/dermatology products.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class ProductCatalogService {

    private final ProductRepository productRepository;
    private final CategoryRepository categoryRepository;

    @Transactional(readOnly = true)
    public List<ProductDto> getAllActive() {
        log.debug("Fetching all active products");
        return productRepository.findByIsActiveTrueOrderByCreatedAtDesc()
                .stream()
                .map(ProductDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<ProductDto> getAllForAdmin() {
        log.debug("Fetching all products for admin");
        // Usamos findAll() estándar de JPA para traer todo
        return productRepository.findAll()
                .stream()
                .map(ProductDto::fromEntity)
                // Ordenamos por ID o fecha para que no salten en la tabla
                .sorted((a, b) -> b.getId().compareTo(a.getId()))
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<ProductDto> getFeatured() {
        log.debug("Fetching featured products");
        return productRepository.findByIsFeaturedTrueAndIsActiveTrueOrderByCreatedAtDesc()
                .stream()
                .map(ProductDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<ProductDto> getOffers() {
        log.debug("Fetching products on offer");
        return productRepository.findByIsOfferTrueAndIsActiveTrueOrderByCreatedAtDesc()
                .stream()
                .map(ProductDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<ProductDto> getTrending() {
        log.debug("Fetching trending products");
        return productRepository.findByIsTrendingTrueAndIsActiveTrueOrderByCreatedAtDesc()
                .stream()
                .map(ProductDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public ProductDto getById(Long id) {
        log.debug("Fetching product by id: {}", id);
        ProductEntity entity = productRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Product", id));
        return ProductDto.fromEntity(entity);
    }

    @Transactional(readOnly = true)
    public ProductDto getBySlug(String slug) {
        log.debug("Fetching product by slug: {}", slug);
        ProductEntity entity = productRepository.findBySlug(slug)
                .orElseThrow(() -> new ResourceNotFoundException("Product with slug '" + slug + "' not found"));
        return ProductDto.fromEntity(entity);
    }

    @Transactional(readOnly = true)
    public List<ProductDto> getByCategory(Long categoryId) {
        log.debug("Fetching products by category: {}", categoryId);
        return productRepository.findByCategoryIdAndIsActiveTrue(categoryId)
                .stream()
                .map(ProductDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional
    public ProductDto create(ProductDto dto) {
        log.info("Creating new product: {}", dto.getName());

        CategoryEntity category = categoryRepository.findById(dto.getCategoryId())
                .orElseThrow(() -> new ResourceNotFoundException("Category", dto.getCategoryId()));

        ProductEntity entity = ProductEntity.builder()
                .name(dto.getName())
                .slug(generateSlug(dto.getName()))
                .description(dto.getDescription())
                .shortDescription(dto.getShortDescription())
                .price(dto.getPrice())
                .stock(dto.getStock() != null ? dto.getStock() : 0)
                .category(category)
                .imageUrl(dto.getImageUrl())
                .isFeatured(dto.getIsFeatured() != null ? dto.getIsFeatured() : false)
                .isOffer(dto.getIsOffer() != null ? dto.getIsOffer() : false)
                .isTrending(dto.getIsTrending() != null ? dto.getIsTrending() : false)
                .isActive(dto.getIsActive() != null ? dto.getIsActive() : true)
                .build();

        ProductEntity saved = productRepository.save(entity);
        return ProductDto.fromEntity(saved);
    }

    @Transactional
    public ProductDto update(Long id, ProductDto dto) {
        log.info("Updating product: {}", id);

        ProductEntity entity = productRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Product", id));

        if (dto.getCategoryId() != null && !dto.getCategoryId().equals(entity.getCategory().getId())) {
            CategoryEntity category = categoryRepository.findById(dto.getCategoryId())
                    .orElseThrow(() -> new ResourceNotFoundException("Category", dto.getCategoryId()));
            entity.setCategory(category);
        }

        entity.setName(dto.getName());
        entity.setDescription(dto.getDescription());
        entity.setShortDescription(dto.getShortDescription());
        entity.setPrice(dto.getPrice());
        entity.setStock(dto.getStock());
        entity.setImageUrl(dto.getImageUrl());
        entity.setIsFeatured(dto.getIsFeatured());
        entity.setIsOffer(dto.getIsOffer());
        entity.setIsTrending(dto.getIsTrending());
        entity.setIsActive(dto.getIsActive());

        ProductEntity updated = productRepository.save(entity);
        return ProductDto.fromEntity(updated);
    }

    @Transactional
    public void delete(Long id) {
        log.info("Deleting product: {}", id);
        if (!productRepository.existsById(id)) {
            throw new ResourceNotFoundException("Product", id);
        }
        productRepository.deleteById(id);
    }

    private String generateSlug(String name) {
        return name.toLowerCase()
                .replaceAll("[^a-z0-9\\s-]", "")
                .replaceAll("\\s+", "-")
                .replaceAll("-+", "-");
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/catalog/service/ServiceCatalogService.java ==========
package com.flavia.dermobeauty.catalog.service;

import com.flavia.dermobeauty.catalog.dto.ServiceDto;
import com.flavia.dermobeauty.catalog.entity.CategoryEntity;
import com.flavia.dermobeauty.catalog.entity.ServiceEntity;
import com.flavia.dermobeauty.catalog.repository.CategoryRepository;
import com.flavia.dermobeauty.catalog.repository.ServiceRepository;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Service for managing service catalog operations.
 * Provides CRUD operations for beauty/dermatology services.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class ServiceCatalogService {

    private final ServiceRepository serviceRepository;
    private final CategoryRepository categoryRepository;

    @Transactional(readOnly = true)
    public List<ServiceDto> getAllActive() {
        log.debug("Fetching all active services");
        return serviceRepository.findByIsActiveTrueOrderByCreatedAtDesc()
                .stream()
                .map(ServiceDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<ServiceDto> getAllForAdmin() {
        log.debug("Fetching all services for admin");
        return serviceRepository.findAll()
                .stream()
                .map(ServiceDto::fromEntity)
                .sorted((a, b) -> b.getId().compareTo(a.getId()))
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<ServiceDto> getFeatured() {
        log.debug("Fetching featured services");
        return serviceRepository.findByIsFeaturedTrueAndIsActiveTrueOrderByCreatedAtDesc()
                .stream()
                .map(ServiceDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public ServiceDto getById(Long id) {
        log.debug("Fetching service by id: {}", id);
        ServiceEntity entity = serviceRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Service", id));
        return ServiceDto.fromEntity(entity);
    }

    @Transactional(readOnly = true)
    public ServiceDto getBySlug(String slug) {
        log.debug("Fetching service by slug: {}", slug);
        ServiceEntity entity = serviceRepository.findBySlug(slug)
                .orElseThrow(() -> new ResourceNotFoundException("Service with slug '" + slug + "' not found"));
        return ServiceDto.fromEntity(entity);
    }

    @Transactional(readOnly = true)
    public List<ServiceDto> getByCategory(Long categoryId) {
        log.debug("Fetching services by category: {}", categoryId);
        return serviceRepository.findByCategoryIdAndIsActiveTrue(categoryId)
                .stream()
                .map(ServiceDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional
    public ServiceDto create(ServiceDto dto) {
        log.info("Creating new service: {}", dto.getName());

        CategoryEntity category = categoryRepository.findById(dto.getCategoryId())
                .orElseThrow(() -> new ResourceNotFoundException("Category", dto.getCategoryId()));

        ServiceEntity entity = ServiceEntity.builder()
                .name(dto.getName())
                .slug(generateSlug(dto.getName()))
                .description(dto.getDescription())
                .shortDescription(dto.getShortDescription())
                .durationMinutes(dto.getDurationMinutes())
                .price(dto.getPrice())
                .category(category)
                .imageUrl(dto.getImageUrl())
                .isFeatured(dto.getIsFeatured() != null ? dto.getIsFeatured() : false)
                .isActive(dto.getIsActive() != null ? dto.getIsActive() : true)
                .build();

        ServiceEntity saved = serviceRepository.save(entity);
        return ServiceDto.fromEntity(saved);
    }

    @Transactional
    public ServiceDto update(Long id, ServiceDto dto) {
        log.info("Updating service: {}", id);

        ServiceEntity entity = serviceRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Service", id));

        if (dto.getCategoryId() != null && !dto.getCategoryId().equals(entity.getCategory().getId())) {
            CategoryEntity category = categoryRepository.findById(dto.getCategoryId())
                    .orElseThrow(() -> new ResourceNotFoundException("Category", dto.getCategoryId()));
            entity.setCategory(category);
        }

        entity.setName(dto.getName());
        entity.setDescription(dto.getDescription());
        entity.setShortDescription(dto.getShortDescription());
        entity.setDurationMinutes(dto.getDurationMinutes());
        entity.setPrice(dto.getPrice());
        entity.setImageUrl(dto.getImageUrl());
        entity.setIsFeatured(dto.getIsFeatured());
        entity.setIsActive(dto.getIsActive());

        ServiceEntity updated = serviceRepository.save(entity);
        return ServiceDto.fromEntity(updated);
    }

    @Transactional
    public void delete(Long id) {
        log.info("Deleting service: {}", id);
        if (!serviceRepository.existsById(id)) {
            throw new ResourceNotFoundException("Service", id);
        }
        serviceRepository.deleteById(id);
    }

    private String generateSlug(String name) {
        return name.toLowerCase()
                .replaceAll("[^a-z0-9\\s-]", "")
                .replaceAll("\\s+", "-")
                .replaceAll("-+", "-");
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/catalog/controller/ProductController.java ==========
package com.flavia.dermobeauty.catalog.controller;

import com.flavia.dermobeauty.catalog.dto.ProductDto;
import com.flavia.dermobeauty.catalog.service.ProductCatalogService;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * Public REST controller for product catalog operations.
 * Provides endpoints for browsing available products.
 */
@RestController
@RequestMapping("/api/public/products")
@RequiredArgsConstructor
public class ProductController {

    private final ProductCatalogService productCatalogService;

    @GetMapping
    public ResponseEntity<ApiResponse<List<ProductDto>>> getAllProducts() {
        List<ProductDto> products = productCatalogService.getAllActive();
        return ResponseEntity.ok(ApiResponse.success(products));
    }

    @GetMapping("/featured")
    public ResponseEntity<ApiResponse<List<ProductDto>>> getFeaturedProducts() {
        List<ProductDto> products = productCatalogService.getFeatured();
        return ResponseEntity.ok(ApiResponse.success(products));
    }

    @GetMapping("/offers")
    public ResponseEntity<ApiResponse<List<ProductDto>>> getOfferProducts() {
        List<ProductDto> products = productCatalogService.getOffers();
        return ResponseEntity.ok(ApiResponse.success(products));
    }

    @GetMapping("/trending")
    public ResponseEntity<ApiResponse<List<ProductDto>>> getTrendingProducts() {
        List<ProductDto> products = productCatalogService.getTrending();
        return ResponseEntity.ok(ApiResponse.success(products));
    }

    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<ProductDto>> getProductById(@PathVariable Long id) {
        ProductDto product = productCatalogService.getById(id);
        return ResponseEntity.ok(ApiResponse.success(product));
    }

    @GetMapping("/slug/{slug}")
    public ResponseEntity<ApiResponse<ProductDto>> getProductBySlug(@PathVariable String slug) {
        ProductDto product = productCatalogService.getBySlug(slug);
        return ResponseEntity.ok(ApiResponse.success(product));
    }

    @GetMapping("/category/{categoryId}")
    public ResponseEntity<ApiResponse<List<ProductDto>>> getProductsByCategory(@PathVariable Long categoryId) {
        List<ProductDto> products = productCatalogService.getByCategory(categoryId);
        return ResponseEntity.ok(ApiResponse.success(products));
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/catalog/controller/AdminCatalogController.java ==========
package com.flavia.dermobeauty.catalog.controller;

import com.flavia.dermobeauty.catalog.dto.CategoryDto;
import com.flavia.dermobeauty.catalog.dto.ProductDto;
import com.flavia.dermobeauty.catalog.dto.ServiceDto;
import com.flavia.dermobeauty.catalog.entity.CategoryEntity;
import com.flavia.dermobeauty.catalog.repository.CategoryRepository;
import com.flavia.dermobeauty.catalog.service.ProductCatalogService;
import com.flavia.dermobeauty.catalog.service.ServiceCatalogService;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

@Slf4j
@RestController
@RequestMapping("/api/admin")
@RequiredArgsConstructor
public class AdminCatalogController {

    private final ServiceCatalogService serviceService;
    private final ProductCatalogService productService;
    private final CategoryRepository categoryRepository;

    // ==================== SERVICES ====================

    @GetMapping("/services")
    public ResponseEntity<ApiResponse<List<ServiceDto>>> getAllServices() {
        return ResponseEntity.ok(ApiResponse.success(serviceService.getAllForAdmin()));
    }

    @GetMapping("/services/{id}")
    public ResponseEntity<ApiResponse<ServiceDto>> getService(@PathVariable Long id) {
        return ResponseEntity.ok(ApiResponse.success(serviceService.getById(id)));
    }

    @PostMapping("/services")
    public ResponseEntity<ApiResponse<ServiceDto>> createService(@Valid @RequestBody ServiceDto dto) {
        return ResponseEntity.ok(ApiResponse.success(serviceService.create(dto), "Servicio creado"));
    }

    @PutMapping("/services/{id}")
    public ResponseEntity<ApiResponse<ServiceDto>> updateService(@PathVariable Long id, @Valid @RequestBody ServiceDto dto) {
        return ResponseEntity.ok(ApiResponse.success(serviceService.update(id, dto), "Servicio actualizado"));
    }

    @DeleteMapping("/services/{id}")
    public ResponseEntity<ApiResponse<Void>> deleteService(@PathVariable Long id) {
        serviceService.delete(id);
        return ResponseEntity.ok(ApiResponse.success("Servicio eliminado"));
    }

    @PatchMapping("/services/{id}/featured")
    public ResponseEntity<ApiResponse<ServiceDto>> toggleServiceFeatured(@PathVariable Long id) {
        // Obtenemos actual, invertimos flag y guardamos
        ServiceDto current = serviceService.getById(id);
        current.setIsFeatured(!current.getIsFeatured());
        return ResponseEntity.ok(ApiResponse.success(serviceService.update(id, current)));
    }

    // ==================== PRODUCTS ====================

    @GetMapping("/products")
    public ResponseEntity<ApiResponse<List<ProductDto>>> getAllProducts() {
        return ResponseEntity.ok(ApiResponse.success(productService.getAllForAdmin()));
    }

    @GetMapping("/products/{id}")
    public ResponseEntity<ApiResponse<ProductDto>> getProduct(@PathVariable Long id) {
        return ResponseEntity.ok(ApiResponse.success(productService.getById(id)));
    }

    @PostMapping("/products")
    public ResponseEntity<ApiResponse<ProductDto>> createProduct(@Valid @RequestBody ProductDto dto) {
        return ResponseEntity.ok(ApiResponse.success(productService.create(dto), "Producto creado"));
    }

    @PutMapping("/products/{id}")
    public ResponseEntity<ApiResponse<ProductDto>> updateProduct(@PathVariable Long id, @Valid @RequestBody ProductDto dto) {
        return ResponseEntity.ok(ApiResponse.success(productService.update(id, dto), "Producto actualizado"));
    }

    @DeleteMapping("/products/{id}")
    public ResponseEntity<ApiResponse<Void>> deleteProduct(@PathVariable Long id) {
        productService.delete(id);
        return ResponseEntity.ok(ApiResponse.success("Producto eliminado"));
    }

    @PatchMapping("/products/{id}/featured")
    public ResponseEntity<ApiResponse<ProductDto>> toggleProductFeatured(@PathVariable Long id) {
        ProductDto current = productService.getById(id);
        current.setIsFeatured(!current.getIsFeatured());
        return ResponseEntity.ok(ApiResponse.success(productService.update(id, current)));
    }

    // ==================== CATEGORIES ====================

    @GetMapping("/categories")
    public ResponseEntity<ApiResponse<List<CategoryDto>>> getAllCategories() {
        List<CategoryDto> categories = categoryRepository.findAll().stream()
                .map(CategoryDto::fromEntity)
                .collect(Collectors.toList());
        return ResponseEntity.ok(ApiResponse.success(categories));
    }

    @PostMapping("/categories")
    public ResponseEntity<ApiResponse<CategoryDto>> createCategory(@RequestBody CategoryEntity category) {
        // Simplificación: Guardamos directo la entidad (mejorar con DTO/Service en futuro)
        // Generar slug simple
        category.setSlug(category.getName().toLowerCase().replace(" ", "-"));
        CategoryEntity saved = categoryRepository.save(category);
        return ResponseEntity.ok(ApiResponse.success(CategoryDto.fromEntity(saved)));
    }

    @DeleteMapping("/categories/{id}")
    public ResponseEntity<ApiResponse<Void>> deleteCategory(@PathVariable Long id) {
        categoryRepository.deleteById(id);
        return ResponseEntity.ok(ApiResponse.success("Categoría eliminada"));
    }
}
========== FILE: src/main/java/com/flavia/dermobeauty/catalog/controller/CategoryController.java ==========
package com.flavia.dermobeauty.catalog.controller;

import com.flavia.dermobeauty.catalog.dto.CategoryDto;
import com.flavia.dermobeauty.catalog.entity.CategoryEntity;
import com.flavia.dermobeauty.catalog.repository.CategoryRepository;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Public REST controller for category operations.
 * Provides endpoints for browsing categories.
 */
@RestController
@RequestMapping("/api/public/categories")
@RequiredArgsConstructor
public class CategoryController {

    private final CategoryRepository categoryRepository;

    @GetMapping
    public ResponseEntity<ApiResponse<List<CategoryDto>>> getAllCategories() {
        List<CategoryDto> categories = categoryRepository.findAll()
                .stream()
                .map(CategoryDto::fromEntity)
                .collect(Collectors.toList());
        return ResponseEntity.ok(ApiResponse.success(categories));
    }

    @GetMapping("/type/{type}")
    public ResponseEntity<ApiResponse<List<CategoryDto>>> getCategoriesByType(@PathVariable CategoryEntity.CategoryType type) {
        List<CategoryDto> categories = categoryRepository.findByType(type)
                .stream()
                .map(CategoryDto::fromEntity)
                .collect(Collectors.toList());
        return ResponseEntity.ok(ApiResponse.success(categories));
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/catalog/controller/FileUploadController.java ==========
package com.flavia.dermobeauty.catalog.controller;

import com.flavia.dermobeauty.shared.exception.ValidationException;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.net.MalformedURLException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;

/**
 * Controller for file upload and retrieval.
 * Handles image uploads for services and products.
 */
@Slf4j
@RestController
@RequestMapping("/api")
public class FileUploadController {

    private static final List<String> ALLOWED_CONTENT_TYPES = Arrays.asList(
            "image/jpeg", "image/jpg", "image/png", "image/webp"
    );
    private static final long MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB

    private final Path uploadPath;

    public FileUploadController(@Value("${app.upload-dir}") String uploadDir) {
        this.uploadPath = Paths.get(uploadDir).toAbsolutePath().normalize();
        try {
            Files.createDirectories(this.uploadPath);
            log.info("Upload directory created at: {}", this.uploadPath);
        } catch (IOException e) {
            throw new RuntimeException("Could not create upload directory", e);
        }
    }

    @PostMapping("/admin/uploads")
    public ResponseEntity<ApiResponse<String>> uploadFile(@RequestParam("file") MultipartFile file) {
        validateFile(file);

        try {
            String originalFilename = file.getOriginalFilename();
            String extension = originalFilename != null && originalFilename.contains(".")
                    ? originalFilename.substring(originalFilename.lastIndexOf("."))
                    : ".jpg";

            String filename = UUID.randomUUID().toString() + extension;
            Path targetLocation = uploadPath.resolve(filename);

            Files.copy(file.getInputStream(), targetLocation, StandardCopyOption.REPLACE_EXISTING);
            log.info("File uploaded successfully: {}", filename);

            String fileUrl = "/api/uploads/" + filename;
            return ResponseEntity.ok(ApiResponse.success(fileUrl, "File uploaded successfully"));

        } catch (IOException e) {
            log.error("Failed to upload file", e);
            throw new ValidationException("Failed to upload file: " + e.getMessage());
        }
    }

    @GetMapping("/uploads/{filename:.+}")
    public ResponseEntity<Resource> getFile(@PathVariable String filename) {
        try {
            Path filePath = uploadPath.resolve(filename).normalize();
            Resource resource = new UrlResource(filePath.toUri());

            if (!resource.exists() || !resource.isReadable()) {
                throw new ValidationException("File not found: " + filename);
            }

            String contentType = Files.probeContentType(filePath);
            if (contentType == null) {
                contentType = "application/octet-stream";
            }

            return ResponseEntity.ok()
                    .contentType(MediaType.parseMediaType(contentType))
                    .header(HttpHeaders.CONTENT_DISPOSITION, "inline; filename=\"" + resource.getFilename() + "\"")
                    .body(resource);

        } catch (MalformedURLException e) {
            log.error("Invalid file path: {}", filename, e);
            throw new ValidationException("Invalid file path");
        } catch (IOException e) {
            log.error("Error reading file: {}", filename, e);
            throw new ValidationException("Error reading file");
        }
    }

    private void validateFile(MultipartFile file) {
        if (file.isEmpty()) {
            throw new ValidationException("File is empty");
        }

        if (file.getSize() > MAX_FILE_SIZE) {
            throw new ValidationException("File size exceeds maximum allowed (5MB)");
        }

        String contentType = file.getContentType();
        if (contentType == null || !ALLOWED_CONTENT_TYPES.contains(contentType)) {
            throw new ValidationException("Invalid file type. Allowed types: JPEG, PNG, WebP");
        }
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/catalog/controller/ServiceController.java ==========
package com.flavia.dermobeauty.catalog.controller;

import com.flavia.dermobeauty.catalog.dto.ServiceDto;
import com.flavia.dermobeauty.catalog.service.ServiceCatalogService;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * Public REST controller for service catalog operations.
 * Provides endpoints for browsing available services.
 */
@RestController
@RequestMapping("/api/public/services")
@RequiredArgsConstructor
public class ServiceController {

    private final ServiceCatalogService serviceCatalogService;

    @GetMapping
    public ResponseEntity<ApiResponse<List<ServiceDto>>> getAllServices() {
        List<ServiceDto> services = serviceCatalogService.getAllActive();
        return ResponseEntity.ok(ApiResponse.success(services));
    }

    @GetMapping("/featured")
    public ResponseEntity<ApiResponse<List<ServiceDto>>> getFeaturedServices() {
        List<ServiceDto> services = serviceCatalogService.getFeatured();
        return ResponseEntity.ok(ApiResponse.success(services));
    }

    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<ServiceDto>> getServiceById(@PathVariable Long id) {
        ServiceDto service = serviceCatalogService.getById(id);
        return ResponseEntity.ok(ApiResponse.success(service));
    }

    @GetMapping("/slug/{slug}")
    public ResponseEntity<ApiResponse<ServiceDto>> getServiceBySlug(@PathVariable String slug) {
        ServiceDto service = serviceCatalogService.getBySlug(slug);
        return ResponseEntity.ok(ApiResponse.success(service));
    }

    @GetMapping("/category/{categoryId}")
    public ResponseEntity<ApiResponse<List<ServiceDto>>> getServicesByCategory(@PathVariable Long categoryId) {
        List<ServiceDto> services = serviceCatalogService.getByCategory(categoryId);
        return ResponseEntity.ok(ApiResponse.success(services));
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/booking/infrastructure/persistence/JpaBookingRepository.java ==========
package com.flavia.dermobeauty.booking.infrastructure.persistence;

import com.flavia.dermobeauty.booking.domain.BookingStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.List;
import java.util.Optional;

/**
 * Spring Data JPA repository for BookingEntity.
 * Infrastructure implementation detail.
 */
@Repository
public interface JpaBookingRepository extends JpaRepository<BookingEntity, Long> {

    Optional<BookingEntity> findByBookingNumber(String bookingNumber);

    Optional<BookingEntity> findByMercadoPagoPaymentId(String paymentId);

    List<BookingEntity> findByStatus(BookingStatus status);

    List<BookingEntity> findByBookingDateAndStatusNot(LocalDate bookingDate, BookingStatus status);

    // Un turno se solapa si: (StartA < EndB) y (StartB < EndA)
    @Query(value = """
           SELECT CASE WHEN COUNT(*) > 0 THEN true ELSE false END
           FROM bookings b
           WHERE b.service_id = :serviceId
           AND b.booking_date = :date
           AND b.status != 'CANCELLED'
           AND (
               b.booking_time < :endTime
               AND :startTime < (b.booking_time + (b.duration_minutes * interval '1 minute'))
           )
           """, nativeQuery = true)
    boolean existsOverlappingBooking(
            @Param("serviceId") Long serviceId,
            @Param("date") LocalDate date,
            @Param("startTime") LocalTime startTime,
            @Param("endTime") LocalTime endTime
    );
}
========== FILE: src/main/java/com/flavia/dermobeauty/booking/infrastructure/persistence/BookingEntity.java ==========
package com.flavia.dermobeauty.booking.infrastructure.persistence;

import com.flavia.dermobeauty.booking.domain.BookingStatus;
import com.flavia.dermobeauty.booking.domain.PaymentStatus;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;

/**
 * JPA entity for bookings table.
 * Infrastructure layer representation of Booking aggregate.
 */
@Entity
@Table(name = "bookings")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class BookingEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "booking_number", nullable = false, unique = true, length = 50)
    private String bookingNumber;

    @Column(name = "service_id", nullable = false)
    private Long serviceId;

    // Customer information (embedded fields)
    @Column(name = "customer_name", nullable = false, length = 200)
    private String customerName;

    @Column(name = "customer_email", nullable = false, length = 200)
    private String customerEmail;

    @Column(name = "customer_whatsapp", nullable = false, length = 50)
    private String customerWhatsapp;

    @Column(name = "customer_comments", columnDefinition = "TEXT")
    private String customerComments;

    // Time slot (embedded fields)
    @Column(name = "booking_date", nullable = false)
    private LocalDate bookingDate;

    @Column(name = "booking_time", nullable = false)
    private LocalTime bookingTime;

    @Column(name = "duration_minutes", nullable = false)
    private Integer durationMinutes;

    // Status tracking
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private BookingStatus status;

    // Payment information
    @Enumerated(EnumType.STRING)
    @Column(name = "payment_status", nullable = false, length = 20)
    private PaymentStatus paymentStatus;

    @Column(name = "mercadopago_preference_id", length = 200)
    private String mercadoPagoPreferenceId;

    @Column(name = "mercadopago_payment_id", length = 200)
    private String mercadoPagoPaymentId;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal amount;

    // Timestamps
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @Column(name = "confirmed_at")
    private LocalDateTime confirmedAt;

    @Column(name = "cancelled_at")
    private LocalDateTime cancelledAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = LocalDateTime.now();
        }
        if (updatedAt == null) {
            updatedAt = LocalDateTime.now();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/booking/infrastructure/notification/StubNotificationService.java ==========
package com.flavia.dermobeauty.booking.infrastructure.notification;

import com.flavia.dermobeauty.booking.application.port.NotificationService;
import com.flavia.dermobeauty.booking.domain.Booking;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

/**
 * Stub implementation of NotificationService for Phase 5.
 * Will be replaced with full email implementation in Phase 8.
 */
@Slf4j
@Service
public class StubNotificationService implements NotificationService {

    @Override
    public void sendBookingConfirmation(Booking booking) {
        log.info("STUB: Would send booking confirmation email for {} to {}",
                booking.getBookingNumber(),
                booking.getCustomerInfo().getEmail());

        // No-op for now - will implement email sending in Phase 8
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/booking/config/BookingConfig.java ==========
package com.flavia.dermobeauty.booking.config;

import com.flavia.dermobeauty.booking.application.port.NotificationService;
import com.flavia.dermobeauty.booking.application.usecase.*;
import com.flavia.dermobeauty.booking.domain.BookingRepository;
import com.flavia.dermobeauty.catalog.repository.ServiceRepository;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * Configuration class for Booking module.
 * Wires use cases as Spring beans for dependency injection.
 */
@Configuration
public class BookingConfig {

    @Bean
    public CreateBookingUseCase createBookingUseCase(BookingRepository bookingRepository) {
        return new CreateBookingUseCase(bookingRepository);
    }

    @Bean
    public ConfirmBookingPaymentUseCase confirmBookingPaymentUseCase(
            BookingRepository bookingRepository,
            NotificationService notificationService) {
        return new ConfirmBookingPaymentUseCase(bookingRepository, notificationService);
    }

    @Bean
    public ListBookingsUseCase listBookingsUseCase(BookingRepository bookingRepository) {
        return new ListBookingsUseCase(bookingRepository);
    }

    @Bean
    public CancelBookingUseCase cancelBookingUseCase(BookingRepository bookingRepository) {
        return new CancelBookingUseCase(bookingRepository);
    }

    @Bean
    public GetBookingByNumberUseCase getBookingByNumberUseCase(BookingRepository bookingRepository) {
        return new GetBookingByNumberUseCase(bookingRepository);
    }

    @Bean
    public GetAvailableSlotsUseCase getAvailableSlotsUseCase(
            BookingRepository bookingRepository,
            ServiceRepository serviceRepository
    ) {
        return new GetAvailableSlotsUseCase(bookingRepository, serviceRepository);
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/booking/domain/BookingRepository.java ==========
package com.flavia.dermobeauty.booking.domain;

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.List;
import java.util.Optional;

/**
 * Repository port (interface) for Booking aggregate.
 * Defines operations needed by the domain layer without specifying implementation.
 * Implementation will be provided by infrastructure layer.
 */
public interface BookingRepository {

    /**
     * Save a booking (create or update).
     */
    Booking save(Booking booking);

    /**
     * Find booking by ID.
     */
    Optional<Booking> findById(Long id);

    /**
     * Find booking by booking number.
     */
    Optional<Booking> findByBookingNumber(String bookingNumber);

    /**
     * Find booking by Mercado Pago payment ID.
     */
    Optional<Booking> findByMercadoPagoPaymentId(String paymentId);

    /**
     * Check if a slot is already booked for a service.
     * Returns true if there's an active (non-cancelled) booking for this slot.
     */
    boolean isTimeSlotAvailable(Long serviceId, LocalDate date, LocalTime startTime, LocalTime endTime);

    /**
     * Find all bookings (for admin).
     */
    List<Booking> findAll();

    /**
     * Find bookings by status (for admin filtering).
     */
    List<Booking> findByStatus(BookingStatus status);

    List<Booking> findByDate(LocalDate date);

}

========== FILE: src/main/java/com/flavia/dermobeauty/booking/web/BookingController.java ==========
package com.flavia.dermobeauty.booking.web;

import com.flavia.dermobeauty.booking.application.usecase.CreateBookingUseCase;
import com.flavia.dermobeauty.booking.application.usecase.GetBookingByNumberUseCase;
import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.web.dto.BookingResponse;
import com.flavia.dermobeauty.booking.web.dto.CreateBookingRequest;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

/**
 * REST controller for booking operations.
 * Public endpoints for customers to create and check bookings.
 */
@Slf4j
@RestController
@RequestMapping("/api/public/bookings")
@RequiredArgsConstructor
public class BookingController {

    private final CreateBookingUseCase createBookingUseCase;
    private final GetBookingByNumberUseCase getBookingByNumberUseCase;

    @PostMapping
    public ResponseEntity<ApiResponse<BookingResponse>> createBooking(
            @Valid @RequestBody CreateBookingRequest request) {

        log.info("Creating booking for service {} on {} at {}",
                request.getServiceId(), request.getBookingDate(), request.getBookingTime());

        Booking booking = createBookingUseCase.execute(
                request.getServiceId(),
                request.getCustomerName(),
                request.getCustomerEmail(),
                request.getCustomerWhatsapp(),
                request.getCustomerComments(),
                request.getBookingDate(),
                request.getBookingTime(),
                request.getDurationMinutes(),
                request.getAmount()
        );

        BookingResponse response = BookingResponse.fromDomain(booking);
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.success(response, "Booking created successfully"));
    }

    @GetMapping("/{bookingNumber}")
    public ResponseEntity<ApiResponse<BookingResponse>> getBookingByNumber(
            @PathVariable String bookingNumber) {

        log.debug("Fetching booking: {}", bookingNumber);

        Booking booking = getBookingByNumberUseCase.execute(bookingNumber);
        BookingResponse response = BookingResponse.fromDomain(booking);

        return ResponseEntity.ok(ApiResponse.success(response));
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/booking/web/AvailabilityController.java ==========
package com.flavia.dermobeauty.booking.web;

import com.flavia.dermobeauty.booking.application.usecase.GetAvailableSlotsUseCase;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.List;

@RestController
@RequestMapping("/api/public/availability")
@RequiredArgsConstructor
public class AvailabilityController {

    private final GetAvailableSlotsUseCase getAvailableSlotsUseCase;

    @GetMapping
    public ResponseEntity<ApiResponse<List<LocalTime>>> getAvailability(
            @RequestParam Long serviceId,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate date) {

        List<LocalTime> slots = getAvailableSlotsUseCase.execute(serviceId, date);
        return ResponseEntity.ok(ApiResponse.success(slots));
    }
}
========== FILE: src/main/java/com/flavia/dermobeauty/booking/application/port/NotificationService.java ==========
package com.flavia.dermobeauty.booking.application.port;

import com.flavia.dermobeauty.booking.domain.Booking;

/**
 * Port (interface) for notification operations.
 * Will be implemented by the notification module infrastructure.
 */
public interface NotificationService {

    /**
     * Send booking confirmation email to customer.
     *
     * @param booking The confirmed booking
     */
    void sendBookingConfirmation(Booking booking);
}

========== FILE: src/main/java/com/flavia/dermobeauty/booking/application/port/PaymentService.java ==========
package com.flavia.dermobeauty.booking.application.port;

import com.flavia.dermobeauty.booking.domain.Booking;

/**
 * Port (interface) for payment operations.
 * Will be implemented by the payment module infrastructure.
 */
public interface PaymentService {

    /**
     * Create a Mercado Pago payment preference for a booking.
     *
     * @param booking The booking to create payment for
     * @return Preference ID
     */
    String createBookingPreference(Booking booking);
}

========== FILE: src/main/java/com/flavia/dermobeauty/security/config/SecurityConfig.java ==========
package com.flavia.dermobeauty.security.config;

import com.flavia.dermobeauty.security.jwt.JwtAuthenticationFilter;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.List;

/**
 * Spring Security configuration for the application.
 * Configures CORS, JWT authentication, and endpoint authorization.
 */
@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .cors(cors -> cors.configurationSource(corsConfigurationSource()))
                .csrf(csrf -> csrf.disable())
                .sessionManagement(session ->
                        session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .authorizeHttpRequests(auth -> auth
                        // Public endpoints
                        .requestMatchers("/api/public/**").permitAll()
                        .requestMatchers("/api/mp/webhook").permitAll()
                        .requestMatchers("/api/auth/login").permitAll()
                        .requestMatchers("/api/uploads/**").permitAll()
                        .requestMatchers("/api/test/**").permitAll() // TODO: Remove in production!
                        // Admin endpoints
                        .requestMatchers("/api/admin/**").hasRole("ADMIN")
                        // All other requests require authentication
                        .anyRequest().authenticated()
                )
                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(List.of("http://localhost:5173", "https://flaviadermobeauty.com","https://api.flaviadermobeauty.com"));
        configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(List.of("*"));
        configuration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/security/controller/AuthController.java ==========
package com.flavia.dermobeauty.security.controller;

import com.flavia.dermobeauty.security.dto.LoginRequest;
import com.flavia.dermobeauty.security.dto.LoginResponse;
import com.flavia.dermobeauty.security.jwt.JwtTokenProvider;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * Authentication controller for admin login.
 * Validates hardcoded credentials and returns JWT token.
 */
@Slf4j
@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
public class AuthController {

    private final JwtTokenProvider jwtTokenProvider;
    private final PasswordEncoder passwordEncoder;

    @Value("${admin.username}")
    private String adminUsername;

    @Value("${admin.password}")
    private String adminPasswordHash;

    @PostMapping("/login")
    public ResponseEntity<ApiResponse<LoginResponse>> login(@Valid @RequestBody LoginRequest request) {
        log.info("Login attempt for user: {}", request.getUsername());

        if (!adminUsername.equals(request.getUsername())) {
            log.warn("Login failed: Invalid username");
            return ResponseEntity.status(401)
                    .body(ApiResponse.success(null, "Invalid credentials"));
        }

        if (!passwordEncoder.matches(request.getPassword(), adminPasswordHash)) {
            log.warn("Login failed: Invalid password");
            return ResponseEntity.status(401)
                    .body(ApiResponse.success(null, "Invalid credentials"));
        }

        String token = jwtTokenProvider.generateToken(adminUsername);
        LoginResponse response = new LoginResponse(token, adminUsername, "ADMIN");

        log.info("Login successful for user: {}", adminUsername);
        return ResponseEntity.ok(ApiResponse.success(response));
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/config/repository/ConfigRepository.java ==========
package com.flavia.dermobeauty.config.repository;

import com.flavia.dermobeauty.config.domain.ConfigEntry;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.Optional;

public interface ConfigRepository extends JpaRepository<ConfigEntry, Long> {
    Optional<ConfigEntry> findByKey(String key);
}
========== FILE: src/main/java/com/flavia/dermobeauty/config/web/AdminConfigController.java ==========
package com.flavia.dermobeauty.config.web;

import com.flavia.dermobeauty.config.domain.ConfigEntry;
import com.flavia.dermobeauty.config.repository.ConfigRepository;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/admin/config")
@RequiredArgsConstructor
public class AdminConfigController {

    private final ConfigRepository configRepository;

    @GetMapping
    public ResponseEntity<ApiResponse<List<ConfigEntry>>> getAllConfig() {
        return ResponseEntity.ok(ApiResponse.success(configRepository.findAll()));
    }

    @PutMapping("/{key}")
    public ResponseEntity<ApiResponse<ConfigEntry>> updateConfig(
            @PathVariable String key,
            @RequestBody UpdateConfigRequest request) {

        ConfigEntry config = configRepository.findByKey(key)
                .orElse(ConfigEntry.builder().key(key).build());

        config.setValue(request.getValue());
        // Descripción opcional, solo si es nuevo
        if (config.getDescription() == null) {
            config.setDescription("Configuración dinámica");
        }

        return ResponseEntity.ok(ApiResponse.success(configRepository.save(config)));
    }

    @Data
    public static class UpdateConfigRequest {
        private String value;
    }
}
========== FILE: src/main/java/com/flavia/dermobeauty/shared/web/GlobalExceptionHandler.java ==========
package com.flavia.dermobeauty.shared.web;

import com.flavia.dermobeauty.shared.exception.DomainException;
import com.flavia.dermobeauty.shared.exception.PaymentException;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import com.flavia.dermobeauty.shared.exception.ValidationException;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.HashMap;
import java.util.Map;

/**
 * Global exception handler for all REST controllers.
 * Provides consistent error responses across the application.
 */
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleResourceNotFound(
            ResourceNotFoundException ex,
            HttpServletRequest request) {

        log.warn("Resource not found: {}", ex.getMessage());

        ErrorResponse error = new ErrorResponse(
                "NOT_FOUND",
                ex.getMessage(),
                request.getRequestURI()
        );

        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }

    @ExceptionHandler(ValidationException.class)
    public ResponseEntity<ErrorResponse> handleValidation(
            ValidationException ex,
            HttpServletRequest request) {

        log.warn("Validation error: {}", ex.getMessage());

        ErrorResponse error = new ErrorResponse(
                "VALIDATION_ERROR",
                ex.getMessage(),
                request.getRequestURI()
        );

        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleMethodArgumentNotValid(
            MethodArgumentNotValidException ex,
            HttpServletRequest request) {

        Map<String, String> fieldErrors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach(error -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            fieldErrors.put(fieldName, errorMessage);
        });

        log.warn("Bean validation failed: {}", fieldErrors);

        ErrorResponse error = new ErrorResponse(
                "VALIDATION_ERROR",
                "Invalid request data",
                request.getRequestURI(),
                fieldErrors
        );

        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }

    @ExceptionHandler(PaymentException.class)
    public ResponseEntity<ErrorResponse> handlePayment(
            PaymentException ex,
            HttpServletRequest request) {

        log.error("Payment processing error: {}", ex.getMessage(), ex);

        ErrorResponse error = new ErrorResponse(
                "PAYMENT_ERROR",
                ex.getMessage(),
                request.getRequestURI()
        );

        return ResponseEntity.status(HttpStatus.BAD_GATEWAY).body(error);
    }

    @ExceptionHandler(DomainException.class)
    public ResponseEntity<ErrorResponse> handleDomain(
            DomainException ex,
            HttpServletRequest request) {

        log.warn("Domain exception: {}", ex.getMessage());

        ErrorResponse error = new ErrorResponse(
                "BUSINESS_RULE_VIOLATION",
                ex.getMessage(),
                request.getRequestURI()
        );

        return ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY).body(error);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneral(
            Exception ex,
            HttpServletRequest request) {

        log.error("Unexpected error", ex);

        ErrorResponse error = new ErrorResponse(
                "INTERNAL_ERROR",
                "An unexpected error occurred. Please try again later.",
                request.getRequestURI()
        );

        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/sales/infrastructure/persistence/OrderEntity.java ==========
package com.flavia.dermobeauty.sales.infrastructure.persistence;

import com.flavia.dermobeauty.booking.domain.PaymentStatus;
import com.flavia.dermobeauty.sales.domain.DeliveryType;
import com.flavia.dermobeauty.sales.domain.OrderStatus;
import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

/**
 * JPA entity for orders table.
 * Infrastructure layer representation of Order aggregate.
 */
@Entity
@Table(name = "orders")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class OrderEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "order_number", nullable = false, unique = true, length = 50)
    private String orderNumber;

    // Customer information
    @Column(name = "customer_name", nullable = false, length = 200)
    private String customerName;

    @Column(name = "customer_email", nullable = false, length = 200)
    private String customerEmail;

    @Column(name = "customer_whatsapp", nullable = false, length = 50)
    private String customerWhatsapp;

    // Delivery information
    @Enumerated(EnumType.STRING)
    @Column(name = "delivery_type", nullable = false, length = 20)
    private DeliveryType deliveryType;

    @Column(name = "delivery_address_street", length = 300)
    private String deliveryAddress;

    @Column(name = "delivery_address_city", length = 100)
    private String deliveryCity;

    @Column(name = "delivery_address_postal_code", length = 20)
    private String deliveryPostalCode;

    @Column(name = "delivery_address_state", length = 100)
    private String deliveryProvince;

    @Column(name = "delivery_notes", columnDefinition = "TEXT")
    private String deliveryNotes;

    // Order items (OneToMany relationship)
    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true)
    @Builder.Default
    @ToString.Exclude
    private List<OrderItemEntity> items = new ArrayList<>();

    // Pricing
    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal subtotal;

    @Column(name = "delivery_cost", nullable = false, precision = 10, scale = 2)
    private BigDecimal deliveryCost;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal total;

    // Status tracking
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private OrderStatus status;

    // Payment information
    @Enumerated(EnumType.STRING)
    @Column(name = "payment_status", nullable = false, length = 20)
    private PaymentStatus paymentStatus;

    @Column(name = "mercadopago_preference_id", length = 200)
    private String mercadoPagoPreferenceId;

    @Column(name = "mercadopago_payment_id", length = 200)
    private String mercadoPagoPaymentId;

    // Timestamps
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = LocalDateTime.now();
        }
        if (updatedAt == null) {
            updatedAt = LocalDateTime.now();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }

    /**
     * Helper method to add item and maintain bidirectional relationship.
     */
    public void addItem(OrderItemEntity item) {
        items.add(item);
        item.setOrder(this);
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/sales/infrastructure/persistence/OrderItemEntity.java ==========
package com.flavia.dermobeauty.sales.infrastructure.persistence;

import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * JPA entity for order_items table.
 * Part of Order aggregate in infrastructure layer.
 */
@Entity
@Table(name = "order_items")
@Getter@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class OrderItemEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id", nullable = false)
    @ToString.Exclude
    private OrderEntity order;

    @Column(name = "product_id", nullable = false)
    private Long productId;

    // Snapshot of product at time of order
    @Column(name = "product_name", nullable = false, length = 200)
    private String productName;

    @Column(name = "product_price", nullable = false, precision = 10, scale = 2)
    private BigDecimal productPrice;

    @Column(nullable = false)
    private Integer quantity;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal subtotal;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = LocalDateTime.now();
        }
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/sales/infrastructure/persistence/JpaOrderRepository.java ==========
package com.flavia.dermobeauty.sales.infrastructure.persistence;

import com.flavia.dermobeauty.sales.domain.OrderStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

/**
 * Spring Data JPA repository for OrderEntity.
 * Infrastructure implementation detail.
 */
@Repository
public interface JpaOrderRepository extends JpaRepository<OrderEntity, Long> {

    Optional<OrderEntity> findByOrderNumber(String orderNumber);

    Optional<OrderEntity> findByMercadoPagoPaymentId(String paymentId);

    List<OrderEntity> findByStatus(OrderStatus status);
}

========== FILE: src/main/java/com/flavia/dermobeauty/sales/infrastructure/notification/StubOrderNotificationService.java ==========
package com.flavia.dermobeauty.sales.infrastructure.notification;

import com.flavia.dermobeauty.sales.application.port.NotificationService;
import com.flavia.dermobeauty.sales.domain.Order;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

/**
 * Stub implementation of NotificationService for Phase 6.
 * Will be replaced with full email implementation in Phase 8.
 */
@Slf4j
@Service("orderNotificationService")
public class StubOrderNotificationService implements NotificationService {

    @Override
    public void sendOrderConfirmation(Order order) {
        log.info("STUB: Would send order confirmation email for {} to {}",
                order.getOrderNumber(),
                order.getCustomerInfo().getEmail());

        // No-op for now - will implement email sending in Phase 8
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/sales/config/SalesConfig.java ==========
package com.flavia.dermobeauty.sales.config;

import com.flavia.dermobeauty.catalog.repository.ProductRepository;
import com.flavia.dermobeauty.sales.application.port.DeliveryCostCalculator;
import com.flavia.dermobeauty.sales.application.port.NotificationService;
import com.flavia.dermobeauty.sales.application.port.StockService;
import com.flavia.dermobeauty.sales.application.usecase.*;
import com.flavia.dermobeauty.sales.domain.OrderRepository;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * Configuration class for Sales module.
 * Wires use cases as Spring beans for dependency injection.
 */
@Configuration
public class SalesConfig {

    @Bean
    public CreateOrderUseCase createOrderUseCase(
            OrderRepository orderRepository,
            ProductRepository productRepository,
            StockService stockService,
            DeliveryCostCalculator deliveryCostCalculator) {
        return new CreateOrderUseCase(orderRepository, productRepository, stockService, deliveryCostCalculator);
    }

    @Bean
    public ConfirmOrderPaymentUseCase confirmOrderPaymentUseCase(
            OrderRepository orderRepository,
            StockService stockService,
            @Qualifier("orderNotificationService") NotificationService notificationService) {
        return new ConfirmOrderPaymentUseCase(orderRepository, stockService, notificationService);
    }

    @Bean
    public UpdateOrderStatusUseCase updateOrderStatusUseCase(OrderRepository orderRepository) {
        return new UpdateOrderStatusUseCase(orderRepository);
    }

    @Bean
    public ListOrdersUseCase listOrdersUseCase(OrderRepository orderRepository) {
        return new ListOrdersUseCase(orderRepository);
    }

    @Bean
    public GetOrderByNumberUseCase getOrderByNumberUseCase(OrderRepository orderRepository) {
        return new GetOrderByNumberUseCase(orderRepository);
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/sales/domain/OrderRepository.java ==========
package com.flavia.dermobeauty.sales.domain;

import java.util.List;
import java.util.Optional;

/**
 * Repository port (interface) for Order aggregate.
 * Defines operations needed by the domain layer without specifying implementation.
 * Implementation will be provided by infrastructure layer.
 */
public interface OrderRepository {

    /**
     * Save an order (create or update).
     */
    Order save(Order order);

    /**
     * Find order by ID.
     */
    Optional<Order> findById(Long id);

    /**
     * Find order by order number.
     */
    Optional<Order> findByOrderNumber(String orderNumber);

    /**
     * Find order by Mercado Pago payment ID.
     */
    Optional<Order> findByMercadoPagoPaymentId(String paymentId);

    /**
     * Find all orders (for admin).
     */
    List<Order> findAll();

    /**
     * Find orders by status (for admin filtering).
     */
    List<Order> findByStatus(OrderStatus status);
}

========== FILE: src/main/java/com/flavia/dermobeauty/sales/web/OrderController.java ==========
package com.flavia.dermobeauty.sales.web;

import com.flavia.dermobeauty.sales.application.usecase.CreateOrderUseCase;
import com.flavia.dermobeauty.sales.application.usecase.GetOrderByNumberUseCase;
import com.flavia.dermobeauty.sales.domain.Order;
import com.flavia.dermobeauty.sales.web.dto.CreateOrderRequest;
import com.flavia.dermobeauty.sales.web.dto.OrderItemRequest;
import com.flavia.dermobeauty.sales.web.dto.OrderResponse;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

/**
 * REST controller for order operations.
 * Public endpoints for customers to create and check orders.
 */
@Slf4j
@RestController
@RequestMapping("/api/public/orders")
@RequiredArgsConstructor
public class OrderController {

    private final CreateOrderUseCase createOrderUseCase;
    private final GetOrderByNumberUseCase getOrderByNumberUseCase;

    @PostMapping
    public ResponseEntity<ApiResponse<OrderResponse>> createOrder(
            @Valid @RequestBody CreateOrderRequest request) {

        log.info("Creating order for customer: {}", request.getCustomerEmail());

        List<CreateOrderUseCase.OrderItemRequest> itemRequests = request.getItems().stream()
                .map(item -> new CreateOrderUseCase.OrderItemRequest(item.getProductId(), item.getQuantity()))
                .collect(Collectors.toList());

        Order order = createOrderUseCase.execute(
                request.getCustomerName(),
                request.getCustomerEmail(),
                request.getCustomerWhatsapp(),
                request.getDeliveryType(),
                request.getDeliveryAddress(),
                request.getDeliveryCity(),
                request.getDeliveryPostalCode(),
                request.getDeliveryProvince(),
                request.getDeliveryNotes(),
                itemRequests
        );

        OrderResponse response = OrderResponse.fromDomain(order);
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.success(response, "Order created successfully"));
    }

    @GetMapping("/{orderNumber}")
    public ResponseEntity<ApiResponse<OrderResponse>> getOrderByNumber(
            @PathVariable String orderNumber) {

        log.debug("Fetching order: {}", orderNumber);

        Order order = getOrderByNumberUseCase.execute(orderNumber);
        OrderResponse response = OrderResponse.fromDomain(order);

        return ResponseEntity.ok(ApiResponse.success(response));
    }
}

========== FILE: src/main/java/com/flavia/dermobeauty/sales/web/AdminOperationsController.java ==========
package com.flavia.dermobeauty.sales.web;

import com.flavia.dermobeauty.booking.application.usecase.CancelBookingUseCase;
import com.flavia.dermobeauty.booking.application.usecase.ListBookingsUseCase;
import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.web.dto.BookingResponse;
import com.flavia.dermobeauty.sales.application.usecase.ListOrdersUseCase;
import com.flavia.dermobeauty.sales.application.usecase.UpdateOrderStatusUseCase;
import com.flavia.dermobeauty.sales.domain.Order;
import com.flavia.dermobeauty.sales.domain.OrderStatus;
import com.flavia.dermobeauty.sales.web.dto.OrderResponse;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/admin")
@RequiredArgsConstructor
public class AdminOperationsController {

    private final ListBookingsUseCase listBookingsUseCase;
    private final CancelBookingUseCase cancelBookingUseCase;
    private final ListOrdersUseCase listOrdersUseCase;
    private final UpdateOrderStatusUseCase updateOrderStatusUseCase;

    // ==================== BOOKINGS ====================

    @GetMapping("/bookings")
    public ResponseEntity<ApiResponse<List<BookingResponse>>> getBookings() {
        List<BookingResponse> bookings = listBookingsUseCase.execute().stream()
                .map(BookingResponse::fromDomain)
                .collect(Collectors.toList());
        return ResponseEntity.ok(ApiResponse.success(bookings));
    }

    @DeleteMapping("/bookings/{id}")
    public ResponseEntity<ApiResponse<Void>> cancelBooking(@PathVariable Long id) {
        cancelBookingUseCase.execute(id);
        return ResponseEntity.ok(ApiResponse.success("Turno cancelado"));
    }

    // ==================== ORDERS ====================

    @GetMapping("/orders")
    public ResponseEntity<ApiResponse<List<OrderResponse>>> getOrders() {
        List<OrderResponse> orders = listOrdersUseCase.execute().stream()
                .map(OrderResponse::fromDomain)
                .collect(Collectors.toList());
        return ResponseEntity.ok(ApiResponse.success(orders));
    }

    @PatchMapping("/orders/{id}/status")
    public ResponseEntity<ApiResponse<OrderResponse>> updateOrderStatus(
            @PathVariable Long id,
            @RequestBody UpdateStatusRequest request) {

        Order updated = updateOrderStatusUseCase.execute(id, request.getStatus());
        return ResponseEntity.ok(ApiResponse.success(OrderResponse.fromDomain(updated)));
    }

    @Data
    public static class UpdateStatusRequest {
        private OrderStatus status;
    }
}
========== FILE: src/main/java/com/flavia/dermobeauty/sales/application/port/StockService.java ==========
package com.flavia.dermobeauty.sales.application.port;

/**
 * Port (interface) for stock management operations.
 * Will be implemented by the catalog infrastructure.
 */
public interface StockService {

    /**
     * Check if sufficient stock is available for a product.
     *
     * @param productId Product ID
     * @param quantity  Requested quantity
     * @return true if stock available, false otherwise
     */
    boolean checkAvailability(Long productId, Integer quantity);

    /**
     * Decrement stock for a product.
     * Should be called after payment confirmation.
     *
     * @param productId Product ID
     * @param quantity  Quantity to decrement
     */
    void decrementStock(Long productId, Integer quantity);
}

========== FILE: src/main/java/com/flavia/dermobeauty/sales/application/port/NotificationService.java ==========
package com.flavia.dermobeauty.sales.application.port;

import com.flavia.dermobeauty.sales.domain.Order;

/**
 * Port (interface) for notification operations.
 * Will be implemented by the notification module infrastructure.
 */
public interface NotificationService {

    /**
     * Send order confirmation email to customer.
     *
     * @param order The confirmed order
     */
    void sendOrderConfirmation(Order order);
}

========== FILE: src/main/java/com/flavia/dermobeauty/sales/application/port/PaymentService.java ==========
package com.flavia.dermobeauty.sales.application.port;

import com.flavia.dermobeauty.sales.domain.Order;

/**
 * Port (interface) for payment operations.
 * Will be implemented by the payment module infrastructure.
 */
public interface PaymentService {

    /**
     * Create a Mercado Pago payment preference for an order.
     *
     * @param order The order to create payment for
     * @return Preference ID
     */
    String createOrderPreference(Order order);
}

========== FILE: src/main/resources/application-dev.yml ==========
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/dermobeauty_dev
    username: dermobeauty
    password: dermobeauty
    driver-class-name: org.postgresql.Driver
  jpa:
    show-sql: true
    properties:
      hibernate:
        format_sql: true
  mail:
    host: smtp.gmail.com
    port: 587
    username: 'flavia.dermobeauty@gmail.com'
    password: 'qajp ptwr gdjg uozl'
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true
            required: true
          connectiontimeout: 5000
          timeout: 5000
          writetimeout: 5000

# Admin credentials (change in production!)
admin:
  username: admin
  # BCrypt hash for "admin123" (verified)
  password: $2a$10$OQlalRpvK3/0ikEa3xO62ujds5OHSF723wIXh3gIk7ca7nJmp0c9q

# JWT configuration
jwt:
  secret: flavia-dermobeauty-jwt-secret-key-change-in-production-2024
  expiration: 86400000 # 24 hours in milliseconds

# Mercado Pago configuration
mercadopago:
  access-token: APP_USR-3480197543728175-092819-981988e8773a0af18511e1e610ba5f23-2719878562
  base-url: https://flaviadermobeauty.com

# Application settings
app:
  api-url: https://api.flaviadermobeauty.com
  upload-dir: ./uploads
  email:
    from: flavia.dermobeauty@gmail.com
    from-name: Flavia Dermobeauty
  delivery:
    fixed-cost: 1500.00

# Logging
logging:
  level:
    com.flavia.dermobeauty: DEBUG
    org.springframework.web: INFO
    org.hibernate.SQL: DEBUG

========== FILE: src/main/resources/application.yml ==========
spring:
  application:
    name: dermobeauty
  profiles:
    active: dev
  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: false
    open-in-view: false
  flyway:
    enabled: true
    baseline-on-migrate: true
  servlet:
    multipart:
      max-file-size: 5MB
      max-request-size: 10MB

server:
  port: 8080
  error:
    include-message: always
    include-binding-errors: always


========== FILE: ./Dockerfile ==========
# Multi-stage build for Spring Boot application
FROM maven:3.9-eclipse-temurin-21-alpine AS build

WORKDIR /app

# Copy pom.xml and download dependencies (layer caching)
COPY pom.xml .
RUN mvn dependency:go-offline -B

# Copy source code and build
COPY src ./src
RUN mvn clean package -DskipTests

# Runtime stage
FROM eclipse-temurin:21-jre-alpine

WORKDIR /app

# Create uploads directory
RUN mkdir -p /app/uploads

# Copy JAR from build stage
COPY --from=build /app/target/*.jar app.jar

# Expose port
EXPOSE 8080

# Run the application
ENTRYPOINT ["java", "-jar", "app.jar"]


========== FILE: ./.gitignore ==========
HELP.md
target/
!.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/

### Application ###
/uploads/
*.log


========== FILE: ./pom.xml ==========
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.3.5</version>
        <relativePath/>
    </parent>

    <groupId>com.flavia</groupId>
    <artifactId>dermobeauty</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <name>Flavia Dermobeauty</name>
    <description>Beauty and dermatology booking and e-commerce platform</description>

    <properties>
        <java.version>17</java.version>
        <mercadopago.version>2.1.28</mercadopago.version>
        <jjwt.version>0.12.6</jjwt.version>
    </properties>

    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>

        <!-- Database -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- Flyway -->
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-core</artifactId>
        </dependency>

        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-database-postgresql</artifactId>
        </dependency>

        <!-- Mercado Pago SDK -->
        <dependency>
            <groupId>com.mercadopago</groupId>
            <artifactId>sdk-java</artifactId>
            <version>${mercadopago.version}</version>
        </dependency>

        <!-- JWT -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>${jjwt.version}</version>
        </dependency>

        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>

        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>

        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- Testing -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/application/port/NotificationService.java ==========
package com.flavia.dermobeauty.booking.application.port;

import com.flavia.dermobeauty.booking.domain.Booking;

/**
 * Port (interface) for notification operations.
 * Will be implemented by the notification module infrastructure.
 */
public interface NotificationService {

    /**
     * Send booking confirmation email to customer.
     *
     * @param booking The confirmed booking
     */
    void sendBookingConfirmation(Booking booking);
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/application/port/PaymentService.java ==========
package com.flavia.dermobeauty.booking.application.port;

import com.flavia.dermobeauty.booking.domain.Booking;

/**
 * Port (interface) for payment operations.
 * Will be implemented by the payment module infrastructure.
 */
public interface PaymentService {

    /**
     * Create a Mercado Pago payment preference for a booking.
     *
     * @param booking The booking to create payment for
     * @return Preference ID
     */
    String createBookingPreference(Booking booking);
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/application/service/BookingHistoryService.java ==========
package com.flavia.dermobeauty.booking.application.service;

import com.flavia.dermobeauty.booking.domain.BookingHistory;
import com.flavia.dermobeauty.booking.domain.BookingHistoryRepository;
import com.flavia.dermobeauty.booking.domain.HistoryActor;
import com.flavia.dermobeauty.booking.domain.HistoryEventType;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.time.OffsetDateTime;
import java.util.List;
import java.util.Map;

/**
 * Service for recording booking history events.
 * Provides append-only audit trail for all booking changes.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class BookingHistoryService {

    private final BookingHistoryRepository historyRepository;

    /**
     * Records a CREATED event when a booking is created.
     */
    public void recordCreated(Long bookingId, String bookingNumber, HistoryActor actor) {
        Map<String, Object> payload = Map.of(
                "bookingNumber", bookingNumber,
                "action", "Turno creado"
        );
        record(bookingId, HistoryEventType.CREATED, payload, actor);
    }

    /**
     * Records a STATUS_CHANGED event.
     */
    public void recordStatusChanged(Long bookingId, String oldStatus, String newStatus, HistoryActor actor) {
        Map<String, Object> payload = Map.of(
                "oldStatus", oldStatus,
                "newStatus", newStatus
        );
        record(bookingId, HistoryEventType.STATUS_CHANGED, payload, actor);
    }

    /**
     * Records a RESCHEDULED event.
     */
    public void recordRescheduled(Long bookingId, OffsetDateTime oldStartAt, OffsetDateTime newStartAt, HistoryActor actor) {
        Map<String, Object> payload = Map.of(
                "oldStartAt", oldStartAt.toString(),
                "newStartAt", newStartAt.toString()
        );
        record(bookingId, HistoryEventType.RESCHEDULED, payload, actor);
    }

    /**
     * Records a CUSTOMER_UPDATED event.
     */
    public void recordCustomerUpdated(Long bookingId, Map<String, Object> changes, HistoryActor actor) {
        record(bookingId, HistoryEventType.CUSTOMER_UPDATED, changes, actor);
    }

    /**
     * Records a PAYMENT_UPDATED event.
     */
    public void recordPaymentUpdated(Long bookingId, String oldPaymentStatus, String newPaymentStatus,
                                     String paymentId, HistoryActor actor) {
        Map<String, Object> payload = Map.of(
                "oldPaymentStatus", oldPaymentStatus,
                "newPaymentStatus", newPaymentStatus,
                "paymentId", paymentId != null ? paymentId : ""
        );
        record(bookingId, HistoryEventType.PAYMENT_UPDATED, payload, actor);
    }

    /**
     * Gets all history entries for a booking, ordered by createdAt ascending.
     */
    public List<BookingHistory> getHistoryForBooking(Long bookingId) {
        return historyRepository.findByBookingIdOrderByCreatedAtAsc(bookingId);
    }

    private void record(Long bookingId, HistoryEventType eventType, Map<String, Object> payload, HistoryActor actor) {
        BookingHistory history = BookingHistory.create(bookingId, eventType, actor, payload);
        historyRepository.save(history);
        log.debug("Recorded {} event for booking {}", eventType, bookingId);
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/application/usecase/CancelBlockUseCase.java ==========
package com.flavia.dermobeauty.booking.application.usecase;

import com.flavia.dermobeauty.booking.domain.Block;
import com.flavia.dermobeauty.booking.domain.BlockRepository;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Use case for cancelling a block.
 * Marks the block as CANCELLED (soft delete).
 */
@SuppressWarnings("ClassCanBeRecord")
@Slf4j
@RequiredArgsConstructor
public class CancelBlockUseCase {

    private final BlockRepository blockRepository;

    /**
     * Cancels a block by ID.
     *
     * @param blockId the ID of the block to cancel
     * @return the cancelled block
     * @throws ResourceNotFoundException if block not found
     */
    public Block execute(Long blockId) {
        log.info("Cancelling block with ID: {}", blockId);

        Block block = blockRepository.findById(blockId)
                .orElseThrow(() -> new ResourceNotFoundException("Block", blockId));

        block.cancel();

        Block saved = blockRepository.save(block);
        log.info("Block cancelled successfully: {}", saved.getBlockNumber());

        return saved;
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/application/usecase/CancelBookingUseCase.java ==========
package com.flavia.dermobeauty.booking.application.usecase;

import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.domain.BookingRepository;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Use Case: Cancel a booking.
 * Can be initiated by admin or customer.
 */
@Slf4j
@RequiredArgsConstructor
public class CancelBookingUseCase {

    private final BookingRepository bookingRepository;

    public Booking execute(Long bookingId) {
        log.info("Cancelling booking: {}", bookingId);

        Booking booking = bookingRepository.findById(bookingId)
                .orElseThrow(() -> new ResourceNotFoundException("Booking", bookingId));

        // Cancel (domain logic validates business rules)
        booking.cancel();

        // Persist
        Booking updated = bookingRepository.save(booking);
        log.info("Booking cancelled: {}", updated.getBookingNumber());

        return updated;
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/application/usecase/ConfirmBookingPaymentUseCase.java ==========
package com.flavia.dermobeauty.booking.application.usecase;

import com.flavia.dermobeauty.booking.application.port.NotificationService;
import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.domain.BookingRepository;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Use Case: Confirm booking payment.
 * Called from Mercado Pago webhook when payment is approved.
 */
@Slf4j
@RequiredArgsConstructor
public class ConfirmBookingPaymentUseCase {

    private final BookingRepository bookingRepository;
    private final NotificationService notificationService;

    public Booking execute(String paymentId) {
        log.info("Confirming payment for payment ID: {}", paymentId);

        // Find booking by payment ID
        Booking booking = bookingRepository.findByMercadoPagoPaymentId(paymentId)
                .orElseThrow(() -> new ResourceNotFoundException("Booking with payment ID '" + paymentId + "' not found"));

        // Confirm payment (domain logic)
        booking.confirmPayment(paymentId);

        // Persist
        Booking updated = bookingRepository.save(booking);
        log.info("Payment confirmed for booking: {}", updated.getBookingNumber());

        // Send confirmation email (async, non-blocking)
        try {
            notificationService.sendBookingConfirmation(updated);
        } catch (Exception e) {
            log.error("Failed to send booking confirmation email for {}", updated.getBookingNumber(), e);
            // Don't throw - email failure should not break payment confirmation
        }

        return updated;
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/application/usecase/CreateBlockUseCase.java ==========
package com.flavia.dermobeauty.booking.application.usecase;

import com.flavia.dermobeauty.booking.domain.Block;
import com.flavia.dermobeauty.booking.domain.BlockRepository;
import com.flavia.dermobeauty.booking.domain.BookingRepository;
import com.flavia.dermobeauty.shared.exception.ConflictException;
import com.flavia.dermobeauty.shared.exception.ValidationException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.time.OffsetDateTime;
import java.util.UUID;

/**
 * Use case for creating a new block (time slot reservation).
 * Validates alignment rules and checks for collisions with bookings and other blocks.
 */
@SuppressWarnings("ClassCanBeRecord")
@Slf4j
@RequiredArgsConstructor
public class CreateBlockUseCase {

    private final BlockRepository blockRepository;
    private final BookingRepository bookingRepository;

    /**
     * Creates a new block.
     *
     * @param startAt start time (must be aligned to 30-min intervals)
     * @param endAt end time (must be aligned to 30-min intervals, must be after startAt)
     * @param reason reason for the block (required)
     * @return the created block
     * @throws ValidationException if alignment or time rules are violated
     * @throws ConflictException if the time range conflicts with existing bookings or blocks
     */
    public Block execute(OffsetDateTime startAt, OffsetDateTime endAt, String reason) {
        log.info("Creating block from {} to {} with reason: {}", startAt, endAt, reason);

        // Validate alignment (30-min intervals)
        validateAlignment(startAt, "startAt");
        validateAlignment(endAt, "endAt");

        // Validate time range
        if (!startAt.isBefore(endAt)) {
            throw new ValidationException("La hora de inicio debe ser anterior a la hora de fin");
        }

        // Check for collisions with active blocks
        if (blockRepository.existsActiveBlockInRange(startAt, endAt)) {
            throw new ConflictException("Ya existe un bloqueo activo en ese rango de tiempo");
        }

        // Check for collisions with active bookings
        // Bookings that "occupy" are PENDING or CONFIRMED
        if (hasBookingCollision(startAt, endAt)) {
            throw new ConflictException("Existe un turno activo en ese rango de tiempo");
        }

        // Generate block number
        String blockNumber = generateBlockNumber();

        // Create block using factory method
        Block block = Block.create(blockNumber, reason, startAt, endAt);

        // Persist
        Block saved = blockRepository.save(block);
        log.info("Block created successfully: {}", saved.getBlockNumber());

        return saved;
    }

    private void validateAlignment(OffsetDateTime time, String fieldName) {
        int minute = time.getMinute();
        if (minute != 0 && minute != 30) {
            throw new ValidationException(
                    fieldName + " debe estar alineado a intervalos de 30 minutos (:00 o :30)"
            );
        }
    }

    private boolean hasBookingCollision(OffsetDateTime startAt, OffsetDateTime endAt) {
        // Query bookings in range (only those that occupy time: PENDING, CONFIRMED)
        return bookingRepository.findByDateRange(startAt, endAt, false).stream()
                .anyMatch(booking -> {
                    OffsetDateTime bookingStart = booking.getStartAt();
                    OffsetDateTime bookingEnd = booking.getEndAt();
                    // Collision: A.start < B.end AND B.start < A.end
                    return bookingStart.isBefore(endAt) && startAt.isBefore(bookingEnd);
                });
    }

    private String generateBlockNumber() {
        String uuid = UUID.randomUUID().toString().replace("-", "").substring(0, 8).toUpperCase();
        return "BLOCK-" + uuid;
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/application/usecase/CreateBookingUseCase.java ==========
package com.flavia.dermobeauty.booking.application.usecase;

import com.flavia.dermobeauty.booking.domain.*;
import com.flavia.dermobeauty.shared.exception.ValidationException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.OffsetDateTime;
import java.time.ZoneId;
import java.util.UUID;

@SuppressWarnings("ClassCanBeRecord")
@Slf4j
@RequiredArgsConstructor
public class CreateBookingUseCase {

    private static final ZoneId ARGENTINA_ZONE = ZoneId.of("America/Argentina/Buenos_Aires");

    private final BookingRepository bookingRepository;

    public Booking execute(
            Long serviceId,
            String serviceName,
            String customerName,
            String customerEmail,
            String customerWhatsapp,
            String customerComments,
            LocalDate bookingDate,
            LocalTime bookingTime,
            Integer durationMinutes,
            BigDecimal amount) {

        log.info("Creating booking for service {} on {} at {}", serviceId, bookingDate, bookingTime);

        // Validar alineación a slots de 30 minutos
        if (bookingTime.getMinute() != 0 && bookingTime.getMinute() != 30) {
            throw new ValidationException("El horario debe ser en intervalos de 30 minutos (:00 o :30)");
        }

        if (durationMinutes <= 0 || durationMinutes % 30 != 0) {
            throw new ValidationException("La duración debe ser múltiplo de 30 minutos");
        }

        // Calcular hora de fin
        LocalTime bookingEndTime = bookingTime.plusMinutes(durationMinutes);

        // Validar disponibilidad real (rangos de tiempo)
        if (!bookingRepository.isTimeSlotAvailable(serviceId, bookingDate, bookingTime, bookingEndTime)) {
            throw new ValidationException(
                    "El horario seleccionado (" + bookingTime + " - " + bookingEndTime + ") no está disponible."
            );
        }

        // Crear value objects
        CustomerInfo customerInfo = new CustomerInfo(
                customerName,
                customerEmail,
                customerWhatsapp,
                customerComments
        );

        TimeSlot timeSlot = new TimeSlot(bookingDate, bookingTime);

        // Crear startAt con timezone
        OffsetDateTime startAt = LocalDateTime.of(bookingDate, bookingTime)
                .atZone(ARGENTINA_ZONE)
                .toOffsetDateTime();

        // Crear booking aggregate
        Booking booking = Booking.builder()
                .bookingNumber(generateBookingNumber())
                .serviceId(serviceId)
                .serviceName(serviceName)
                .customerInfo(customerInfo)
                .timeSlot(timeSlot)
                .startAt(startAt)
                .durationMinutes(durationMinutes)
                .status(BookingStatus.PENDING)
                .paymentStatus(PaymentStatus.PENDING)
                .amount(amount)
                .createdAt(LocalDateTime.now())
                .updatedAt(LocalDateTime.now())
                .build();

        // Persistir
        Booking saved = bookingRepository.save(booking);
        log.info("Booking created successfully: {}", saved.getBookingNumber());

        return saved;
    }

    /**
     * Generates a booking number using ULID-like format for uniqueness.
     * Format: BOOK-{first 8 chars of UUID}
     */
    private String generateBookingNumber() {
        String uuid = UUID.randomUUID().toString().replace("-", "").substring(0, 8).toUpperCase();
        return "BOOK-" + uuid;
    }
}

========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/application/usecase/GetAvailableSlotsUseCase.java ==========
package com.flavia.dermobeauty.booking.application.usecase;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.flavia.dermobeauty.booking.domain.Block;
import com.flavia.dermobeauty.booking.domain.BlockRepository;
import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.domain.BookingRepository;
import com.flavia.dermobeauty.catalog.entity.ServiceEntity;
import com.flavia.dermobeauty.catalog.repository.ServiceRepository;
import com.flavia.dermobeauty.config.domain.ConfigEntry;
import com.flavia.dermobeauty.config.repository.ConfigRepository;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.time.LocalDate;
import java.time.LocalTime;
import java.time.OffsetDateTime;
import java.time.ZoneId;
import java.time.format.TextStyle;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Locale;

/**
 * Use Case: Get available time slots for a service on a specific date.
 *
 * Business hours are database-driven via the "schedule.weekly" config entry.
 * Returns empty list if the requested day is marked as closed.
 *
 * Availability considers:
 * - Bookings with status IN (PENDING, CONFIRMED) occupy time
 * - Blocks with status ACTIVE occupy time
 * - CANCELLED/COMPLETED bookings and CANCELLED blocks do NOT occupy time
 * - Collisions are GLOBAL (single resource - Flavia), not per-service
 */
@SuppressWarnings("ClassCanBeRecord")
@Slf4j
@RequiredArgsConstructor
public class GetAvailableSlotsUseCase {

    private static final ZoneId ARGENTINA_ZONE = ZoneId.of("America/Argentina/Buenos_Aires");
    private static final int SLOT_INTERVAL_MINUTES = 30;
    private static final String SCHEDULE_CONFIG_KEY = "schedule.weekly";

    // Fallback values if config is missing or invalid
    private static final LocalTime FALLBACK_OPEN_TIME = LocalTime.of(9, 0);
    private static final LocalTime FALLBACK_CLOSE_TIME = LocalTime.of(19, 0);

    private final BookingRepository bookingRepository;
    private final BlockRepository blockRepository;
    private final ServiceRepository serviceRepository;
    private final ConfigRepository configRepository;
    private final ObjectMapper objectMapper;

    public List<LocalTime> execute(Long serviceId, LocalDate date) {
        log.debug("Calculating availability for service {} on {}", serviceId, date);

        // 1. Get service duration (for slot sizing)
        ServiceEntity service = serviceRepository.findById(serviceId)
                .orElseThrow(() -> new ResourceNotFoundException("Service", serviceId));
        int durationMinutes = service.getDurationMinutes();

        // Validate duration is multiple of 30
        if (durationMinutes <= 0 || durationMinutes % 30 != 0) {
            log.warn("Service {} has invalid duration {}. Rounding to nearest 30.", serviceId, durationMinutes);
            durationMinutes = ((durationMinutes + 29) / 30) * 30;
        }

        // 2. Get business hours for the requested day
        BusinessHours businessHours = getBusinessHoursForDate(date);

        // 3. If the day is closed, return empty list
        if (!businessHours.isEnabled()) {
            log.info("Day {} is closed. No slots available.", date.getDayOfWeek());
            return Collections.emptyList();
        }

        // 4. Convert day boundaries to OffsetDateTime
        OffsetDateTime dayStart = date.atTime(businessHours.getOpenTime())
                .atZone(ARGENTINA_ZONE).toOffsetDateTime();
        OffsetDateTime dayEnd = date.atTime(businessHours.getCloseTime())
                .atZone(ARGENTINA_ZONE).toOffsetDateTime();

        // 5. Get all OCCUPYING bookings for the day (PENDING, CONFIRMED only)
        // Using date range query - includeCancelled=false excludes CANCELLED
        List<Booking> occupyingBookings = bookingRepository.findByDateRange(dayStart, dayEnd, false)
                .stream()
                .filter(Booking::occupiesTime) // PENDING or CONFIRMED
                .toList();

        // 6. Get all ACTIVE blocks for the day
        List<Block> activeBlocks = blockRepository.findActiveBlocksInRange(dayStart, dayEnd);

        // 7. Check if entire day is blocked
        if (isDayFullyBlocked(dayStart, dayEnd, activeBlocks)) {
            log.info("Day {} is fully blocked. No slots available.", date);
            return Collections.emptyList();
        }

        // 8. Calculate available slots
        List<LocalTime> availableSlots = new ArrayList<>();
        LocalTime currentSlot = businessHours.getOpenTime();
        LocalTime closeTime = businessHours.getCloseTime();

        while (canServiceFit(currentSlot, durationMinutes, closeTime)) {
            OffsetDateTime slotStart = date.atTime(currentSlot)
                    .atZone(ARGENTINA_ZONE).toOffsetDateTime();
            OffsetDateTime slotEnd = slotStart.plusMinutes(durationMinutes);

            if (isSlotFree(slotStart, slotEnd, occupyingBookings, activeBlocks)) {
                availableSlots.add(currentSlot);
            }

            currentSlot = currentSlot.plusMinutes(SLOT_INTERVAL_MINUTES);
        }

        log.debug("Found {} available slots for service {} on {}", availableSlots.size(), serviceId, date);
        return availableSlots;
    }

    /**
     * Fetches business hours from database config for the requested date.
     */
    private BusinessHours getBusinessHoursForDate(LocalDate date) {
        try {
            String dayKey = date.getDayOfWeek()
                    .getDisplayName(TextStyle.FULL, Locale.ENGLISH)
                    .toLowerCase();

            ConfigEntry scheduleConfig = configRepository.findByKey(SCHEDULE_CONFIG_KEY)
                    .orElseThrow(() -> new RuntimeException("Schedule config not found"));

            JsonNode scheduleJson = objectMapper.readTree(scheduleConfig.getValue());
            JsonNode dayConfig = scheduleJson.get(dayKey);

            if (dayConfig == null) {
                log.warn("No config found for day '{}', using fallback", dayKey);
                return new BusinessHours(true, FALLBACK_OPEN_TIME, FALLBACK_CLOSE_TIME);
            }

            boolean enabled = dayConfig.get("enabled").asBoolean();
            if (!enabled) {
                return new BusinessHours(false, null, null);
            }

            String startTimeStr = dayConfig.get("startTime").asText();
            String endTimeStr = dayConfig.get("endTime").asText();

            LocalTime openTime = LocalTime.parse(startTimeStr);
            LocalTime closeTime = LocalTime.parse(endTimeStr);

            log.debug("Business hours for {}: {} - {}", dayKey, openTime, closeTime);
            return new BusinessHours(true, openTime, closeTime);

        } catch (Exception e) {
            log.error("Error parsing schedule config, using fallback hours", e);
            return new BusinessHours(true, FALLBACK_OPEN_TIME, FALLBACK_CLOSE_TIME);
        }
    }

    private boolean canServiceFit(LocalTime start, int duration, LocalTime closeTime) {
        LocalTime end = start.plusMinutes(duration);
        // Check for midnight overflow
        if (end.isBefore(start)) return false;
        return !end.isAfter(closeTime);
    }

    /**
     * Checks if a slot is free (no collisions with bookings or blocks).
     */
    private boolean isSlotFree(OffsetDateTime slotStart, OffsetDateTime slotEnd,
                               List<Booking> bookings, List<Block> blocks) {
        // Check collision with bookings
        for (Booking b : bookings) {
            OffsetDateTime bStart = b.getStartAt();
            OffsetDateTime bEnd = b.getEndAt();

            // Overlap: A.start < B.end AND A.end > B.start
            if (slotStart.isBefore(bEnd) && slotEnd.isAfter(bStart)) {
                return false;
            }
        }

        // Check collision with blocks
        for (Block bl : blocks) {
            OffsetDateTime blStart = bl.getStartAt();
            OffsetDateTime blEnd = bl.getEndAt();

            if (slotStart.isBefore(blEnd) && slotEnd.isAfter(blStart)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the entire business day is covered by a single block.
     */
    private boolean isDayFullyBlocked(OffsetDateTime dayStart, OffsetDateTime dayEnd, List<Block> blocks) {
        for (Block bl : blocks) {
            if (bl.getStartAt().compareTo(dayStart) <= 0 && bl.getEndAt().compareTo(dayEnd) >= 0) {
                return true;
            }
        }
        return false;
    }

    private static class BusinessHours {
        private final boolean enabled;
        private final LocalTime openTime;
        private final LocalTime closeTime;

        public BusinessHours(boolean enabled, LocalTime openTime, LocalTime closeTime) {
            this.enabled = enabled;
            this.openTime = openTime;
            this.closeTime = closeTime;
        }

        public boolean isEnabled() { return enabled; }
        public LocalTime getOpenTime() { return openTime; }
        public LocalTime getCloseTime() { return closeTime; }
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/application/usecase/GetBookingByNumberUseCase.java ==========
package com.flavia.dermobeauty.booking.application.usecase;

import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.domain.BookingRepository;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Use Case: Get booking by booking number.
 * Used by customers to check their booking status.
 */
@Slf4j
@RequiredArgsConstructor
public class GetBookingByNumberUseCase {

    private final BookingRepository bookingRepository;

    public Booking execute(String bookingNumber) {
        log.debug("Fetching booking by number: {}", bookingNumber);

        return bookingRepository.findByBookingNumber(bookingNumber)
                .orElseThrow(() -> new ResourceNotFoundException("Booking with number '" + bookingNumber + "' not found"));
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/application/usecase/GetCalendarEventsUseCase.java ==========
package com.flavia.dermobeauty.booking.application.usecase;

import com.flavia.dermobeauty.booking.domain.Block;
import com.flavia.dermobeauty.booking.domain.BlockRepository;
import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.domain.BookingRepository;
import com.flavia.dermobeauty.booking.web.dto.CalendarEventResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.time.LocalDate;
import java.time.LocalTime;
import java.time.OffsetDateTime;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

/**
 * Use case for fetching calendar events (bookings + blocks merged).
 * Returns a unified list of CalendarEventResponse sorted by start time.
 */
@SuppressWarnings("ClassCanBeRecord")
@Slf4j
@RequiredArgsConstructor
public class GetCalendarEventsUseCase {

    private static final ZoneId ARGENTINA_ZONE = ZoneId.of("America/Argentina/Buenos_Aires");

    private final BookingRepository bookingRepository;
    private final BlockRepository blockRepository;

    /**
     * Fetches calendar events for a date range.
     *
     * @param fromDate start date (interpreted in Argentina timezone)
     * @param toDate end date (interpreted in Argentina timezone, inclusive)
     * @param includeCancelled if true, includes cancelled events
     * @return list of calendar events sorted by start time
     */
    public List<CalendarEventResponse> execute(LocalDate fromDate, LocalDate toDate, boolean includeCancelled) {
        log.info("Fetching calendar events from {} to {} (includeCancelled={})",
                fromDate, toDate, includeCancelled);

        // Convert dates to OffsetDateTime in Argentina timezone
        OffsetDateTime from = fromDate.atStartOfDay(ARGENTINA_ZONE).toOffsetDateTime();
        OffsetDateTime to = toDate.atTime(LocalTime.MAX).atZone(ARGENTINA_ZONE).toOffsetDateTime();

        // Fetch bookings
        List<Booking> bookings = bookingRepository.findByDateRange(from, to, includeCancelled);
        log.debug("Found {} bookings in range", bookings.size());

        // Fetch blocks
        List<Block> blocks = blockRepository.findByDateRange(from, to, includeCancelled);
        log.debug("Found {} blocks in range", blocks.size());

        // Convert and merge
        List<CalendarEventResponse> events = new ArrayList<>();

        for (Booking booking : bookings) {
            events.add(CalendarEventResponse.fromBooking(booking));
        }

        for (Block block : blocks) {
            events.add(CalendarEventResponse.fromBlock(block));
        }

        // Sort by start time
        events.sort(Comparator.comparing(CalendarEventResponse::getStartAt));

        log.info("Returning {} total calendar events", events.size());
        return events;
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/application/usecase/ListBookingsUseCase.java ==========
package com.flavia.dermobeauty.booking.application.usecase;

import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.domain.BookingRepository;
import com.flavia.dermobeauty.booking.domain.BookingStatus;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.util.List;

/**
 * Use Case: List bookings for admin panel.
 * Supports filtering by status.
 */
@Slf4j
@RequiredArgsConstructor
public class ListBookingsUseCase {

    private final BookingRepository bookingRepository;

    public List<Booking> execute() {
        log.debug("Fetching all bookings");
        return bookingRepository.findAll();
    }

    public List<Booking> executeByStatus(BookingStatus status) {
        log.debug("Fetching bookings with status: {}", status);
        return bookingRepository.findByStatus(status);
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/application/usecase/RescheduleBookingUseCase.java ==========
package com.flavia.dermobeauty.booking.application.usecase;

import com.flavia.dermobeauty.booking.domain.BlockRepository;
import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.domain.BookingRepository;
import com.flavia.dermobeauty.shared.exception.ConflictException;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import com.flavia.dermobeauty.shared.exception.ValidationException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.time.OffsetDateTime;

/**
 * Use case for rescheduling a booking to a new time.
 * Validates alignment rules and checks for collisions.
 */
@SuppressWarnings("ClassCanBeRecord")
@Slf4j
@RequiredArgsConstructor
public class RescheduleBookingUseCase {

    private final BookingRepository bookingRepository;
    private final BlockRepository blockRepository;

    /**
     * Reschedules a booking to a new start time.
     *
     * @param bookingId the ID of the booking to reschedule
     * @param newStartAt the new start time (must be aligned to 30-min intervals)
     * @return the rescheduled booking
     * @throws ResourceNotFoundException if booking not found
     * @throws ValidationException if alignment rules are violated
     * @throws ConflictException if the new time conflicts with existing bookings or blocks
     */
    public Booking execute(Long bookingId, OffsetDateTime newStartAt) {
        log.info("Rescheduling booking {} to {}", bookingId, newStartAt);

        // Find booking
        Booking booking = bookingRepository.findById(bookingId)
                .orElseThrow(() -> new ResourceNotFoundException("Booking", bookingId));

        // Validate alignment
        int minute = newStartAt.getMinute();
        if (minute != 0 && minute != 30) {
            throw new ValidationException("El horario debe estar alineado a intervalos de 30 minutos (:00 o :30)");
        }

        // Calculate new end time
        OffsetDateTime newEndAt = newStartAt.plusMinutes(booking.getDurationMinutes());

        // Check for collisions with other bookings (excluding this one)
        if (hasBookingCollision(bookingId, newStartAt, newEndAt)) {
            throw new ConflictException("El nuevo horario colisiona con otro turno existente");
        }

        // Check for collisions with blocks
        if (blockRepository.existsActiveBlockInRange(newStartAt, newEndAt)) {
            throw new ConflictException("El nuevo horario colisiona con un bloqueo existente");
        }

        // Reschedule
        booking.reschedule(newStartAt);

        // Persist
        Booking saved = bookingRepository.save(booking);
        log.info("Booking {} rescheduled to {}", saved.getBookingNumber(), newStartAt);

        return saved;
    }

    private boolean hasBookingCollision(Long excludeBookingId, OffsetDateTime startAt, OffsetDateTime endAt) {
        // Query bookings in range (only those that occupy time: PENDING, CONFIRMED)
        return bookingRepository.findByDateRange(startAt, endAt, false).stream()
                .filter(b -> !b.getId().equals(excludeBookingId)) // Exclude current booking
                .anyMatch(booking -> {
                    OffsetDateTime bookingStart = booking.getStartAt();
                    OffsetDateTime bookingEnd = booking.getEndAt();
                    // Collision: A.start < B.end AND B.start < A.end
                    return bookingStart.isBefore(endAt) && startAt.isBefore(bookingEnd);
                });
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/application/usecase/UpdateBookingCustomerUseCase.java ==========
package com.flavia.dermobeauty.booking.application.usecase;

import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.domain.BookingRepository;
import com.flavia.dermobeauty.booking.domain.CustomerInfo;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Use case for updating customer information on a booking.
 */
@SuppressWarnings("ClassCanBeRecord")
@Slf4j
@RequiredArgsConstructor
public class UpdateBookingCustomerUseCase {

    private final BookingRepository bookingRepository;

    /**
     * Updates customer information on a booking.
     *
     * @param bookingId the ID of the booking
     * @param name customer name
     * @param email customer email
     * @param whatsapp customer WhatsApp number
     * @param comments optional comments
     * @return the updated booking
     * @throws ResourceNotFoundException if booking not found
     */
    public Booking execute(Long bookingId, String name, String email, String whatsapp, String comments) {
        log.info("Updating customer info for booking {}", bookingId);

        Booking booking = bookingRepository.findById(bookingId)
                .orElseThrow(() -> new ResourceNotFoundException("Booking", bookingId));

        CustomerInfo newCustomerInfo = new CustomerInfo(name, email, whatsapp, comments);
        booking.updateCustomer(newCustomerInfo);

        Booking saved = bookingRepository.save(booking);
        log.info("Customer info updated for booking {}", saved.getBookingNumber());

        return saved;
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/config/BookingConfig.java ==========
package com.flavia.dermobeauty.booking.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.flavia.dermobeauty.booking.application.port.NotificationService;
import com.flavia.dermobeauty.booking.application.usecase.*;
import com.flavia.dermobeauty.booking.domain.BlockRepository;
import com.flavia.dermobeauty.booking.domain.BookingRepository;
import com.flavia.dermobeauty.catalog.repository.ServiceRepository;
import com.flavia.dermobeauty.config.repository.ConfigRepository;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * Configuration class for Booking module.
 * Wires use cases as Spring beans for dependency injection.
 */
@Configuration
public class BookingConfig {

    @Bean
    public CreateBookingUseCase createBookingUseCase(BookingRepository bookingRepository) {
        return new CreateBookingUseCase(bookingRepository);
    }

    @Bean
    public ConfirmBookingPaymentUseCase confirmBookingPaymentUseCase(
            BookingRepository bookingRepository,
            NotificationService notificationService) {
        return new ConfirmBookingPaymentUseCase(bookingRepository, notificationService);
    }

    @Bean
    public ListBookingsUseCase listBookingsUseCase(BookingRepository bookingRepository) {
        return new ListBookingsUseCase(bookingRepository);
    }

    @Bean
    public CancelBookingUseCase cancelBookingUseCase(BookingRepository bookingRepository) {
        return new CancelBookingUseCase(bookingRepository);
    }

    @Bean
    public GetBookingByNumberUseCase getBookingByNumberUseCase(BookingRepository bookingRepository) {
        return new GetBookingByNumberUseCase(bookingRepository);
    }

    @Bean
    public GetAvailableSlotsUseCase getAvailableSlotsUseCase(
            BookingRepository bookingRepository,
            BlockRepository blockRepository,
            ServiceRepository serviceRepository,
            ConfigRepository configRepository,
            ObjectMapper objectMapper
    ) {
        return new GetAvailableSlotsUseCase(
                bookingRepository,
                blockRepository,
                serviceRepository,
                configRepository,
                objectMapper
        );
    }

    @Bean
    public GetCalendarEventsUseCase getCalendarEventsUseCase(
            BookingRepository bookingRepository,
            BlockRepository blockRepository
    ) {
        return new GetCalendarEventsUseCase(bookingRepository, blockRepository);
    }

    @Bean
    public CreateBlockUseCase createBlockUseCase(
            BlockRepository blockRepository,
            BookingRepository bookingRepository
    ) {
        return new CreateBlockUseCase(blockRepository, bookingRepository);
    }

    @Bean
    public CancelBlockUseCase cancelBlockUseCase(BlockRepository blockRepository) {
        return new CancelBlockUseCase(blockRepository);
    }

    @Bean
    public RescheduleBookingUseCase rescheduleBookingUseCase(
            BookingRepository bookingRepository,
            BlockRepository blockRepository
    ) {
        return new RescheduleBookingUseCase(bookingRepository, blockRepository);
    }

    @Bean
    public UpdateBookingCustomerUseCase updateBookingCustomerUseCase(BookingRepository bookingRepository) {
        return new UpdateBookingCustomerUseCase(bookingRepository);
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/domain/Block.java ==========
package com.flavia.dermobeauty.booking.domain;

import com.flavia.dermobeauty.shared.exception.DomainException;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;

import java.time.OffsetDateTime;
import java.time.ZoneId;

/**
 * Block Aggregate Root.
 * Represents a schedule block (holiday, personal day, etc.).
 * Blocks occupy time slots and prevent bookings during that period.
 */
@Getter
@AllArgsConstructor
@Builder
public class Block {

    private static final ZoneId ARGENTINA_ZONE = ZoneId.of("America/Argentina/Buenos_Aires");

    private Long id;
    private String blockNumber;
    private String reason;
    private OffsetDateTime startAt;
    private OffsetDateTime endAt;
    private BlockStatus status;
    private OffsetDateTime createdAt;
    private OffsetDateTime updatedAt;
    private OffsetDateTime cancelledAt;

    /**
     * Factory method to create a new block.
     * Validates business rules at creation time.
     */
    public static Block create(String blockNumber, String reason, OffsetDateTime startAt, OffsetDateTime endAt) {
        validateTimeRange(startAt, endAt);
        validateAlignment(startAt, "startAt");
        validateAlignment(endAt, "endAt");

        if (reason == null || reason.isBlank()) {
            throw new IllegalArgumentException("Block reason cannot be empty");
        }

        OffsetDateTime now = OffsetDateTime.now(ARGENTINA_ZONE);

        return Block.builder()
                .blockNumber(blockNumber)
                .reason(reason.trim())
                .startAt(startAt)
                .endAt(endAt)
                .status(BlockStatus.ACTIVE)
                .createdAt(now)
                .updatedAt(now)
                .build();
    }

    /**
     * Cancels this block.
     * Cancelled blocks no longer occupy time slots.
     */
    public void cancel() {
        if (this.status == BlockStatus.CANCELLED) {
            throw new DomainException("Block " + blockNumber + " is already cancelled");
        }

        OffsetDateTime now = OffsetDateTime.now(ARGENTINA_ZONE);
        this.status = BlockStatus.CANCELLED;
        this.cancelledAt = now;
        this.updatedAt = now;
    }

    /**
     * Checks if this block occupies time slots (used in collision detection).
     */
    public boolean occupiesTime() {
        return status == BlockStatus.ACTIVE;
    }

    /**
     * Gets the duration of this block in minutes.
     */
    public long getDurationMinutes() {
        return java.time.Duration.between(startAt, endAt).toMinutes();
    }

    private static void validateTimeRange(OffsetDateTime startAt, OffsetDateTime endAt) {
        if (startAt == null || endAt == null) {
            throw new IllegalArgumentException("Start and end times cannot be null");
        }
        if (!endAt.isAfter(startAt)) {
            throw new DomainException("Block end time must be after start time");
        }
    }

    private static void validateAlignment(OffsetDateTime time, String fieldName) {
        int minute = time.getMinute();
        if (minute != 0 && minute != 30) {
            throw new DomainException(fieldName + " must be aligned to 30-minute intervals (:00 or :30)");
        }
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/domain/BlockRepository.java ==========
package com.flavia.dermobeauty.booking.domain;

import java.time.OffsetDateTime;
import java.util.List;
import java.util.Optional;

/**
 * Repository port for Block aggregate.
 * Defines the contract for block persistence operations.
 */
public interface BlockRepository {

    /**
     * Saves a block (create or update).
     */
    Block save(Block block);

    /**
     * Finds a block by its ID.
     */
    Optional<Block> findById(Long id);

    /**
     * Finds a block by its block number.
     */
    Optional<Block> findByBlockNumber(String blockNumber);

    /**
     * Finds all active blocks within a date range.
     * Used for calendar display.
     */
    List<Block> findByDateRange(OffsetDateTime from, OffsetDateTime to, boolean includeCancelled);

    /**
     * Finds all active blocks that overlap with a given time range.
     * Used for collision detection.
     */
    List<Block> findActiveBlocksInRange(OffsetDateTime startAt, OffsetDateTime endAt);

    /**
     * Checks if there's any active block that overlaps with the given time range.
     * Optimized for collision detection (returns early if any collision found).
     */
    boolean existsActiveBlockInRange(OffsetDateTime startAt, OffsetDateTime endAt);
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/domain/BlockStatus.java ==========
package com.flavia.dermobeauty.booking.domain;

/**
 * Domain enum representing the status of a schedule block.
 */
public enum BlockStatus {
    ACTIVE,     // Block is active and occupies the time slot
    CANCELLED   // Block was cancelled and no longer occupies time
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/domain/BookingHistory.java ==========
package com.flavia.dermobeauty.booking.domain;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;

import java.time.OffsetDateTime;
import java.time.ZoneId;
import java.util.Map;

/**
 * BookingHistory Entity.
 * Represents an audit trail entry for a booking change.
 * This is an append-only entity: records are never modified or deleted.
 */
@Getter
@AllArgsConstructor
@Builder
public class BookingHistory {

    private static final ZoneId ARGENTINA_ZONE = ZoneId.of("America/Argentina/Buenos_Aires");

    private Long id;
    private Long bookingId;
    private HistoryEventType eventType;
    private HistoryActor actor;
    private Map<String, Object> payload;  // JSON payload as Map
    private OffsetDateTime createdAt;

    /**
     * Factory method to create a new history entry.
     */
    public static BookingHistory create(Long bookingId, HistoryEventType eventType, HistoryActor actor, Map<String, Object> payload) {
        if (bookingId == null) {
            throw new IllegalArgumentException("Booking ID cannot be null");
        }
        if (eventType == null) {
            throw new IllegalArgumentException("Event type cannot be null");
        }
        if (actor == null) {
            throw new IllegalArgumentException("Actor cannot be null");
        }

        return BookingHistory.builder()
                .bookingId(bookingId)
                .eventType(eventType)
                .actor(actor)
                .payload(payload)
                .createdAt(OffsetDateTime.now(ARGENTINA_ZONE))
                .build();
    }

    /**
     * Convenience factory for CREATED event.
     */
    public static BookingHistory created(Long bookingId, HistoryActor actor) {
        return create(bookingId, HistoryEventType.CREATED, actor, null);
    }

    /**
     * Convenience factory for STATUS_CHANGED event.
     */
    public static BookingHistory statusChanged(Long bookingId, HistoryActor actor, BookingStatus oldStatus, BookingStatus newStatus) {
        return create(bookingId, HistoryEventType.STATUS_CHANGED, actor, Map.of(
                "old_status", oldStatus.name(),
                "new_status", newStatus.name()
        ));
    }

    /**
     * Convenience factory for RESCHEDULED event.
     */
    public static BookingHistory rescheduled(Long bookingId, HistoryActor actor, OffsetDateTime oldStartAt, OffsetDateTime newStartAt) {
        return create(bookingId, HistoryEventType.RESCHEDULED, actor, Map.of(
                "old_start_at", oldStartAt.toString(),
                "new_start_at", newStartAt.toString()
        ));
    }

    /**
     * Convenience factory for CUSTOMER_UPDATED event.
     */
    public static BookingHistory customerUpdated(Long bookingId, HistoryActor actor, Map<String, Object> changes) {
        return create(bookingId, HistoryEventType.CUSTOMER_UPDATED, actor, changes);
    }

    /**
     * Convenience factory for PAYMENT_UPDATED event.
     */
    public static BookingHistory paymentUpdated(Long bookingId, HistoryActor actor, PaymentStatus oldStatus, PaymentStatus newStatus) {
        return create(bookingId, HistoryEventType.PAYMENT_UPDATED, actor, Map.of(
                "old_payment_status", oldStatus.name(),
                "new_payment_status", newStatus.name()
        ));
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/domain/BookingHistoryRepository.java ==========
package com.flavia.dermobeauty.booking.domain;

import java.util.List;

/**
 * Repository port for BookingHistory.
 * Append-only: only save and find operations, no delete.
 */
public interface BookingHistoryRepository {

    /**
     * Saves a history entry (always insert, never update).
     */
    BookingHistory save(BookingHistory history);

    /**
     * Finds all history entries for a booking, ordered by creation time (newest first).
     */
    List<BookingHistory> findByBookingId(Long bookingId);

    /**
     * Finds all history entries for a booking, ordered by creation time (oldest first).
     */
    List<BookingHistory> findByBookingIdOrderByCreatedAtAsc(Long bookingId);
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/domain/Booking.java ==========
package com.flavia.dermobeauty.booking.domain;

import com.flavia.dermobeauty.shared.exception.DomainException;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.time.OffsetDateTime;
import java.time.ZoneId;

/**
 * Booking Aggregate Root.
 * Represents a service booking/appointment with business rules enforcement.
 */
@Getter
@AllArgsConstructor
@Builder
public class Booking {

    private static final ZoneId ARGENTINA_ZONE = ZoneId.of("America/Argentina/Buenos_Aires");

    private Long id;
    private String bookingNumber;
    private Long serviceId;
    private String serviceName;  // Snapshot inmutable del nombre del servicio
    private CustomerInfo customerInfo;
    private TimeSlot timeSlot;  // Legacy - kept for compatibility
    private OffsetDateTime startAt;  // New datetime with timezone
    private Integer durationMinutes;
    private BookingStatus status;
    private PaymentStatus paymentStatus;
    private String mercadoPagoPreferenceId;
    private String mercadoPagoPaymentId;
    private BigDecimal amount;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    private LocalDateTime confirmedAt;
    private LocalDateTime cancelledAt;

    /**
     * Computed end time based on startAt + durationMinutes.
     * This is NOT persisted in DB to avoid inconsistencies.
     */
    public OffsetDateTime getEndAt() {
        if (startAt == null || durationMinutes == null) {
            return null;
        }
        return startAt.plusMinutes(durationMinutes);
    }

    /**
     * Checks if this booking occupies time slots (used in collision detection).
     * Only PENDING and CONFIRMED bookings occupy time.
     */
    public boolean occupiesTime() {
        return status == BookingStatus.PENDING || status == BookingStatus.CONFIRMED;
    }

    /**
     * Confirms payment for this booking.
     * Business rule: can only confirm payment once, and only from PENDING status.
     *
     * @param paymentId Mercado Pago payment ID
     */
    public void confirmPayment(String paymentId) {
        if (this.paymentStatus == PaymentStatus.PAID) {
            throw new DomainException("Payment already confirmed for booking " + bookingNumber);
        }

        if (this.status == BookingStatus.CANCELLED) {
            throw new DomainException("Cannot confirm payment for cancelled booking " + bookingNumber);
        }

        if (paymentId == null || paymentId.isBlank()) {
            throw new IllegalArgumentException("Payment ID cannot be empty");
        }

        this.mercadoPagoPaymentId = paymentId;
        this.paymentStatus = PaymentStatus.PAID;
        this.status = BookingStatus.CONFIRMED;
        this.confirmedAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Cancels this booking.
     * Business rule: cannot cancel already completed bookings, cannot cancel twice.
     */
    public void cancel() {
        if (this.status == BookingStatus.CANCELLED) {
            throw new DomainException("Booking " + bookingNumber + " is already cancelled");
        }

        if (this.status == BookingStatus.COMPLETED) {
            throw new DomainException("Cannot cancel completed booking " + bookingNumber);
        }

        this.status = BookingStatus.CANCELLED;
        this.cancelledAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Marks booking as completed (service was provided).
     * Business rule: can only complete confirmed bookings.
     */
    public void complete() {
        if (this.status != BookingStatus.CONFIRMED) {
            throw new DomainException("Can only complete confirmed bookings. Current status: " + status);
        }

        this.status = BookingStatus.COMPLETED;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Validates that the booking slot is available (business rule).
     *
     * @return true if slot is valid for booking
     */
    public boolean isSlotAvailable() {
        return timeSlot.isFuture() && status != BookingStatus.CANCELLED;
    }

    /**
     * Checks if this booking can be cancelled.
     */
    public boolean isCancellable() {
        return status != BookingStatus.CANCELLED && status != BookingStatus.COMPLETED;
    }

    /**
     * Reschedules this booking to a new date and time.
     * Business rule: cannot reschedule cancelled or completed bookings.
     *
     * @param newTimeSlot the new time slot (legacy)
     */
    public void reschedule(TimeSlot newTimeSlot) {
        if (this.status == BookingStatus.CANCELLED) {
            throw new DomainException("Cannot reschedule cancelled booking " + bookingNumber);
        }

        if (this.status == BookingStatus.COMPLETED) {
            throw new DomainException("Cannot reschedule completed booking " + bookingNumber);
        }

        if (newTimeSlot == null) {
            throw new IllegalArgumentException("New time slot cannot be null");
        }

        this.timeSlot = newTimeSlot;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Reschedules this booking to a new start time.
     * Business rule: cannot reschedule cancelled or completed bookings.
     * Start time must be aligned to 30-minute intervals.
     *
     * @param newStartAt the new start time
     */
    public void reschedule(OffsetDateTime newStartAt) {
        if (this.status == BookingStatus.CANCELLED) {
            throw new DomainException("Cannot reschedule cancelled booking " + bookingNumber);
        }

        if (this.status == BookingStatus.COMPLETED) {
            throw new DomainException("Cannot reschedule completed booking " + bookingNumber);
        }

        if (newStartAt == null) {
            throw new IllegalArgumentException("New start time cannot be null");
        }

        int minute = newStartAt.getMinute();
        if (minute != 0 && minute != 30) {
            throw new DomainException("Start time must be aligned to 30-minute intervals (:00 or :30)");
        }

        this.startAt = newStartAt;
        // Also update legacy timeSlot for compatibility
        if (this.timeSlot != null) {
            this.timeSlot = new TimeSlot(
                    newStartAt.toLocalDate(),
                    newStartAt.toLocalTime()
            );
        }
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Updates customer information.
     */
    public void updateCustomer(CustomerInfo newCustomerInfo) {
        if (newCustomerInfo == null) {
            throw new IllegalArgumentException("Customer info cannot be null");
        }
        this.customerInfo = newCustomerInfo;
        this.updatedAt = LocalDateTime.now();
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/domain/BookingRepository.java ==========
package com.flavia.dermobeauty.booking.domain;

import java.time.LocalDate;
import java.time.LocalTime;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Optional;

/**
 * Repository port (interface) for Booking aggregate.
 * Defines operations needed by the domain layer without specifying implementation.
 * Implementation will be provided by infrastructure layer.
 */
public interface BookingRepository {

    /**
     * Save a booking (create or update).
     */
    Booking save(Booking booking);

    /**
     * Find booking by ID.
     */
    Optional<Booking> findById(Long id);

    /**
     * Find booking by booking number.
     */
    Optional<Booking> findByBookingNumber(String bookingNumber);

    /**
     * Find booking by Mercado Pago payment ID.
     */
    Optional<Booking> findByMercadoPagoPaymentId(String paymentId);

    /**
     * Check if a slot is already booked for a service.
     * Returns true if there's an active (non-cancelled) booking for this slot.
     */
    boolean isTimeSlotAvailable(Long serviceId, LocalDate date, LocalTime startTime, LocalTime endTime);

    /**
     * Find all bookings (for admin).
     */
    List<Booking> findAll();

    /**
     * Find bookings by status (for admin filtering).
     */
    List<Booking> findByStatus(BookingStatus status);

    List<Booking> findByDate(LocalDate date);

    /**
     * Find bookings within a date range for calendar display.
     * @param from start of range (inclusive)
     * @param to end of range (inclusive)
     * @param includeCancelled if true, includes cancelled bookings
     * @return list of bookings in range
     */
    List<Booking> findByDateRange(OffsetDateTime from, OffsetDateTime to, boolean includeCancelled);

}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/domain/BookingStatus.java ==========
package com.flavia.dermobeauty.booking.domain;

/**
 * Domain enum representing the lifecycle status of a booking.
 * Note: BLOCKED status was removed - use the separate Block entity for schedule blocks.
 */
public enum BookingStatus {
    PENDING,    // Initial state, payment not yet completed
    CONFIRMED,  // Payment completed, booking confirmed
    CANCELLED,  // Booking cancelled (by admin or customer)
    COMPLETED   // Service was provided
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/domain/CustomerInfo.java ==========
package com.flavia.dermobeauty.booking.domain;

import lombok.Value;

/**
 * Value Object representing customer information for a booking.
 * Immutable to ensure consistency.
 */
@Value
public class CustomerInfo {
    String name;
    String email;
    String whatsapp;
    String comments;

    public CustomerInfo(String name, String email, String whatsapp, String comments) {
        if (name == null || name.isBlank()) {
            throw new IllegalArgumentException("Customer name cannot be empty");
        }
        if (email == null || email.isBlank()) {
            throw new IllegalArgumentException("Customer email cannot be empty");
        }
        if (whatsapp == null || whatsapp.isBlank()) {
            throw new IllegalArgumentException("Customer whatsapp cannot be empty");
        }

        this.name = name;
        this.email = email;
        this.whatsapp = whatsapp;
        this.comments = comments;
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/domain/HistoryActor.java ==========
package com.flavia.dermobeauty.booking.domain;

/**
 * Domain enum for who made a change in booking history.
 */
public enum HistoryActor {
    ADMIN,    // Change made by admin through admin panel
    SYSTEM,   // Change made by system (e.g., payment webhook)
    CUSTOMER  // Change made by customer through public interface
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/domain/HistoryEventType.java ==========
package com.flavia.dermobeauty.booking.domain;

/**
 * Domain enum for booking history event types.
 * Used to categorize changes in the audit trail.
 */
public enum HistoryEventType {
    CREATED,           // Booking was created
    STATUS_CHANGED,    // Status changed (PENDING -> CONFIRMED, etc.)
    RESCHEDULED,       // Booking was rescheduled to a new time
    CUSTOMER_UPDATED,  // Customer info was updated (name, whatsapp, comments)
    PAYMENT_UPDATED    // Payment status was updated
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/domain/PaymentStatus.java ==========
package com.flavia.dermobeauty.booking.domain;

/**
 * Domain enum representing the payment status of a booking.
 */
public enum PaymentStatus {
    PENDING,       // Payment not yet initiated or in progress
    PAID,          // Payment successfully completed
    FAILED,        // Payment failed
    REFUNDED,      // Payment was refunded
    NOT_REQUIRED   // No payment required (e.g., blocked time slots)
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/domain/TimeSlot.java ==========
package com.flavia.dermobeauty.booking.domain;

import lombok.Value;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;

/**
 * Value Object representing a specific date and time slot for a booking.
 * Immutable to ensure consistency.
 */
@Value
public class TimeSlot {
    LocalDate date;
    LocalTime time;

    public TimeSlot(LocalDate date, LocalTime time) {
        if (date == null) {
            throw new IllegalArgumentException("Date cannot be null");
        }
        if (time == null) {
            throw new IllegalArgumentException("Time cannot be null");
        }
        if (date.isBefore(LocalDate.now())) {
            throw new IllegalArgumentException("Cannot book appointments in the past");
        }

        this.date = date;
        this.time = time;
    }

    public LocalDateTime toDateTime() {
        return LocalDateTime.of(date, time);
    }

    public boolean isFuture() {
        return toDateTime().isAfter(LocalDateTime.now());
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/infrastructure/mapper/BlockMapper.java ==========
package com.flavia.dermobeauty.booking.infrastructure.mapper;

import com.flavia.dermobeauty.booking.domain.Block;
import com.flavia.dermobeauty.booking.infrastructure.persistence.BlockEntity;
import org.springframework.stereotype.Component;

/**
 * Mapper between Block domain entity and BlockEntity JPA entity.
 */
@Component
public class BlockMapper {

    /**
     * Converts a domain Block to a JPA BlockEntity.
     */
    public BlockEntity toEntity(Block block) {
        if (block == null) {
            return null;
        }

        return BlockEntity.builder()
                .id(block.getId())
                .blockNumber(block.getBlockNumber())
                .reason(block.getReason())
                .startAt(block.getStartAt())
                .endAt(block.getEndAt())
                .status(block.getStatus())
                .createdAt(block.getCreatedAt())
                .updatedAt(block.getUpdatedAt())
                .cancelledAt(block.getCancelledAt())
                .build();
    }

    /**
     * Converts a JPA BlockEntity to a domain Block.
     */
    public Block toDomain(BlockEntity entity) {
        if (entity == null) {
            return null;
        }

        return Block.builder()
                .id(entity.getId())
                .blockNumber(entity.getBlockNumber())
                .reason(entity.getReason())
                .startAt(entity.getStartAt())
                .endAt(entity.getEndAt())
                .status(entity.getStatus())
                .createdAt(entity.getCreatedAt())
                .updatedAt(entity.getUpdatedAt())
                .cancelledAt(entity.getCancelledAt())
                .build();
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/infrastructure/mapper/BookingHistoryMapper.java ==========
package com.flavia.dermobeauty.booking.infrastructure.mapper;

import com.flavia.dermobeauty.booking.domain.BookingHistory;
import com.flavia.dermobeauty.booking.infrastructure.persistence.BookingHistoryEntity;
import org.springframework.stereotype.Component;

/**
 * Mapper between BookingHistory domain entity and BookingHistoryEntity JPA entity.
 */
@Component
public class BookingHistoryMapper {

    /**
     * Converts a domain BookingHistory to a JPA BookingHistoryEntity.
     */
    public BookingHistoryEntity toEntity(BookingHistory history) {
        if (history == null) {
            return null;
        }

        return BookingHistoryEntity.builder()
                .id(history.getId())
                .bookingId(history.getBookingId())
                .eventType(history.getEventType())
                .actor(history.getActor())
                .payload(history.getPayload())
                .createdAt(history.getCreatedAt())
                .build();
    }

    /**
     * Converts a JPA BookingHistoryEntity to a domain BookingHistory.
     */
    public BookingHistory toDomain(BookingHistoryEntity entity) {
        if (entity == null) {
            return null;
        }

        return BookingHistory.builder()
                .id(entity.getId())
                .bookingId(entity.getBookingId())
                .eventType(entity.getEventType())
                .actor(entity.getActor())
                .payload(entity.getPayload())
                .createdAt(entity.getCreatedAt())
                .build();
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/infrastructure/mapper/BookingMapper.java ==========
package com.flavia.dermobeauty.booking.infrastructure.mapper;

import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.domain.CustomerInfo;
import com.flavia.dermobeauty.booking.domain.TimeSlot;
import com.flavia.dermobeauty.booking.infrastructure.persistence.BookingEntity;
import org.springframework.stereotype.Component;

/**
 * Mapper between Booking domain model and BookingEntity JPA entity.
 * Handles conversion in both directions.
 */
@Component
public class BookingMapper {

    /**
     * Convert domain Booking to JPA BookingEntity.
     */
    public BookingEntity toEntity(Booking booking) {
        return BookingEntity.builder()
                .id(booking.getId())
                .bookingNumber(booking.getBookingNumber())
                .serviceId(booking.getServiceId())
                .serviceName(booking.getServiceName())
                .customerName(booking.getCustomerInfo().getName())
                .customerEmail(booking.getCustomerInfo().getEmail())
                .customerWhatsapp(booking.getCustomerInfo().getWhatsapp())
                .customerComments(booking.getCustomerInfo().getComments())
                .bookingDate(booking.getTimeSlot().getDate())
                .bookingTime(booking.getTimeSlot().getTime())
                .startAt(booking.getStartAt())
                .durationMinutes(booking.getDurationMinutes())
                .status(booking.getStatus())
                .paymentStatus(booking.getPaymentStatus())
                .mercadoPagoPreferenceId(booking.getMercadoPagoPreferenceId())
                .mercadoPagoPaymentId(booking.getMercadoPagoPaymentId())
                .amount(booking.getAmount())
                .createdAt(booking.getCreatedAt())
                .updatedAt(booking.getUpdatedAt())
                .confirmedAt(booking.getConfirmedAt())
                .cancelledAt(booking.getCancelledAt())
                .build();
    }

    /**
     * Convert JPA BookingEntity to domain Booking.
     */
    public Booking toDomain(BookingEntity entity) {
        CustomerInfo customerInfo = new CustomerInfo(
                entity.getCustomerName(),
                entity.getCustomerEmail(),
                entity.getCustomerWhatsapp(),
                entity.getCustomerComments()
        );

        TimeSlot timeSlot = new TimeSlot(
                entity.getBookingDate(),
                entity.getBookingTime()
        );

        return Booking.builder()
                .id(entity.getId())
                .bookingNumber(entity.getBookingNumber())
                .serviceId(entity.getServiceId())
                .serviceName(entity.getServiceName())
                .customerInfo(customerInfo)
                .timeSlot(timeSlot)
                .startAt(entity.getStartAt())
                .durationMinutes(entity.getDurationMinutes())
                .status(entity.getStatus())
                .paymentStatus(entity.getPaymentStatus())
                .mercadoPagoPreferenceId(entity.getMercadoPagoPreferenceId())
                .mercadoPagoPaymentId(entity.getMercadoPagoPaymentId())
                .amount(entity.getAmount())
                .createdAt(entity.getCreatedAt())
                .updatedAt(entity.getUpdatedAt())
                .confirmedAt(entity.getConfirmedAt())
                .cancelledAt(entity.getCancelledAt())
                .build();
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/infrastructure/notification/StubNotificationService.java ==========
package com.flavia.dermobeauty.booking.infrastructure.notification;

import com.flavia.dermobeauty.booking.application.port.NotificationService;
import com.flavia.dermobeauty.booking.domain.Booking;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

/**
 * Stub implementation of NotificationService for Phase 5.
 * Will be replaced with full email implementation in Phase 8.
 */
@Slf4j
@Service
public class StubNotificationService implements NotificationService {

    @Override
    public void sendBookingConfirmation(Booking booking) {
        log.info("STUB: Would send booking confirmation email for {} to {}",
                booking.getBookingNumber(),
                booking.getCustomerInfo().getEmail());

        // No-op for now - will implement email sending in Phase 8
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/infrastructure/persistence/BlockEntity.java ==========
package com.flavia.dermobeauty.booking.infrastructure.persistence;

import com.flavia.dermobeauty.booking.domain.BlockStatus;
import jakarta.persistence.*;
import lombok.*;

import java.time.OffsetDateTime;

/**
 * JPA entity for blocks table.
 * Infrastructure layer representation of Block aggregate.
 */
@Entity
@Table(name = "blocks")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class BlockEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @EqualsAndHashCode.Include
    private Long id;

    @Column(name = "block_number", nullable = false, unique = true, length = 50)
    private String blockNumber;

    @Column(nullable = false, length = 500)
    private String reason;

    @Column(name = "start_at", nullable = false, columnDefinition = "TIMESTAMPTZ")
    private OffsetDateTime startAt;

    @Column(name = "end_at", nullable = false, columnDefinition = "TIMESTAMPTZ")
    private OffsetDateTime endAt;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private BlockStatus status;

    @Column(name = "created_at", nullable = false, updatable = false, columnDefinition = "TIMESTAMPTZ")
    private OffsetDateTime createdAt;

    @Column(name = "updated_at", nullable = false, columnDefinition = "TIMESTAMPTZ")
    private OffsetDateTime updatedAt;

    @Column(name = "cancelled_at", columnDefinition = "TIMESTAMPTZ")
    private OffsetDateTime cancelledAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = OffsetDateTime.now();
        }
        if (updatedAt == null) {
            updatedAt = OffsetDateTime.now();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = OffsetDateTime.now();
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/infrastructure/persistence/BlockRepositoryAdapter.java ==========
package com.flavia.dermobeauty.booking.infrastructure.persistence;

import com.flavia.dermobeauty.booking.domain.Block;
import com.flavia.dermobeauty.booking.domain.BlockRepository;
import com.flavia.dermobeauty.booking.infrastructure.mapper.BlockMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.time.OffsetDateTime;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Adapter implementing BlockRepository using JPA.
 */
@Component
@RequiredArgsConstructor
public class BlockRepositoryAdapter implements BlockRepository {

    private final JpaBlockRepository jpaRepository;
    private final BlockMapper mapper;

    @Override
    public Block save(Block block) {
        BlockEntity entity = mapper.toEntity(block);
        BlockEntity saved = jpaRepository.save(entity);
        return mapper.toDomain(saved);
    }

    @Override
    public Optional<Block> findById(Long id) {
        return jpaRepository.findById(id)
                .map(mapper::toDomain);
    }

    @Override
    public Optional<Block> findByBlockNumber(String blockNumber) {
        return jpaRepository.findByBlockNumber(blockNumber)
                .map(mapper::toDomain);
    }

    @Override
    public List<Block> findByDateRange(OffsetDateTime from, OffsetDateTime to, boolean includeCancelled) {
        return jpaRepository.findByDateRange(from, to, includeCancelled)
                .stream()
                .map(mapper::toDomain)
                .collect(Collectors.toList());
    }

    @Override
    public List<Block> findActiveBlocksInRange(OffsetDateTime startAt, OffsetDateTime endAt) {
        return jpaRepository.findActiveBlocksInRange(startAt, endAt)
                .stream()
                .map(mapper::toDomain)
                .collect(Collectors.toList());
    }

    @Override
    public boolean existsActiveBlockInRange(OffsetDateTime startAt, OffsetDateTime endAt) {
        return jpaRepository.existsActiveBlockInRange(startAt, endAt);
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/infrastructure/persistence/BookingEntity.java ==========
package com.flavia.dermobeauty.booking.infrastructure.persistence;

import com.flavia.dermobeauty.booking.domain.BookingStatus;
import com.flavia.dermobeauty.booking.domain.PaymentStatus;
import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.OffsetDateTime;

/**
 * JPA entity for bookings table.
 * Infrastructure layer representation of Booking aggregate.
 */
@Entity
@Table(name = "bookings")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class BookingEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @EqualsAndHashCode.Include
    private Long id;

    @Column(name = "booking_number", nullable = false, unique = true, length = 50)
    private String bookingNumber;

    @Column(name = "service_id", nullable = false)
    private Long serviceId;

    // Service name snapshot (immutable)
    @Column(name = "service_name", length = 200)
    private String serviceName;

    // Customer information (embedded fields)
    @Column(name = "customer_name", nullable = false, length = 200)
    private String customerName;

    @Column(name = "customer_email", nullable = false, length = 200)
    private String customerEmail;

    @Column(name = "customer_whatsapp", nullable = false, length = 50)
    private String customerWhatsapp;

    @Column(name = "customer_comments", columnDefinition = "TEXT")
    private String customerComments;

    // Time slot (legacy fields - kept for backward compatibility)
    @Column(name = "booking_date", nullable = false)
    private LocalDate bookingDate;

    @Column(name = "booking_time", nullable = false)
    private LocalTime bookingTime;

    // New datetime field with timezone
    @Column(name = "start_at", nullable = false, columnDefinition = "TIMESTAMPTZ")
    private OffsetDateTime startAt;

    @Column(name = "duration_minutes", nullable = false)
    private Integer durationMinutes;

    // Status tracking
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private BookingStatus status;

    // Payment information
    @Enumerated(EnumType.STRING)
    @Column(name = "payment_status", nullable = false, length = 20)
    private PaymentStatus paymentStatus;

    @Column(name = "mercadopago_preference_id", length = 200)
    private String mercadoPagoPreferenceId;

    @Column(name = "mercadopago_payment_id", length = 200)
    private String mercadoPagoPaymentId;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal amount;

    // Timestamps
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @Column(name = "confirmed_at")
    private LocalDateTime confirmedAt;

    @Column(name = "cancelled_at")
    private LocalDateTime cancelledAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = LocalDateTime.now();
        }
        if (updatedAt == null) {
            updatedAt = LocalDateTime.now();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/infrastructure/persistence/BookingHistoryEntity.java ==========
package com.flavia.dermobeauty.booking.infrastructure.persistence;

import com.flavia.dermobeauty.booking.domain.HistoryActor;
import com.flavia.dermobeauty.booking.domain.HistoryEventType;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;

import java.time.OffsetDateTime;
import java.util.Map;

/**
 * JPA entity for booking_history table.
 * Append-only: records are never modified or deleted.
 */
@Entity
@Table(name = "booking_history")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class BookingHistoryEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @EqualsAndHashCode.Include
    private Long id;

    @Column(name = "booking_id", nullable = false)
    private Long bookingId;

    @Enumerated(EnumType.STRING)
    @Column(name = "event_type", nullable = false, length = 30)
    private HistoryEventType eventType;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private HistoryActor actor;

    @JdbcTypeCode(SqlTypes.JSON)
    @Column(columnDefinition = "jsonb")
    private Map<String, Object> payload;

    @Column(name = "created_at", nullable = false, updatable = false, columnDefinition = "TIMESTAMPTZ")
    private OffsetDateTime createdAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = OffsetDateTime.now();
        }
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/infrastructure/persistence/BookingHistoryRepositoryAdapter.java ==========
package com.flavia.dermobeauty.booking.infrastructure.persistence;

import com.flavia.dermobeauty.booking.domain.BookingHistory;
import com.flavia.dermobeauty.booking.domain.BookingHistoryRepository;
import com.flavia.dermobeauty.booking.infrastructure.mapper.BookingHistoryMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Adapter implementing BookingHistoryRepository using JPA.
 */
@Component
@RequiredArgsConstructor
public class BookingHistoryRepositoryAdapter implements BookingHistoryRepository {

    private final JpaBookingHistoryRepository jpaRepository;
    private final BookingHistoryMapper mapper;

    @Override
    public BookingHistory save(BookingHistory history) {
        BookingHistoryEntity entity = mapper.toEntity(history);
        BookingHistoryEntity saved = jpaRepository.save(entity);
        return mapper.toDomain(saved);
    }

    @Override
    public List<BookingHistory> findByBookingId(Long bookingId) {
        return jpaRepository.findByBookingIdOrderByCreatedAtDesc(bookingId)
                .stream()
                .map(mapper::toDomain)
                .collect(Collectors.toList());
    }

    @Override
    public List<BookingHistory> findByBookingIdOrderByCreatedAtAsc(Long bookingId) {
        return jpaRepository.findByBookingIdOrderByCreatedAtAsc(bookingId)
                .stream()
                .map(mapper::toDomain)
                .collect(Collectors.toList());
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/infrastructure/persistence/BookingRepositoryAdapter.java ==========
package com.flavia.dermobeauty.booking.infrastructure.persistence;

import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.domain.BookingRepository;
import com.flavia.dermobeauty.booking.domain.BookingStatus;
import com.flavia.dermobeauty.booking.infrastructure.mapper.BookingMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.time.LocalDate;
import java.time.LocalTime;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Adapter that implements the domain BookingRepository port using JPA.
 * Bridges between domain layer and infrastructure layer.
 */
@Component
@RequiredArgsConstructor
public class BookingRepositoryAdapter implements BookingRepository {

    private final JpaBookingRepository jpaRepository;
    private final BookingMapper mapper;

    @Override
    public Booking save(Booking booking) {
        BookingEntity entity = mapper.toEntity(booking);
        BookingEntity saved = jpaRepository.save(entity);
        return mapper.toDomain(saved);
    }

    @Override
    public Optional<Booking> findById(Long id) {
        return jpaRepository.findById(id)
                .map(mapper::toDomain);
    }

    @Override
    public List<Booking> findByDate(LocalDate date) {
        // Buscamos por fecha y excluimos los CANCELLED
        return jpaRepository.findByBookingDateAndStatusNot(date, BookingStatus.CANCELLED)
                .stream()
                .map(mapper::toDomain)
                .collect(Collectors.toList());
    }

    @Override
    public Optional<Booking> findByBookingNumber(String bookingNumber) {
        return jpaRepository.findByBookingNumber(bookingNumber)
                .map(mapper::toDomain);
    }

    @Override
    public Optional<Booking> findByMercadoPagoPaymentId(String paymentId) {
        return jpaRepository.findByMercadoPagoPaymentId(paymentId)
                .map(mapper::toDomain);
    }

    @Override
    public boolean isTimeSlotAvailable(Long serviceId, LocalDate date, LocalTime startTime, LocalTime endTime) {
        return !jpaRepository.existsOverlappingBooking(serviceId, date, startTime, endTime);
    }

    @Override
    public List<Booking> findAll() {
        return jpaRepository.findAll()
                .stream()
                .map(mapper::toDomain)
                .collect(Collectors.toList());
    }

    @Override
    public List<Booking> findByStatus(BookingStatus status) {
        return jpaRepository.findByStatus(status)
                .stream()
                .map(mapper::toDomain)
                .collect(Collectors.toList());
    }

    @Override
    public List<Booking> findByDateRange(OffsetDateTime from, OffsetDateTime to, boolean includeCancelled) {
        List<BookingEntity> entities = includeCancelled
                ? jpaRepository.findByDateRangeAll(from, to)
                : jpaRepository.findByDateRangeExcludingCancelled(from, to);

        return entities.stream()
                .map(mapper::toDomain)
                .collect(Collectors.toList());
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/infrastructure/persistence/JpaBlockRepository.java ==========
package com.flavia.dermobeauty.booking.infrastructure.persistence;

import com.flavia.dermobeauty.booking.domain.BlockStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.OffsetDateTime;
import java.util.List;
import java.util.Optional;

/**
 * Spring Data JPA repository for BlockEntity.
 */
@Repository
public interface JpaBlockRepository extends JpaRepository<BlockEntity, Long> {

    Optional<BlockEntity> findByBlockNumber(String blockNumber);

    /**
     * Find blocks in a date range, optionally including cancelled.
     */
    @Query("SELECT b FROM BlockEntity b WHERE " +
            "b.startAt < :to AND b.endAt > :from " +
            "AND (:includeCancelled = true OR b.status != 'CANCELLED') " +
            "ORDER BY b.startAt ASC")
    List<BlockEntity> findByDateRange(
            @Param("from") OffsetDateTime from,
            @Param("to") OffsetDateTime to,
            @Param("includeCancelled") boolean includeCancelled);

    /**
     * Find active blocks that overlap with a time range.
     */
    @Query("SELECT b FROM BlockEntity b WHERE " +
            "b.status = 'ACTIVE' " +
            "AND b.startAt < :endAt AND b.endAt > :startAt")
    List<BlockEntity> findActiveBlocksInRange(
            @Param("startAt") OffsetDateTime startAt,
            @Param("endAt") OffsetDateTime endAt);

    /**
     * Check if any active block exists in a time range.
     */
    @Query("SELECT COUNT(b) > 0 FROM BlockEntity b WHERE " +
            "b.status = 'ACTIVE' " +
            "AND b.startAt < :endAt AND b.endAt > :startAt")
    boolean existsActiveBlockInRange(
            @Param("startAt") OffsetDateTime startAt,
            @Param("endAt") OffsetDateTime endAt);
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/infrastructure/persistence/JpaBookingHistoryRepository.java ==========
package com.flavia.dermobeauty.booking.infrastructure.persistence;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

/**
 * Spring Data JPA repository for BookingHistoryEntity.
 */
@Repository
public interface JpaBookingHistoryRepository extends JpaRepository<BookingHistoryEntity, Long> {

    /**
     * Find all history entries for a booking, newest first.
     */
    List<BookingHistoryEntity> findByBookingIdOrderByCreatedAtDesc(Long bookingId);

    /**
     * Find all history entries for a booking, oldest first.
     */
    List<BookingHistoryEntity> findByBookingIdOrderByCreatedAtAsc(Long bookingId);
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/infrastructure/persistence/JpaBookingRepository.java ==========
package com.flavia.dermobeauty.booking.infrastructure.persistence;

import com.flavia.dermobeauty.booking.domain.BookingStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDate;
import java.time.LocalTime;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Optional;

/**
 * Spring Data JPA repository for BookingEntity.
 * Infrastructure implementation detail.
 */
@Repository
public interface JpaBookingRepository extends JpaRepository<BookingEntity, Long> {

    Optional<BookingEntity> findByBookingNumber(String bookingNumber);

    Optional<BookingEntity> findByMercadoPagoPaymentId(String paymentId);

    List<BookingEntity> findByStatus(BookingStatus status);

    List<BookingEntity> findByBookingDateAndStatusNot(LocalDate bookingDate, BookingStatus status);

    // Un turno se solapa si: (StartA < EndB) y (StartB < EndA)
    @Query(value = """
           SELECT CASE WHEN COUNT(*) > 0 THEN true ELSE false END
           FROM bookings b
           WHERE b.service_id = :serviceId
           AND b.booking_date = :date
           AND b.status != 'CANCELLED'
           AND (
               b.booking_time < :endTime
               AND :startTime < (b.booking_time + (b.duration_minutes * interval '1 minute'))
           )
           """, nativeQuery = true)
    boolean existsOverlappingBooking(
            @Param("serviceId") Long serviceId,
            @Param("date") LocalDate date,
            @Param("startTime") LocalTime startTime,
            @Param("endTime") LocalTime endTime
    );

    /**
     * Find bookings in date range, excluding cancelled.
     */
    @Query("SELECT b FROM BookingEntity b WHERE b.startAt >= :from AND b.startAt <= :to AND b.status != 'CANCELLED' ORDER BY b.startAt")
    List<BookingEntity> findByDateRangeExcludingCancelled(
            @Param("from") OffsetDateTime from,
            @Param("to") OffsetDateTime to
    );

    /**
     * Find all bookings in date range, including cancelled.
     */
    @Query("SELECT b FROM BookingEntity b WHERE b.startAt >= :from AND b.startAt <= :to ORDER BY b.startAt")
    List<BookingEntity> findByDateRangeAll(
            @Param("from") OffsetDateTime from,
            @Param("to") OffsetDateTime to
    );
}

========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/web/AdminCalendarController.java ==========
package com.flavia.dermobeauty.booking.web;

import com.flavia.dermobeauty.booking.application.service.BookingHistoryService;
import com.flavia.dermobeauty.booking.application.usecase.CancelBlockUseCase;
import com.flavia.dermobeauty.booking.application.usecase.CreateBlockUseCase;
import com.flavia.dermobeauty.booking.application.usecase.GetCalendarEventsUseCase;
import com.flavia.dermobeauty.booking.application.usecase.RescheduleBookingUseCase;
import com.flavia.dermobeauty.booking.application.usecase.UpdateBookingCustomerUseCase;
import com.flavia.dermobeauty.booking.domain.Block;
import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.domain.BookingHistory;
import com.flavia.dermobeauty.booking.web.dto.BlockResponse;
import com.flavia.dermobeauty.booking.web.dto.BookingHistoryResponse;
import com.flavia.dermobeauty.booking.web.dto.BookingResponse;
import com.flavia.dermobeauty.booking.web.dto.CalendarEventResponse;
import com.flavia.dermobeauty.booking.web.dto.CreateBlockRequest;
import com.flavia.dermobeauty.booking.web.dto.RescheduleBookingRequest;
import com.flavia.dermobeauty.booking.web.dto.UpdateCustomerRequest;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.util.List;

/**
 * Admin controller for calendar operations.
 * Provides unified view of bookings and blocks, plus management actions.
 */
@Slf4j
@RestController
@RequestMapping("/api/admin")
@RequiredArgsConstructor
public class AdminCalendarController {

    private final GetCalendarEventsUseCase getCalendarEventsUseCase;
    private final CreateBlockUseCase createBlockUseCase;
    private final CancelBlockUseCase cancelBlockUseCase;
    private final RescheduleBookingUseCase rescheduleBookingUseCase;
    private final UpdateBookingCustomerUseCase updateBookingCustomerUseCase;
    private final BookingHistoryService bookingHistoryService;

    // ==================== CALENDAR ====================

    /**
     * Get calendar events for a date range.
     *
     * @param from start date (required)
     * @param to end date (required, inclusive)
     * @param includeCancelled if true, includes cancelled events (default: false)
     * @return list of calendar events (bookings + blocks merged)
     */
    @GetMapping("/calendar")
    public ResponseEntity<ApiResponse<List<CalendarEventResponse>>> getCalendarEvents(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate from,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate to,
            @RequestParam(defaultValue = "false") boolean includeCancelled) {

        log.info("GET /api/admin/calendar from={} to={} includeCancelled={}", from, to, includeCancelled);

        List<CalendarEventResponse> events = getCalendarEventsUseCase.execute(from, to, includeCancelled);

        return ResponseEntity.ok(ApiResponse.success(events));
    }

    // ==================== BLOCKS ====================

    /**
     * Create a new block.
     *
     * @param request block creation request
     * @return the created block
     */
    @PostMapping("/blocks")
    public ResponseEntity<ApiResponse<BlockResponse>> createBlock(
            @Valid @RequestBody CreateBlockRequest request) {

        log.info("POST /api/admin/blocks startAt={} endAt={} reason={}",
                request.getStartAt(), request.getEndAt(), request.getReason());

        Block block = createBlockUseCase.execute(
                request.getStartAt(),
                request.getEndAt(),
                request.getReason()
        );

        BlockResponse response = BlockResponse.fromDomain(block);
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.success(response, "Bloqueo creado exitosamente"));
    }

    /**
     * Cancel a block.
     *
     * @param id block ID
     * @return the cancelled block
     */
    @PatchMapping("/blocks/{id}/cancel")
    public ResponseEntity<ApiResponse<BlockResponse>> cancelBlock(@PathVariable Long id) {

        log.info("PATCH /api/admin/blocks/{}/cancel", id);

        Block block = cancelBlockUseCase.execute(id);

        BlockResponse response = BlockResponse.fromDomain(block);
        return ResponseEntity.ok(ApiResponse.success(response, "Bloqueo cancelado exitosamente"));
    }

    // ==================== BOOKINGS ====================

    /**
     * Reschedule a booking to a new time.
     *
     * @param id booking ID
     * @param request reschedule request with new start time
     * @return the rescheduled booking
     */
    @PatchMapping("/bookings/{id}/reschedule")
    public ResponseEntity<ApiResponse<BookingResponse>> rescheduleBooking(
            @PathVariable Long id,
            @Valid @RequestBody RescheduleBookingRequest request) {

        log.info("PATCH /api/admin/bookings/{}/reschedule newStartAt={}", id, request.getNewStartAt());

        Booking booking = rescheduleBookingUseCase.execute(id, request.getNewStartAt());

        BookingResponse response = BookingResponse.fromDomain(booking);
        return ResponseEntity.ok(ApiResponse.success(response, "Turno reprogramado exitosamente"));
    }

    /**
     * Update customer information on a booking.
     *
     * @param id booking ID
     * @param request customer info update request
     * @return the updated booking
     */
    @PatchMapping("/bookings/{id}/customer")
    public ResponseEntity<ApiResponse<BookingResponse>> updateBookingCustomer(
            @PathVariable Long id,
            @Valid @RequestBody UpdateCustomerRequest request) {

        log.info("PATCH /api/admin/bookings/{}/customer", id);

        Booking booking = updateBookingCustomerUseCase.execute(
                id,
                request.getName(),
                request.getEmail(),
                request.getWhatsapp(),
                request.getComments()
        );

        BookingResponse response = BookingResponse.fromDomain(booking);
        return ResponseEntity.ok(ApiResponse.success(response, "Información del cliente actualizada"));
    }

    /**
     * Get history for a booking.
     *
     * @param id booking ID
     * @return list of history entries ordered by createdAt ascending
     */
    @GetMapping("/bookings/{id}/history")
    public ResponseEntity<ApiResponse<List<BookingHistoryResponse>>> getBookingHistory(
            @PathVariable Long id) {

        log.info("GET /api/admin/bookings/{}/history", id);

        List<BookingHistory> history = bookingHistoryService.getHistoryForBooking(id);
        List<BookingHistoryResponse> response = history.stream()
                .map(BookingHistoryResponse::fromDomain)
                .toList();

        return ResponseEntity.ok(ApiResponse.success(response));
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/web/AvailabilityController.java ==========
package com.flavia.dermobeauty.booking.web;

import com.flavia.dermobeauty.booking.application.usecase.GetAvailableSlotsUseCase;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.List;

@RestController
@RequestMapping("/api/public/availability")
@RequiredArgsConstructor
public class AvailabilityController {

    private final GetAvailableSlotsUseCase getAvailableSlotsUseCase;

    @GetMapping
    public ResponseEntity<ApiResponse<List<LocalTime>>> getAvailability(
            @RequestParam Long serviceId,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate date) {

        List<LocalTime> slots = getAvailableSlotsUseCase.execute(serviceId, date);
        return ResponseEntity.ok(ApiResponse.success(slots));
    }
}

========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/web/BookingController.java ==========
package com.flavia.dermobeauty.booking.web;

import com.flavia.dermobeauty.booking.application.usecase.CreateBookingUseCase;
import com.flavia.dermobeauty.booking.application.usecase.GetBookingByNumberUseCase;
import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.web.dto.BookingResponse;
import com.flavia.dermobeauty.booking.web.dto.CreateBookingRequest;
import com.flavia.dermobeauty.catalog.dto.ServiceDto;
import com.flavia.dermobeauty.catalog.service.ServiceCatalogService;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

/**
 * REST controller for booking operations.
 * Public endpoints for customers to create and check bookings.
 */
@Slf4j
@RestController
@RequestMapping("/api/public/bookings")
@RequiredArgsConstructor
public class BookingController {

    private final CreateBookingUseCase createBookingUseCase;
    private final GetBookingByNumberUseCase getBookingByNumberUseCase;
    private final ServiceCatalogService serviceCatalogService;

    @PostMapping
    public ResponseEntity<ApiResponse<BookingResponse>> createBooking(
            @Valid @RequestBody CreateBookingRequest request) {

        log.info("Creating booking for service {} on {} at {}",
                request.getServiceId(), request.getBookingDate(), request.getBookingTime());

        // Fetch service to get the name snapshot
        ServiceDto service = serviceCatalogService.getById(request.getServiceId());

        Booking booking = createBookingUseCase.execute(
                request.getServiceId(),
                service.getName(),
                request.getCustomerName(),
                request.getCustomerEmail(),
                request.getCustomerWhatsapp(),
                request.getCustomerComments(),
                request.getBookingDate(),
                request.getBookingTime(),
                request.getDurationMinutes(),
                request.getAmount()
        );

        BookingResponse response = BookingResponse.fromDomain(booking);
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.success(response, "Booking created successfully"));
    }

    @GetMapping("/{bookingNumber}")
    public ResponseEntity<ApiResponse<BookingResponse>> getBookingByNumber(
            @PathVariable String bookingNumber) {

        log.debug("Fetching booking: {}", bookingNumber);

        Booking booking = getBookingByNumberUseCase.execute(bookingNumber);
        BookingResponse response = BookingResponse.fromDomain(booking);

        return ResponseEntity.ok(ApiResponse.success(response));
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/web/dto/BlockResponse.java ==========
package com.flavia.dermobeauty.booking.web.dto;

import com.flavia.dermobeauty.booking.domain.Block;
import com.flavia.dermobeauty.booking.domain.BlockStatus;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.OffsetDateTime;

/**
 * Response DTO for block operations.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class BlockResponse {

    private Long id;
    private String blockNumber;
    private OffsetDateTime startAt;
    private OffsetDateTime endAt;
    private String reason;
    private BlockStatus status;
    private OffsetDateTime createdAt;
    private OffsetDateTime cancelledAt;

    public static BlockResponse fromDomain(Block block) {
        return BlockResponse.builder()
                .id(block.getId())
                .blockNumber(block.getBlockNumber())
                .startAt(block.getStartAt())
                .endAt(block.getEndAt())
                .reason(block.getReason())
                .status(block.getStatus())
                .createdAt(block.getCreatedAt())
                .cancelledAt(block.getCancelledAt())
                .build();
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/web/dto/BookingHistoryResponse.java ==========
package com.flavia.dermobeauty.booking.web.dto;

import com.flavia.dermobeauty.booking.domain.BookingHistory;
import com.flavia.dermobeauty.booking.domain.HistoryActor;
import com.flavia.dermobeauty.booking.domain.HistoryEventType;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.OffsetDateTime;
import java.util.Map;

/**
 * Response DTO for booking history entries.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class BookingHistoryResponse {

    private Long id;
    private Long bookingId;
    private HistoryEventType eventType;
    private Map<String, Object> payload;
    private HistoryActor actor;
    private OffsetDateTime createdAt;

    public static BookingHistoryResponse fromDomain(BookingHistory history) {
        return BookingHistoryResponse.builder()
                .id(history.getId())
                .bookingId(history.getBookingId())
                .eventType(history.getEventType())
                .payload(history.getPayload())
                .actor(history.getActor())
                .createdAt(history.getCreatedAt())
                .build();
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/web/dto/BookingResponse.java ==========
package com.flavia.dermobeauty.booking.web.dto;

import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.domain.BookingStatus;
import com.flavia.dermobeauty.booking.domain.PaymentStatus;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.OffsetDateTime;

/**
 * DTO for booking response.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class BookingResponse {

    private Long id;
    private String bookingNumber;
    private Long serviceId;
    private String serviceName;
    private String customerName;
    private String customerEmail;
    private String customerWhatsapp;
    private String customerComments;
    private LocalDate bookingDate;
    private LocalTime bookingTime;
    private OffsetDateTime startAt;
    private OffsetDateTime endAt;
    private Integer durationMinutes;
    private BookingStatus status;
    private PaymentStatus paymentStatus;
    private String mercadoPagoPreferenceId;
    private BigDecimal amount;
    private LocalDateTime createdAt;
    private LocalDateTime confirmedAt;

    public static BookingResponse fromDomain(Booking booking) {
        return BookingResponse.builder()
                .id(booking.getId())
                .bookingNumber(booking.getBookingNumber())
                .serviceId(booking.getServiceId())
                .serviceName(booking.getServiceName())
                .customerName(booking.getCustomerInfo().getName())
                .customerEmail(booking.getCustomerInfo().getEmail())
                .customerWhatsapp(booking.getCustomerInfo().getWhatsapp())
                .customerComments(booking.getCustomerInfo().getComments())
                .bookingDate(booking.getTimeSlot().getDate())
                .bookingTime(booking.getTimeSlot().getTime())
                .startAt(booking.getStartAt())
                .endAt(booking.getEndAt())
                .durationMinutes(booking.getDurationMinutes())
                .status(booking.getStatus())
                .paymentStatus(booking.getPaymentStatus())
                .mercadoPagoPreferenceId(booking.getMercadoPagoPreferenceId())
                .amount(booking.getAmount())
                .createdAt(booking.getCreatedAt())
                .confirmedAt(booking.getConfirmedAt())
                .build();
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/web/dto/CalendarEventResponse.java ==========
package com.flavia.dermobeauty.booking.web.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.flavia.dermobeauty.booking.domain.Block;
import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.domain.PaymentStatus;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.OffsetDateTime;

/**
 * Unified calendar event response.
 * Discriminated union: type determines which fields are present.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
public class CalendarEventResponse {

    public enum EventType {
        BOOKING,
        BLOCK
    }

    private EventType type;
    private Long id;
    private OffsetDateTime startAt;
    private OffsetDateTime endAt;
    private String status;

    // Booking-only fields
    private String bookingNumber;
    private String serviceName;
    private String customerName;
    private PaymentStatus paymentStatus;

    // Block-only fields
    private String blockNumber;
    private String reason;

    /**
     * Create CalendarEventResponse from Booking domain.
     */
    public static CalendarEventResponse fromBooking(Booking booking) {
        return CalendarEventResponse.builder()
                .type(EventType.BOOKING)
                .id(booking.getId())
                .startAt(booking.getStartAt())
                .endAt(booking.getEndAt())
                .status(booking.getStatus().name())
                .bookingNumber(booking.getBookingNumber())
                .serviceName(booking.getServiceName())
                .customerName(booking.getCustomerInfo().getName())
                .paymentStatus(booking.getPaymentStatus())
                .build();
    }

    /**
     * Create CalendarEventResponse from Block domain.
     */
    public static CalendarEventResponse fromBlock(Block block) {
        return CalendarEventResponse.builder()
                .type(EventType.BLOCK)
                .id(block.getId())
                .startAt(block.getStartAt())
                .endAt(block.getEndAt())
                .status(block.getStatus().name())
                .blockNumber(block.getBlockNumber())
                .reason(block.getReason())
                .build();
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/web/dto/CreateBlockRequest.java ==========
package com.flavia.dermobeauty.booking.web.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.OffsetDateTime;

/**
 * Request DTO for creating a block.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateBlockRequest {

    @NotNull(message = "La hora de inicio es requerida")
    private OffsetDateTime startAt;

    @NotNull(message = "La hora de fin es requerida")
    private OffsetDateTime endAt;

    @NotBlank(message = "El motivo del bloqueo es requerido")
    private String reason;
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/web/dto/CreateBookingRequest.java ==========
package com.flavia.dermobeauty.booking.web.dto;

import jakarta.validation.constraints.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalTime;

/**
 * DTO for creating a new booking request.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateBookingRequest {

    @NotNull(message = "Service ID is required")
    private Long serviceId;

    @NotBlank(message = "Customer name is required")
    private String customerName;

    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    private String customerEmail;

    @NotBlank(message = "WhatsApp number is required")
    private String customerWhatsapp;

    private String customerComments;

    @NotNull(message = "Booking date is required")
    @Future(message = "Booking date must be in the future")
    private LocalDate bookingDate;

    @NotNull(message = "Booking time is required")
    private LocalTime bookingTime;

    @NotNull(message = "Duration is required")
    @Min(value = 1, message = "Duration must be at least 1 minute")
    private Integer durationMinutes;

    @NotNull(message = "Amount is required")
    @DecimalMin(value = "0.0", inclusive = false, message = "Amount must be greater than 0")
    private BigDecimal amount;
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/web/dto/RescheduleBookingRequest.java ==========
package com.flavia.dermobeauty.booking.web.dto;

import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.OffsetDateTime;

/**
 * Request DTO for rescheduling a booking.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class RescheduleBookingRequest {

    @NotNull(message = "La nueva hora de inicio es requerida")
    private OffsetDateTime newStartAt;
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/booking/web/dto/UpdateCustomerRequest.java ==========
package com.flavia.dermobeauty.booking.web.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Request DTO for updating customer information on a booking.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class UpdateCustomerRequest {

    @NotBlank(message = "El nombre del cliente es requerido")
    private String name;

    @NotBlank(message = "El email es requerido")
    @Email(message = "El email no tiene un formato válido")
    private String email;

    @NotBlank(message = "El WhatsApp es requerido")
    private String whatsapp;

    private String comments;
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/controller/AdminCatalogController.java ==========
package com.flavia.dermobeauty.catalog.controller;

import com.flavia.dermobeauty.catalog.dto.CategoryDto;
import com.flavia.dermobeauty.catalog.dto.ProductDto;
import com.flavia.dermobeauty.catalog.dto.ServiceDto;
import com.flavia.dermobeauty.catalog.entity.CategoryEntity;
import com.flavia.dermobeauty.catalog.repository.CategoryRepository;
import com.flavia.dermobeauty.catalog.service.ProductCatalogService;
import com.flavia.dermobeauty.catalog.service.ServiceCatalogService;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

@Slf4j
@RestController
@RequestMapping("/api/admin")
@RequiredArgsConstructor
public class AdminCatalogController {

    private final ServiceCatalogService serviceService;
    private final ProductCatalogService productService;
    private final CategoryRepository categoryRepository;

    // ==================== SERVICES ====================

    @GetMapping("/services")
    public ResponseEntity<ApiResponse<List<ServiceDto>>> getAllServices() {
        return ResponseEntity.ok(ApiResponse.success(serviceService.getAllForAdmin()));
    }

    @GetMapping("/services/{id}")
    public ResponseEntity<ApiResponse<ServiceDto>> getService(@PathVariable Long id) {
        return ResponseEntity.ok(ApiResponse.success(serviceService.getById(id)));
    }

    @PostMapping("/services")
    public ResponseEntity<ApiResponse<ServiceDto>> createService(@Valid @RequestBody ServiceDto dto) {
        return ResponseEntity.ok(ApiResponse.success(serviceService.create(dto), "Servicio creado"));
    }

    @PutMapping("/services/{id}")
    public ResponseEntity<ApiResponse<ServiceDto>> updateService(@PathVariable Long id, @Valid @RequestBody ServiceDto dto) {
        return ResponseEntity.ok(ApiResponse.success(serviceService.update(id, dto), "Servicio actualizado"));
    }

    @DeleteMapping("/services/{id}")
    public ResponseEntity<ApiResponse<Void>> deleteService(@PathVariable Long id) {
        serviceService.delete(id);
        return ResponseEntity.ok(ApiResponse.success("Servicio eliminado"));
    }

    @PatchMapping("/services/{id}/featured")
    public ResponseEntity<ApiResponse<ServiceDto>> toggleServiceFeatured(@PathVariable Long id) {
        // Obtenemos actual, invertimos flag y guardamos
        ServiceDto current = serviceService.getById(id);
        current.setIsFeatured(!current.getIsFeatured());
        return ResponseEntity.ok(ApiResponse.success(serviceService.update(id, current)));
    }

    // ==================== PRODUCTS ====================

    @GetMapping("/products")
    public ResponseEntity<ApiResponse<Page<ProductDto>>> getAllProducts(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {
        Pageable pageable = PageRequest.of(page, size, Sort.by("id").descending());
        Page<ProductDto> products = productService.getAllForAdminPaginated(pageable);
        return ResponseEntity.ok(ApiResponse.success(products));
    }

    @GetMapping("/products/{id}")
    public ResponseEntity<ApiResponse<ProductDto>> getProduct(@PathVariable Long id) {
        return ResponseEntity.ok(ApiResponse.success(productService.getById(id)));
    }

    @PostMapping("/products")
    public ResponseEntity<ApiResponse<ProductDto>> createProduct(@Valid @RequestBody ProductDto dto) {
        return ResponseEntity.ok(ApiResponse.success(productService.create(dto), "Producto creado"));
    }

    @PutMapping("/products/{id}")
    public ResponseEntity<ApiResponse<ProductDto>> updateProduct(@PathVariable Long id, @Valid @RequestBody ProductDto dto) {
        return ResponseEntity.ok(ApiResponse.success(productService.update(id, dto), "Producto actualizado"));
    }

    @DeleteMapping("/products/{id}")
    public ResponseEntity<ApiResponse<Void>> deleteProduct(@PathVariable Long id) {
        productService.delete(id);
        return ResponseEntity.ok(ApiResponse.success("Producto eliminado"));
    }

    @PatchMapping("/products/{id}/featured")
    public ResponseEntity<ApiResponse<ProductDto>> toggleProductFeatured(@PathVariable Long id) {
        ProductDto current = productService.getById(id);
        current.setIsFeatured(!current.getIsFeatured());
        return ResponseEntity.ok(ApiResponse.success(productService.update(id, current)));
    }

    // ==================== CATEGORIES ====================

    @GetMapping("/categories")
    public ResponseEntity<ApiResponse<List<CategoryDto>>> getAllCategories() {
        List<CategoryDto> categories = categoryRepository.findAll().stream()
                .map(CategoryDto::fromEntity)
                .collect(Collectors.toList());
        return ResponseEntity.ok(ApiResponse.success(categories));
    }

    @PostMapping("/categories")
    public ResponseEntity<ApiResponse<CategoryDto>> createCategory(@RequestBody CategoryEntity category) {
        // Simplificación: Guardamos directo la entidad (mejorar con DTO/Service en futuro)
        // Generar slug simple
        category.setSlug(category.getName().toLowerCase().replace(" ", "-"));
        CategoryEntity saved = categoryRepository.save(category);
        return ResponseEntity.ok(ApiResponse.success(CategoryDto.fromEntity(saved)));
    }

    @DeleteMapping("/categories/{id}")
    public ResponseEntity<ApiResponse<Void>> deleteCategory(@PathVariable Long id) {
        categoryRepository.deleteById(id);
        return ResponseEntity.ok(ApiResponse.success("Categoría eliminada"));
    }
}

========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/controller/CategoryController.java ==========
package com.flavia.dermobeauty.catalog.controller;

import com.flavia.dermobeauty.catalog.dto.CategoryDto;
import com.flavia.dermobeauty.catalog.entity.CategoryEntity;
import com.flavia.dermobeauty.catalog.repository.CategoryRepository;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Public REST controller for category operations.
 * Provides endpoints for browsing categories.
 */
@RestController
@RequestMapping("/api/public/categories")
@RequiredArgsConstructor
public class CategoryController {

    private final CategoryRepository categoryRepository;

    @GetMapping
    public ResponseEntity<ApiResponse<List<CategoryDto>>> getAllCategories() {
        List<CategoryDto> categories = categoryRepository.findAll()
                .stream()
                .map(CategoryDto::fromEntity)
                .collect(Collectors.toList());
        return ResponseEntity.ok(ApiResponse.success(categories));
    }

    @GetMapping("/type/{type}")
    public ResponseEntity<ApiResponse<List<CategoryDto>>> getCategoriesByType(@PathVariable CategoryEntity.CategoryType type) {
        List<CategoryDto> categories = categoryRepository.findByType(type)
                .stream()
                .map(CategoryDto::fromEntity)
                .collect(Collectors.toList());
        return ResponseEntity.ok(ApiResponse.success(categories));
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/controller/FileUploadController.java ==========
package com.flavia.dermobeauty.catalog.controller;

import com.flavia.dermobeauty.shared.exception.ValidationException;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.net.MalformedURLException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;

/**
 * Controller for file upload and retrieval.
 * Handles image uploads for services and products.
 */
@Slf4j
@RestController
@RequestMapping("/api")
public class FileUploadController {

    private static final List<String> ALLOWED_CONTENT_TYPES = Arrays.asList(
            "image/jpeg", "image/jpg", "image/png", "image/webp"
    );
    private static final long MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB

    private final Path uploadPath;

    public FileUploadController(@Value("${app.upload-dir}") String uploadDir) {
        this.uploadPath = Paths.get(uploadDir).toAbsolutePath().normalize();
        try {
            Files.createDirectories(this.uploadPath);
            log.info("Upload directory created at: {}", this.uploadPath);
        } catch (IOException e) {
            throw new RuntimeException("Could not create upload directory", e);
        }
    }

    @PostMapping("/admin/uploads")
    public ResponseEntity<ApiResponse<String>> uploadFile(@RequestParam("file") MultipartFile file) {
        validateFile(file);

        try {
            String originalFilename = file.getOriginalFilename();
            String extension = originalFilename != null && originalFilename.contains(".")
                    ? originalFilename.substring(originalFilename.lastIndexOf("."))
                    : ".jpg";

            String filename = UUID.randomUUID().toString() + extension;
            Path targetLocation = uploadPath.resolve(filename);

            Files.copy(file.getInputStream(), targetLocation, StandardCopyOption.REPLACE_EXISTING);
            log.info("File uploaded successfully: {}", filename);

            String fileUrl = "/api/uploads/" + filename;
            return ResponseEntity.ok(ApiResponse.success(fileUrl, "File uploaded successfully"));

        } catch (IOException e) {
            log.error("Failed to upload file", e);
            throw new ValidationException("Failed to upload file: " + e.getMessage());
        }
    }

    @GetMapping("/uploads/{filename:.+}")
    public ResponseEntity<Resource> getFile(@PathVariable String filename) {
        try {
            Path filePath = uploadPath.resolve(filename).normalize();
            Resource resource = new UrlResource(filePath.toUri());

            if (!resource.exists() || !resource.isReadable()) {
                throw new ValidationException("File not found: " + filename);
            }

            // Try to detect content type from file
            String contentType = Files.probeContentType(filePath);

            // Fallback: detect from file extension if probeContentType fails
            if (contentType == null) {
                String lowercaseFilename = filename.toLowerCase();
                if (lowercaseFilename.endsWith(".jpg") || lowercaseFilename.endsWith(".jpeg")) {
                    contentType = "image/jpeg";
                } else if (lowercaseFilename.endsWith(".png")) {
                    contentType = "image/png";
                } else if (lowercaseFilename.endsWith(".webp")) {
                    contentType = "image/webp";
                } else {
                    contentType = "application/octet-stream";
                }
            }

            return ResponseEntity.ok()
                    .contentType(MediaType.parseMediaType(contentType))
                    .header(HttpHeaders.CONTENT_DISPOSITION, "inline; filename=\"" + resource.getFilename() + "\"")
                    .body(resource);

        } catch (MalformedURLException e) {
            log.error("Invalid file path: {}", filename, e);
            throw new ValidationException("Invalid file path");
        } catch (IOException e) {
            log.error("Error reading file: {}", filename, e);
            throw new ValidationException("Error reading file");
        }
    }

    private void validateFile(MultipartFile file) {
        if (file.isEmpty()) {
            throw new ValidationException("File is empty");
        }

        if (file.getSize() > MAX_FILE_SIZE) {
            throw new ValidationException("File size exceeds maximum allowed (5MB)");
        }

        String contentType = file.getContentType();
        if (contentType == null || !ALLOWED_CONTENT_TYPES.contains(contentType)) {
            throw new ValidationException("Invalid file type. Allowed types: JPEG, PNG, WebP");
        }
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/controller/ProductController.java ==========
package com.flavia.dermobeauty.catalog.controller;

import com.flavia.dermobeauty.catalog.dto.ProductDto;
import com.flavia.dermobeauty.catalog.service.ProductCatalogService;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * Public REST controller for product catalog operations.
 * Provides endpoints for browsing available products.
 */
@RestController
@RequestMapping("/api/public/products")
@RequiredArgsConstructor
public class ProductController {

    private final ProductCatalogService productCatalogService;

    @GetMapping
    public ResponseEntity<ApiResponse<List<ProductDto>>> getAllProducts() {
        List<ProductDto> products = productCatalogService.getAllActive();
        return ResponseEntity.ok(ApiResponse.success(products));
    }

    @GetMapping("/featured")
    public ResponseEntity<ApiResponse<List<ProductDto>>> getFeaturedProducts() {
        List<ProductDto> products = productCatalogService.getFeatured();
        return ResponseEntity.ok(ApiResponse.success(products));
    }

    @GetMapping("/offers")
    public ResponseEntity<ApiResponse<List<ProductDto>>> getOfferProducts() {
        List<ProductDto> products = productCatalogService.getOffers();
        return ResponseEntity.ok(ApiResponse.success(products));
    }

    @GetMapping("/trending")
    public ResponseEntity<ApiResponse<List<ProductDto>>> getTrendingProducts() {
        List<ProductDto> products = productCatalogService.getTrending();
        return ResponseEntity.ok(ApiResponse.success(products));
    }

    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<ProductDto>> getProductById(@PathVariable Long id) {
        ProductDto product = productCatalogService.getById(id);
        return ResponseEntity.ok(ApiResponse.success(product));
    }

    @GetMapping("/slug/{slug}")
    public ResponseEntity<ApiResponse<ProductDto>> getProductBySlug(@PathVariable String slug) {
        ProductDto product = productCatalogService.getBySlug(slug);
        return ResponseEntity.ok(ApiResponse.success(product));
    }

    @GetMapping("/category/{categoryId}")
    public ResponseEntity<ApiResponse<List<ProductDto>>> getProductsByCategory(@PathVariable Long categoryId) {
        List<ProductDto> products = productCatalogService.getByCategory(categoryId);
        return ResponseEntity.ok(ApiResponse.success(products));
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/controller/ServiceController.java ==========
package com.flavia.dermobeauty.catalog.controller;

import com.flavia.dermobeauty.catalog.dto.ServiceDto;
import com.flavia.dermobeauty.catalog.service.ServiceCatalogService;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * Public REST controller for service catalog operations.
 * Provides endpoints for browsing available services.
 */
@RestController
@RequestMapping("/api/public/services")
@RequiredArgsConstructor
public class ServiceController {

    private final ServiceCatalogService serviceCatalogService;

    @GetMapping
    public ResponseEntity<ApiResponse<List<ServiceDto>>> getAllServices() {
        List<ServiceDto> services = serviceCatalogService.getAllActive();
        return ResponseEntity.ok(ApiResponse.success(services));
    }

    @GetMapping("/featured")
    public ResponseEntity<ApiResponse<List<ServiceDto>>> getFeaturedServices() {
        List<ServiceDto> services = serviceCatalogService.getFeatured();
        return ResponseEntity.ok(ApiResponse.success(services));
    }

    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<ServiceDto>> getServiceById(@PathVariable Long id) {
        ServiceDto service = serviceCatalogService.getById(id);
        return ResponseEntity.ok(ApiResponse.success(service));
    }

    @GetMapping("/slug/{slug}")
    public ResponseEntity<ApiResponse<ServiceDto>> getServiceBySlug(@PathVariable String slug) {
        ServiceDto service = serviceCatalogService.getBySlug(slug);
        return ResponseEntity.ok(ApiResponse.success(service));
    }

    @GetMapping("/category/{categoryId}")
    public ResponseEntity<ApiResponse<List<ServiceDto>>> getServicesByCategory(@PathVariable Long categoryId) {
        List<ServiceDto> services = serviceCatalogService.getByCategory(categoryId);
        return ResponseEntity.ok(ApiResponse.success(services));
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/dto/CategoryDto.java ==========
package com.flavia.dermobeauty.catalog.dto;

import com.flavia.dermobeauty.catalog.entity.CategoryEntity;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO for category data transfer.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CategoryDto {

    private Long id;
    private String name;
    private String slug;
    private String description;
    private CategoryEntity.CategoryType type;

    public static CategoryDto fromEntity(CategoryEntity entity) {
        return CategoryDto.builder()
                .id(entity.getId())
                .name(entity.getName())
                .slug(entity.getSlug())
                .description(entity.getDescription())
                .type(entity.getType())
                .build();
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/dto/ProductDto.java ==========
package com.flavia.dermobeauty.catalog.dto;

import com.flavia.dermobeauty.catalog.entity.ProductEntity;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

/**
 * DTO for product data transfer with validation.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProductDto {

    private Long id;

    @NotBlank(message = "Name is required")
    private String name;

    private String slug;

    @NotBlank(message = "Description is required")
    private String description;

    private String shortDescription;

    @NotNull(message = "Price is required")
    @DecimalMin(value = "0.0", inclusive = false, message = "Price must be greater than 0")
    private BigDecimal price;

    private BigDecimal offerPrice;

    @NotNull(message = "Stock is required")
    @Min(value = 0, message = "Stock cannot be negative")
    private Integer stock;

    @NotNull(message = "Category ID is required")
    private Long categoryId;

    private String categoryName;

    private String imageUrl;

    private Boolean isFeatured;

    private Boolean isOffer;

    private Boolean isTrending;

    private Boolean isActive;

    public static ProductDto fromEntity(ProductEntity entity) {
        return ProductDto.builder()
                .id(entity.getId())
                .name(entity.getName())
                .slug(entity.getSlug())
                .description(entity.getDescription())
                .shortDescription(entity.getShortDescription())
                .price(entity.getPrice())
                .offerPrice(entity.getOfferPrice())
                .stock(entity.getStock())
                .categoryId(entity.getCategory().getId())
                .categoryName(entity.getCategory().getName())
                .imageUrl(entity.getImageUrl())
                .isFeatured(entity.getIsFeatured())
                .isOffer(entity.getIsOffer())
                .isTrending(entity.getIsTrending())
                .isActive(entity.getIsActive())
                .build();
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/dto/ServiceDto.java ==========
package com.flavia.dermobeauty.catalog.dto;

import com.flavia.dermobeauty.catalog.entity.ServiceEntity;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

/**
 * DTO for service data transfer with validation.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ServiceDto {

    private Long id;

    @NotBlank(message = "Name is required")
    private String name;

    private String slug;

    @NotBlank(message = "Description is required")
    private String description;

    private String shortDescription;

    @NotNull(message = "Duration is required")
    @Min(value = 1, message = "Duration must be at least 1 minute")
    private Integer durationMinutes;

    @NotNull(message = "Price is required")
    @DecimalMin(value = "0.0", inclusive = false, message = "Price must be greater than 0")
    private BigDecimal price;

    private BigDecimal offerPrice;

    private Boolean isOffer;

    @NotNull(message = "Category ID is required")
    private Long categoryId;

    private String categoryName;

    private String imageUrl;

    private Boolean isFeatured;

    private Boolean isActive;

    public static ServiceDto fromEntity(ServiceEntity entity) {
        return ServiceDto.builder()
                .id(entity.getId())
                .name(entity.getName())
                .slug(entity.getSlug())
                .description(entity.getDescription())
                .shortDescription(entity.getShortDescription())
                .durationMinutes(entity.getDurationMinutes())
                .price(entity.getPrice())
                .offerPrice(entity.getOfferPrice())
                .isOffer(entity.getIsOffer())
                .categoryId(entity.getCategory().getId())
                .categoryName(entity.getCategory().getName())
                .imageUrl(entity.getImageUrl())
                .isFeatured(entity.getIsFeatured())
                .isActive(entity.getIsActive())
                .build();
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/entity/CategoryEntity.java ==========
package com.flavia.dermobeauty.catalog.entity;

import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDateTime;

/**
 * JPA entity for categories table.
 * Categories are used to organize both services and products.
 */
@Entity
@Table(name = "categories")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class CategoryEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @EqualsAndHashCode.Include
    private Long id;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(nullable = false, unique = true, length = 100)
    private String slug;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private CategoryType type;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }

    public enum CategoryType {
        SERVICE, PRODUCT
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/entity/ProductEntity.java ==========
package com.flavia.dermobeauty.catalog.entity;

import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * JPA entity for products table.
 * Represents beauty/dermatology products for sale.
 */
@Entity
@Table(name = "products")
@Getter@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class ProductEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @EqualsAndHashCode.Include
    private Long id;

    @Column(nullable = false, length = 200)
    private String name;

    @Column(nullable = false, unique = true, length = 200)
    private String slug;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Column(name = "short_description", length = 500)
    private String shortDescription;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal price;

    @Column(name = "offer_price", precision = 10, scale = 2)
    private BigDecimal offerPrice;

    @Builder.Default
    @Column(nullable = false)
    private Integer stock = 0;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id", nullable = false)
    @ToString.Exclude
    private CategoryEntity category;

    @Column(name = "image_url", length = 500)
    private String imageUrl;

    @Builder.Default
    @Column(name = "is_featured", nullable = false)
    private Boolean isFeatured = false;

    @Builder.Default
    @Column(name = "is_offer", nullable = false)
    private Boolean isOffer = false;

    @Builder.Default
    @Column(name = "is_trending", nullable = false)
    private Boolean isTrending = false;

    @Builder.Default
    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/entity/ServiceEntity.java ==========
package com.flavia.dermobeauty.catalog.entity;

import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * JPA entity for services table.
 * Represents professional services offered (e.g., facial treatments, peels).
 */
@Entity
@Table(name = "services")
@Getter@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class ServiceEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @EqualsAndHashCode.Include
    private Long id;

    @Column(nullable = false, length = 200)
    private String name;

    @Column(nullable = false, unique = true, length = 200)
    private String slug;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Column(name = "short_description", length = 500)
    private String shortDescription;

    @Column(name = "duration_minutes", nullable = false)
    private Integer durationMinutes;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal price;

    @Column(name = "offer_price", precision = 10, scale = 2)
    private BigDecimal offerPrice;

    @Builder.Default
    @Column(name = "is_offer", nullable = false)
    private Boolean isOffer = false;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id", nullable = false)
    @ToString.Exclude
    private CategoryEntity category;

    @Column(name = "image_url", length = 500)
    private String imageUrl;

    @Builder.Default
    @Column(name = "is_featured", nullable = false)
    private Boolean isFeatured = false;

    @Builder.Default
    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/repository/CategoryRepository.java ==========
package com.flavia.dermobeauty.catalog.repository;

import com.flavia.dermobeauty.catalog.entity.CategoryEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

/**
 * Repository for category operations.
 */
@Repository
public interface CategoryRepository extends JpaRepository<CategoryEntity, Long> {

    Optional<CategoryEntity> findBySlug(String slug);

    List<CategoryEntity> findByType(CategoryEntity.CategoryType type);
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/repository/ProductRepository.java ==========
package com.flavia.dermobeauty.catalog.repository;

import com.flavia.dermobeauty.catalog.entity.ProductEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

/**
 * Repository for product operations with custom queries for filtering.
 */
@Repository
public interface ProductRepository extends JpaRepository<ProductEntity, Long> {

    Optional<ProductEntity> findBySlug(String slug);

    List<ProductEntity> findByIsActiveTrueOrderByCreatedAtDesc();

    List<ProductEntity> findByIsFeaturedTrueAndIsActiveTrueOrderByCreatedAtDesc();

    List<ProductEntity> findByIsOfferTrueAndIsActiveTrueOrderByCreatedAtDesc();

    List<ProductEntity> findByIsTrendingTrueAndIsActiveTrueOrderByCreatedAtDesc();

    @Query("SELECT p FROM ProductEntity p WHERE p.category.id = :categoryId AND p.isActive = true ORDER BY p.createdAt DESC")
    List<ProductEntity> findByCategoryIdAndIsActiveTrue(@Param("categoryId") Long categoryId);

    @Modifying(clearAutomatically = true)
    @Query("UPDATE ProductEntity p SET p.stock = p.stock - :quantity WHERE p.id = :id AND p.stock >= :quantity")
    int decrementStock(@Param("id") Long id, @Param("quantity") Integer quantity);

}


========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/repository/ServiceRepository.java ==========
package com.flavia.dermobeauty.catalog.repository;

import com.flavia.dermobeauty.catalog.entity.ServiceEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

/**
 * Repository for service operations with custom queries for filtering.
 */
@Repository
public interface ServiceRepository extends JpaRepository<ServiceEntity, Long> {

    Optional<ServiceEntity> findBySlug(String slug);

    List<ServiceEntity> findByIsActiveTrueOrderByCreatedAtDesc();

    List<ServiceEntity> findByIsFeaturedTrueAndIsActiveTrueOrderByCreatedAtDesc();

    @Query("SELECT s FROM ServiceEntity s WHERE s.category.id = :categoryId AND s.isActive = true ORDER BY s.createdAt DESC")
    List<ServiceEntity> findByCategoryIdAndIsActiveTrue(@Param("categoryId") Long categoryId);
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/service/ProductCatalogService.java ==========
package com.flavia.dermobeauty.catalog.service;

import com.flavia.dermobeauty.catalog.dto.ProductDto;
import com.flavia.dermobeauty.catalog.entity.CategoryEntity;
import com.flavia.dermobeauty.catalog.entity.ProductEntity;
import com.flavia.dermobeauty.catalog.repository.CategoryRepository;
import com.flavia.dermobeauty.catalog.repository.ProductRepository;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Service for managing product catalog operations.
 * Provides CRUD operations for beauty/dermatology products.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class ProductCatalogService {

    private final ProductRepository productRepository;
    private final CategoryRepository categoryRepository;

    @Transactional(readOnly = true)
    public List<ProductDto> getAllActive() {
        log.debug("Fetching all active products");
        return productRepository.findByIsActiveTrueOrderByCreatedAtDesc()
                .stream()
                .map(ProductDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<ProductDto> getAllForAdmin() {
        log.debug("Fetching all products for admin");
        // Usamos findAll() estándar de JPA para traer todo
        return productRepository.findAll()
                .stream()
                .map(ProductDto::fromEntity)
                // Ordenamos por ID o fecha para que no salten en la tabla
                .sorted((a, b) -> b.getId().compareTo(a.getId()))
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public Page<ProductDto> getAllForAdminPaginated(Pageable pageable) {
        log.debug("Fetching products for admin with pagination: page={}, size={}",
                pageable.getPageNumber(), pageable.getPageSize());
        return productRepository.findAll(pageable)
                .map(ProductDto::fromEntity);
    }

    @Transactional(readOnly = true)
    public List<ProductDto> getFeatured() {
        log.debug("Fetching featured products");
        return productRepository.findByIsFeaturedTrueAndIsActiveTrueOrderByCreatedAtDesc()
                .stream()
                .map(ProductDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<ProductDto> getOffers() {
        log.debug("Fetching products on offer");
        return productRepository.findByIsOfferTrueAndIsActiveTrueOrderByCreatedAtDesc()
                .stream()
                .map(ProductDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<ProductDto> getTrending() {
        log.debug("Fetching trending products");
        return productRepository.findByIsTrendingTrueAndIsActiveTrueOrderByCreatedAtDesc()
                .stream()
                .map(ProductDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public ProductDto getById(Long id) {
        log.debug("Fetching product by id: {}", id);
        ProductEntity entity = productRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Product", id));
        return ProductDto.fromEntity(entity);
    }

    @Transactional(readOnly = true)
    public ProductDto getBySlug(String slug) {
        log.debug("Fetching product by slug: {}", slug);
        ProductEntity entity = productRepository.findBySlug(slug)
                .orElseThrow(() -> new ResourceNotFoundException("Product with slug '" + slug + "' not found"));
        return ProductDto.fromEntity(entity);
    }

    @Transactional(readOnly = true)
    public List<ProductDto> getByCategory(Long categoryId) {
        log.debug("Fetching products by category: {}", categoryId);
        return productRepository.findByCategoryIdAndIsActiveTrue(categoryId)
                .stream()
                .map(ProductDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional
    public ProductDto create(ProductDto dto) {
        log.info("Creating new product: {}", dto.getName());

        CategoryEntity category = categoryRepository.findById(dto.getCategoryId())
                .orElseThrow(() -> new ResourceNotFoundException("Category", dto.getCategoryId()));

        ProductEntity entity = ProductEntity.builder()
                .name(dto.getName())
                .slug(generateSlug(dto.getName()))
                .description(dto.getDescription())
                .shortDescription(dto.getShortDescription())
                .price(dto.getPrice())
                .offerPrice(dto.getOfferPrice())
                .stock(dto.getStock() != null ? dto.getStock() : 0)
                .category(category)
                .imageUrl(dto.getImageUrl())
                .isFeatured(dto.getIsFeatured() != null ? dto.getIsFeatured() : false)
                .isOffer(dto.getIsOffer() != null ? dto.getIsOffer() : false)
                .isTrending(dto.getIsTrending() != null ? dto.getIsTrending() : false)
                .isActive(dto.getIsActive() != null ? dto.getIsActive() : true)
                .build();

        ProductEntity saved = productRepository.save(entity);
        return ProductDto.fromEntity(saved);
    }

    @Transactional
    public ProductDto update(Long id, ProductDto dto) {
        log.info("Updating product: {}", id);

        ProductEntity entity = productRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Product", id));

        if (dto.getCategoryId() != null && !dto.getCategoryId().equals(entity.getCategory().getId())) {
            CategoryEntity category = categoryRepository.findById(dto.getCategoryId())
                    .orElseThrow(() -> new ResourceNotFoundException("Category", dto.getCategoryId()));
            entity.setCategory(category);
        }

        entity.setName(dto.getName());
        entity.setDescription(dto.getDescription());
        entity.setShortDescription(dto.getShortDescription());
        entity.setPrice(dto.getPrice());
        entity.setOfferPrice(dto.getOfferPrice());
        entity.setStock(dto.getStock());
        entity.setImageUrl(dto.getImageUrl());
        entity.setIsFeatured(dto.getIsFeatured());
        entity.setIsOffer(dto.getIsOffer());
        entity.setIsTrending(dto.getIsTrending());
        entity.setIsActive(dto.getIsActive());

        ProductEntity updated = productRepository.save(entity);
        return ProductDto.fromEntity(updated);
    }

    @Transactional
    public void delete(Long id) {
        log.info("Deleting product: {}", id);
        if (!productRepository.existsById(id)) {
            throw new ResourceNotFoundException("Product", id);
        }
        productRepository.deleteById(id);
    }

    private String generateSlug(String name) {
        return name.toLowerCase()
                .replaceAll("[^a-z0-9\\s-]", "")
                .replaceAll("\\s+", "-")
                .replaceAll("-+", "-");
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/catalog/service/ServiceCatalogService.java ==========
package com.flavia.dermobeauty.catalog.service;

import com.flavia.dermobeauty.catalog.dto.ServiceDto;
import com.flavia.dermobeauty.catalog.entity.CategoryEntity;
import com.flavia.dermobeauty.catalog.entity.ServiceEntity;
import com.flavia.dermobeauty.catalog.repository.CategoryRepository;
import com.flavia.dermobeauty.catalog.repository.ServiceRepository;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Service for managing service catalog operations.
 * Provides CRUD operations for beauty/dermatology services.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class ServiceCatalogService {

    private final ServiceRepository serviceRepository;
    private final CategoryRepository categoryRepository;

    @Transactional(readOnly = true)
    public List<ServiceDto> getAllActive() {
        log.debug("Fetching all active services");
        return serviceRepository.findByIsActiveTrueOrderByCreatedAtDesc()
                .stream()
                .map(ServiceDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<ServiceDto> getAllForAdmin() {
        log.debug("Fetching all services for admin");
        return serviceRepository.findAll()
                .stream()
                .map(ServiceDto::fromEntity)
                .sorted((a, b) -> b.getId().compareTo(a.getId()))
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<ServiceDto> getFeatured() {
        log.debug("Fetching featured services");
        return serviceRepository.findByIsFeaturedTrueAndIsActiveTrueOrderByCreatedAtDesc()
                .stream()
                .map(ServiceDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public ServiceDto getById(Long id) {
        log.debug("Fetching service by id: {}", id);
        ServiceEntity entity = serviceRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Service", id));
        return ServiceDto.fromEntity(entity);
    }

    @Transactional(readOnly = true)
    public ServiceDto getBySlug(String slug) {
        log.debug("Fetching service by slug: {}", slug);
        ServiceEntity entity = serviceRepository.findBySlug(slug)
                .orElseThrow(() -> new ResourceNotFoundException("Service with slug '" + slug + "' not found"));
        return ServiceDto.fromEntity(entity);
    }

    @Transactional(readOnly = true)
    public List<ServiceDto> getByCategory(Long categoryId) {
        log.debug("Fetching services by category: {}", categoryId);
        return serviceRepository.findByCategoryIdAndIsActiveTrue(categoryId)
                .stream()
                .map(ServiceDto::fromEntity)
                .collect(Collectors.toList());
    }

    @Transactional
    public ServiceDto create(ServiceDto dto) {
        log.info("Creating new service: {}", dto.getName());

        CategoryEntity category = categoryRepository.findById(dto.getCategoryId())
                .orElseThrow(() -> new ResourceNotFoundException("Category", dto.getCategoryId()));

        ServiceEntity entity = ServiceEntity.builder()
                .name(dto.getName())
                .slug(generateSlug(dto.getName()))
                .description(dto.getDescription())
                .shortDescription(dto.getShortDescription())
                .durationMinutes(dto.getDurationMinutes())
                .price(dto.getPrice())
                .offerPrice(dto.getOfferPrice())
                .isOffer(dto.getIsOffer() != null ? dto.getIsOffer() : false)
                .category(category)
                .imageUrl(dto.getImageUrl())
                .isFeatured(dto.getIsFeatured() != null ? dto.getIsFeatured() : false)
                .isActive(dto.getIsActive() != null ? dto.getIsActive() : true)
                .build();

        ServiceEntity saved = serviceRepository.save(entity);
        return ServiceDto.fromEntity(saved);
    }

    @Transactional
    public ServiceDto update(Long id, ServiceDto dto) {
        log.info("Updating service: {}", id);

        ServiceEntity entity = serviceRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Service", id));

        if (dto.getCategoryId() != null && !dto.getCategoryId().equals(entity.getCategory().getId())) {
            CategoryEntity category = categoryRepository.findById(dto.getCategoryId())
                    .orElseThrow(() -> new ResourceNotFoundException("Category", dto.getCategoryId()));
            entity.setCategory(category);
        }

        entity.setName(dto.getName());
        entity.setDescription(dto.getDescription());
        entity.setShortDescription(dto.getShortDescription());
        entity.setDurationMinutes(dto.getDurationMinutes());
        entity.setPrice(dto.getPrice());
        entity.setOfferPrice(dto.getOfferPrice());
        entity.setIsOffer(dto.getIsOffer());
        entity.setImageUrl(dto.getImageUrl());
        entity.setIsFeatured(dto.getIsFeatured());
        entity.setIsActive(dto.getIsActive());

        ServiceEntity updated = serviceRepository.save(entity);
        return ServiceDto.fromEntity(updated);
    }

    @Transactional
    public void delete(Long id) {
        log.info("Deleting service: {}", id);
        if (!serviceRepository.existsById(id)) {
            throw new ResourceNotFoundException("Service", id);
        }
        serviceRepository.deleteById(id);
    }

    private String generateSlug(String name) {
        return name.toLowerCase()
                .replaceAll("[^a-z0-9\\s-]", "")
                .replaceAll("\\s+", "-")
                .replaceAll("-+", "-");
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/config/domain/ConfigEntry.java ==========
package com.flavia.dermobeauty.config.domain;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "app_config")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ConfigEntry {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "config_key", unique = true, nullable = false)
    private String key;

    @Column(name = "config_value", nullable = false)
    private String value;

    private String description;
}

========== FILE: ./src/main/java/com/flavia/dermobeauty/config/repository/ConfigRepository.java ==========
package com.flavia.dermobeauty.config.repository;

import com.flavia.dermobeauty.config.domain.ConfigEntry;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.Optional;

public interface ConfigRepository extends JpaRepository<ConfigEntry, Long> {
    Optional<ConfigEntry> findByKey(String key);
}

========== FILE: ./src/main/java/com/flavia/dermobeauty/config/web/AdminConfigController.java ==========
package com.flavia.dermobeauty.config.web;

import com.flavia.dermobeauty.config.domain.ConfigEntry;
import com.flavia.dermobeauty.config.repository.ConfigRepository;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/admin/config")
@RequiredArgsConstructor
public class AdminConfigController {

    private final ConfigRepository configRepository;

    @GetMapping
    public ResponseEntity<ApiResponse<List<ConfigEntry>>> getAllConfig() {
        return ResponseEntity.ok(ApiResponse.success(configRepository.findAll()));
    }

    @PutMapping("/{key}")
    public ResponseEntity<ApiResponse<ConfigEntry>> updateConfig(
            @PathVariable String key,
            @RequestBody UpdateConfigRequest request) {

        ConfigEntry config = configRepository.findByKey(key)
                .orElse(ConfigEntry.builder().key(key).build());

        config.setValue(request.getValue());
        // Descripción opcional, solo si es nuevo
        if (config.getDescription() == null) {
            config.setDescription("Configuración dinámica");
        }

        return ResponseEntity.ok(ApiResponse.success(configRepository.save(config)));
    }

    @Data
    public static class UpdateConfigRequest {
        private String value;
    }
}

========== FILE: ./src/main/java/com/flavia/dermobeauty/DermobeautyApplication.java ==========
package com.flavia.dermobeauty;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class DermobeautyApplication {

    public static void main(String[] args) {
        SpringApplication.run(DermobeautyApplication.class, args);
    }

}


========== FILE: ./src/main/java/com/flavia/dermobeauty/payment/config/MercadoPagoConfiguration.java ==========
package com.flavia.dermobeauty.payment.config;

import com.mercadopago.MercadoPagoConfig;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;

import jakarta.annotation.PostConstruct;

/**
 * Configuration for Mercado Pago SDK.
 * Initializes SDK with access token from application properties.
 */
@Slf4j
@Configuration
public class MercadoPagoConfiguration {

    @Value("${mercadopago.access-token}")
    private String accessToken;

    @PostConstruct
    public void init() {
        MercadoPagoConfig.setAccessToken(accessToken);
        log.info("Mercado Pago SDK configured with access token");
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/payment/controller/MercadoPagoWebhookController.java ==========
package com.flavia.dermobeauty.payment.controller;

import com.flavia.dermobeauty.booking.application.usecase.ConfirmBookingPaymentUseCase;
import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.domain.BookingRepository;
import com.flavia.dermobeauty.sales.application.usecase.ConfirmOrderPaymentUseCase;
import com.flavia.dermobeauty.sales.domain.Order;
import com.flavia.dermobeauty.sales.domain.OrderRepository;
import com.mercadopago.client.payment.PaymentClient;
import com.mercadopago.exceptions.MPApiException;
import com.mercadopago.exceptions.MPException;
import com.mercadopago.resources.payment.Payment;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.util.Map;

/**
 * Controller for Mercado Pago webhook notifications.
 * Handles payment status updates from Mercado Pago.
 *
 * SECURITY MEASURES IMPLEMENTED:
 * 1. Never trusts webhook payload directly
 * 2. Always verifies payment status via Mercado Pago API
 * 3. Validates payment amount matches booking/order
 * 4. Prevents duplicate payment processing (idempotency)
 * 5. Structured logging for security audit trail
 * 6. Validates external reference format
 *
 * CRITICAL: This endpoint must be publicly accessible (no authentication).
 * Mercado Pago sends IPN notifications here when payment status changes.
 */
@Slf4j
@RestController
@RequestMapping("/api/mp")
@RequiredArgsConstructor
public class MercadoPagoWebhookController {

    private final BookingRepository bookingRepository;
    private final OrderRepository orderRepository;
    private final ConfirmBookingPaymentUseCase confirmBookingPaymentUseCase;
    private final ConfirmOrderPaymentUseCase confirmOrderPaymentUseCase;
    private final PaymentClient paymentClient = new PaymentClient();

    @PostMapping("/webhook")
    public ResponseEntity<Void> handleWebhook(@RequestBody Map<String, Object> payload) {
        Long paymentId = null;
        String externalReference = null;

        try {
            // SECURITY: Log raw webhook received (audit trail)
            log.info("[WEBHOOK-RECEIVED] Payload type: {}, data: {}",
                    payload.get("type"),
                    payload.get("data"));

            // Step 1: Validate webhook payload structure
            String type = (String) payload.get("type");
            if (!"payment".equals(type)) {
                log.debug("[WEBHOOK-IGNORED] Non-payment notification type: {}", type);
                return ResponseEntity.ok().build();
            }

            Map<String, Object> data = (Map<String, Object>) payload.get("data");
            if (data == null) {
                log.warn("[WEBHOOK-REJECTED] Webhook data is null");
                return ResponseEntity.ok().build();
            }

            String paymentIdStr = (String) data.get("id");
            if (paymentIdStr == null) {
                log.warn("[WEBHOOK-REJECTED] Payment ID is null in webhook data");
                return ResponseEntity.ok().build();
            }

            // Step 2: Extract payment ID from webhook
            try {
                paymentId = Long.parseLong(paymentIdStr);
            } catch (NumberFormatException e) {
                log.error("[WEBHOOK-REJECTED] Invalid payment ID format: {}", paymentIdStr);
                return ResponseEntity.ok().build();
            }

            log.info("[WEBHOOK-PROCESSING] Payment ID: {}", paymentId);

            // CRITICAL SECURITY STEP 3: Verify payment directly with Mercado Pago API
            // NEVER trust the webhook payload alone - always verify with the source
            Payment payment;
            try {
                payment = paymentClient.get(paymentId);
                log.info("[MP-API-VERIFIED] Payment ID: {}, Status: {}, Amount: {}, External Ref: {}",
                        paymentId,
                        payment.getStatus(),
                        payment.getTransactionAmount(),
                        payment.getExternalReference());
            } catch (MPException | MPApiException e) {
                log.error("[MP-API-ERROR] Failed to verify payment {}: {}", paymentId, e.getMessage(), e);
                throw e;
            }

            // SECURITY VALIDATION 1: Only process approved payments
            if (!"approved".equals(payment.getStatus())) {
                log.warn("[PAYMENT-NOT-APPROVED] Payment {} has status '{}', expected 'approved'. Skipping.",
                        paymentId, payment.getStatus());
                return ResponseEntity.ok().build();
            }

            // SECURITY VALIDATION 2: Validate external reference exists and format
            externalReference = payment.getExternalReference();
            if (externalReference == null || externalReference.isBlank()) {
                log.error("[SECURITY-VIOLATION] Payment {} has no external reference", paymentId);
                return ResponseEntity.ok().build();
            }

            if (!externalReference.matches("^(BOOKING|ORDER)-[A-Z0-9]+$")) {
                log.error("[SECURITY-VIOLATION] Invalid external reference format: {}", externalReference);
                return ResponseEntity.ok().build();
            }

            // Step 4: Route to appropriate payment confirmation handler
            if (externalReference.startsWith("BOOKING-")) {
                confirmBookingPayment(payment, externalReference, String.valueOf(paymentId));
            } else if (externalReference.startsWith("ORDER-")) {
                confirmOrderPayment(payment, externalReference, String.valueOf(paymentId));
            } else {
                log.error("[SECURITY-VIOLATION] Unknown external reference prefix: {}", externalReference);
            }

            log.info("[WEBHOOK-SUCCESS] Payment {} processed successfully", paymentId);
            return ResponseEntity.ok().build();

        } catch (MPApiException e) {
            log.error("[MP-API-ERROR] Payment: {}, Ref: {}, Status: {}, Message: {}",
                    paymentId, externalReference, e.getStatusCode(), e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.OK).build(); // Always return 200 to MP
        } catch (MPException e) {
            log.error("[MP-ERROR] Payment: {}, Ref: {}, Message: {}",
                    paymentId, externalReference, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.OK).build();
        } catch (Exception e) {
            log.error("[WEBHOOK-ERROR] Payment: {}, Ref: {}, Unexpected error",
                    paymentId, externalReference, e);
            return ResponseEntity.status(HttpStatus.OK).build(); // Always return 200 to MP
        }
    }

    private void confirmBookingPayment(Payment payment, String externalReference, String paymentId) {
        String bookingNumber = null;
        try {
            bookingNumber = externalReference.replace("BOOKING-", "");
            log.info("[BOOKING-CONFIRMATION-START] Booking: {}, Payment: {}", bookingNumber, paymentId);

            // Create final variable for lambda expression
            final String finalBookingNumber = bookingNumber;

            // Find booking
            Booking booking = bookingRepository.findByBookingNumber(bookingNumber)
                    .orElseThrow(() -> {
                        log.error("[SECURITY-VIOLATION] Booking not found: {}", finalBookingNumber);
                        return new RuntimeException("Booking not found: " + finalBookingNumber);
                    });

            // SECURITY VALIDATION 3: Idempotency - Check if payment already processed
            if (booking.getMercadoPagoPaymentId() != null &&
                    booking.getMercadoPagoPaymentId().equals(paymentId)) {
                log.warn("[DUPLICATE-PAYMENT] Booking {} already has payment {} processed. Ignoring duplicate notification.",
                        bookingNumber, paymentId);
                return;
            }

            // SECURITY VALIDATION 4: Prevent different payment ID for same booking
            if (booking.getMercadoPagoPaymentId() != null &&
                    !booking.getMercadoPagoPaymentId().equals(paymentId)) {
                log.error("[SECURITY-VIOLATION] Booking {} already has different payment ID: {}. Rejecting new payment: {}",
                        bookingNumber, booking.getMercadoPagoPaymentId(), paymentId);
                throw new RuntimeException("Booking already has a different payment ID");
            }

            // SECURITY VALIDATION 5: Verify payment amount matches booking amount
            BigDecimal paymentAmount = payment.getTransactionAmount();
            BigDecimal bookingAmount = booking.getAmount();

            if (paymentAmount == null || paymentAmount.compareTo(bookingAmount) != 0) {
                log.error("[SECURITY-VIOLATION] Amount mismatch! Booking {}: expected {}, got {}",
                        bookingNumber, bookingAmount, paymentAmount);
                throw new RuntimeException("Payment amount does not match booking amount");
            }

            log.info("[AMOUNT-VERIFIED] Booking {}: {} ARS", bookingNumber, paymentAmount);

            // Update booking with payment ID
            Booking updatedBooking = Booking.builder()
                    .id(booking.getId())
                    .bookingNumber(booking.getBookingNumber())
                    .serviceId(booking.getServiceId())
                    .customerInfo(booking.getCustomerInfo())
                    .timeSlot(booking.getTimeSlot())
                    .durationMinutes(booking.getDurationMinutes())
                    .status(booking.getStatus())
                    .paymentStatus(booking.getPaymentStatus())
                    .mercadoPagoPreferenceId(booking.getMercadoPagoPreferenceId())
                    .mercadoPagoPaymentId(paymentId)
                    .amount(booking.getAmount())
                    .createdAt(booking.getCreatedAt())
                    .updatedAt(booking.getUpdatedAt())
                    .confirmedAt(booking.getConfirmedAt())
                    .cancelledAt(booking.getCancelledAt())
                    .build();

            bookingRepository.save(updatedBooking);
            log.info("[BOOKING-UPDATED] Booking {} updated with payment ID {}", bookingNumber, paymentId);

            // Confirm payment via use case (sends confirmation email, updates status)
            confirmBookingPaymentUseCase.execute(paymentId);
            log.info("[BOOKING-CONFIRMATION-SUCCESS] Booking {} payment confirmed successfully", bookingNumber);

        } catch (Exception e) {
            log.error("[BOOKING-CONFIRMATION-FAILED] Booking: {}, Payment: {}, Error: {}",
                    bookingNumber, paymentId, e.getMessage(), e);
            throw new RuntimeException("Error confirming booking payment", e);
        }
    }

    private void confirmOrderPayment(Payment payment, String externalReference, String paymentId) {
        String orderNumber = null;
        try {
            orderNumber = externalReference.replace("ORDER-", "");
            log.info("[ORDER-CONFIRMATION-START] Order: {}, Payment: {}", orderNumber, paymentId);

            // Create final variable for lambda expression
            final String finalOrderNumber = orderNumber;

            // Find order
            Order order = orderRepository.findByOrderNumber(orderNumber)
                    .orElseThrow(() -> {
                        log.error("[SECURITY-VIOLATION] Order not found: {}", finalOrderNumber);
                        return new RuntimeException("Order not found: " + finalOrderNumber);
                    });

            // SECURITY VALIDATION 3: Idempotency - Check if payment already processed
            if (order.getMercadoPagoPaymentId() != null &&
                    order.getMercadoPagoPaymentId().equals(paymentId)) {
                log.warn("[DUPLICATE-PAYMENT] Order {} already has payment {} processed. Ignoring duplicate notification.",
                        orderNumber, paymentId);
                return;
            }

            // SECURITY VALIDATION 4: Prevent different payment ID for same order
            if (order.getMercadoPagoPaymentId() != null &&
                    !order.getMercadoPagoPaymentId().equals(paymentId)) {
                log.error("[SECURITY-VIOLATION] Order {} already has different payment ID: {}. Rejecting new payment: {}",
                        orderNumber, order.getMercadoPagoPaymentId(), paymentId);
                throw new RuntimeException("Order already has a different payment ID");
            }

            // SECURITY VALIDATION 5: Verify payment amount matches order total
            BigDecimal paymentAmount = payment.getTransactionAmount();
            BigDecimal orderTotal = order.getTotal();

            if (paymentAmount == null || paymentAmount.compareTo(orderTotal) != 0) {
                log.error("[SECURITY-VIOLATION] Amount mismatch! Order {}: expected {}, got {}",
                        orderNumber, orderTotal, paymentAmount);
                throw new RuntimeException("Payment amount does not match order total");
            }

            log.info("[AMOUNT-VERIFIED] Order {}: {} ARS", orderNumber, paymentAmount);

            // Update order with payment ID
            Order updatedOrder = Order.builder()
                    .id(order.getId())
                    .orderNumber(order.getOrderNumber())
                    .customerInfo(order.getCustomerInfo())
                    .deliveryInfo(order.getDeliveryInfo())
                    .items(order.getItems())
                    .subtotal(order.getSubtotal())
                    .deliveryCost(order.getDeliveryCost())
                    .total(order.getTotal())
                    .status(order.getStatus())
                    .paymentStatus(order.getPaymentStatus())
                    .mercadoPagoPreferenceId(order.getMercadoPagoPreferenceId())
                    .mercadoPagoPaymentId(paymentId)
                    .createdAt(order.getCreatedAt())
                    .updatedAt(order.getUpdatedAt())
                    .build();

            orderRepository.save(updatedOrder);
            log.info("[ORDER-UPDATED] Order {} updated with payment ID {}", orderNumber, paymentId);

            // Confirm payment via use case (decrements stock, sends email)
            confirmOrderPaymentUseCase.execute(paymentId);
            log.info("[ORDER-CONFIRMATION-SUCCESS] Order {} payment confirmed successfully", orderNumber);

        } catch (Exception e) {
            log.error("[ORDER-CONFIRMATION-FAILED] Order: {}, Payment: {}, Error: {}",
                    orderNumber, paymentId, e.getMessage(), e);
            throw new RuntimeException("Error confirming order payment", e);
        }
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/payment/controller/PaymentController.java ==========
package com.flavia.dermobeauty.payment.controller;

import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.domain.BookingRepository;
import com.flavia.dermobeauty.payment.dto.PaymentPreferenceResponse;
import com.flavia.dermobeauty.payment.service.MercadoPagoClient;
import com.flavia.dermobeauty.sales.domain.Order;
import com.flavia.dermobeauty.sales.domain.OrderRepository;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

/**
 * Controller for payment preference creation.
 * Public endpoints to initiate payment for bookings and orders.
 */
@Slf4j
@RestController
@RequestMapping("/api/public/payments")
@RequiredArgsConstructor
public class PaymentController {

    private final MercadoPagoClient mercadoPagoClient;
    private final BookingRepository bookingRepository;
    private final OrderRepository orderRepository;

    @PostMapping("/bookings/{bookingId}/preference")
    public ResponseEntity<ApiResponse<PaymentPreferenceResponse>> createBookingPreference(
            @PathVariable Long bookingId) {

        log.info("Creating payment preference for booking: {}", bookingId);

        Booking booking = bookingRepository.findById(bookingId)
                .orElseThrow(() -> new ResourceNotFoundException("Booking", bookingId));

        String preferenceId = mercadoPagoClient.createPreferenceForBooking(booking);

        // Update booking with preference ID
        Booking updatedBooking = Booking.builder()
                .id(booking.getId())
                .bookingNumber(booking.getBookingNumber())
                .serviceId(booking.getServiceId())
                .customerInfo(booking.getCustomerInfo())
                .timeSlot(booking.getTimeSlot())
                .durationMinutes(booking.getDurationMinutes())
                .status(booking.getStatus())
                .paymentStatus(booking.getPaymentStatus())
                .mercadoPagoPreferenceId(preferenceId)
                .mercadoPagoPaymentId(booking.getMercadoPagoPaymentId())
                .amount(booking.getAmount())
                .createdAt(booking.getCreatedAt())
                .updatedAt(booking.getUpdatedAt())
                .confirmedAt(booking.getConfirmedAt())
                .cancelledAt(booking.getCancelledAt())
                .build();

        bookingRepository.save(updatedBooking);

        PaymentPreferenceResponse response = new PaymentPreferenceResponse(
                preferenceId,
                "https://www.mercadopago.com.ar/checkout/v1/redirect?pref_id=" + preferenceId
        );

        return ResponseEntity.ok(ApiResponse.success(response, "Payment preference created"));
    }

    @PostMapping("/orders/{orderId}/preference")
    public ResponseEntity<ApiResponse<PaymentPreferenceResponse>> createOrderPreference(
            @PathVariable Long orderId) {

        log.info("Creating payment preference for order: {}", orderId);

        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new ResourceNotFoundException("Order", orderId));

        String preferenceId = mercadoPagoClient.createPreferenceForOrder(order);

        // Update order with preference ID
        Order updatedOrder = Order.builder()
                .id(order.getId())
                .orderNumber(order.getOrderNumber())
                .customerInfo(order.getCustomerInfo())
                .deliveryInfo(order.getDeliveryInfo())
                .items(order.getItems())
                .subtotal(order.getSubtotal())
                .deliveryCost(order.getDeliveryCost())
                .total(order.getTotal())
                .status(order.getStatus())
                .paymentStatus(order.getPaymentStatus())
                .mercadoPagoPreferenceId(preferenceId)
                .mercadoPagoPaymentId(order.getMercadoPagoPaymentId())
                .createdAt(order.getCreatedAt())
                .updatedAt(order.getUpdatedAt())
                .build();

        orderRepository.save(updatedOrder);

        PaymentPreferenceResponse response = new PaymentPreferenceResponse(
                preferenceId,
                "https://www.mercadopago.com.ar/checkout/v1/redirect?pref_id=" + preferenceId
        );

        return ResponseEntity.ok(ApiResponse.success(response, "Payment preference created"));
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/payment/dto/PaymentPreferenceResponse.java ==========
package com.flavia.dermobeauty.payment.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO for payment preference response.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class PaymentPreferenceResponse {
    private String preferenceId;
    private String initPoint;
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/payment/service/BookingPaymentServiceImpl.java ==========
package com.flavia.dermobeauty.payment.service;

import com.flavia.dermobeauty.booking.application.port.PaymentService;
import com.flavia.dermobeauty.booking.domain.Booking;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

/**
 * Implementation of PaymentService for booking module.
 * Delegates to MercadoPagoClient for preference creation.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class BookingPaymentServiceImpl implements PaymentService {

    private final MercadoPagoClient mercadoPagoClient;

    @Override
    public String createBookingPreference(Booking booking) {
        return mercadoPagoClient.createPreferenceForBooking(booking);
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/payment/service/MercadoPagoClient.java ==========
package com.flavia.dermobeauty.payment.service;

import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.sales.domain.Order;
import com.flavia.dermobeauty.shared.exception.PaymentException;
import com.mercadopago.client.common.IdentificationRequest;
import com.mercadopago.client.preference.*;
import com.mercadopago.exceptions.MPApiException;
import com.mercadopago.exceptions.MPException;
import com.mercadopago.resources.preference.Preference;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

/**
 * Client for Mercado Pago API operations.
 * Creates payment preferences for bookings and orders.
 */
@Slf4j
@Service
public class MercadoPagoClient {

    private final String baseUrl;
    private final String apiUrl;
    private final PreferenceClient preferenceClient;

    public MercadoPagoClient(
            @Value("${mercadopago.base-url}") String baseUrl,
            @Value("${app.api-url}") String apiUrl) {
        this.baseUrl = baseUrl;
        this.apiUrl = apiUrl;
        this.preferenceClient = new PreferenceClient();
        log.info("MercadoPagoClient initialized with base URL: {}", baseUrl);
    }

    /**
     * Create payment preference for a booking.
     *
     * @param booking The booking to create payment for
     * @return Preference ID
     */
    public String createPreferenceForBooking(Booking booking) {
        try {
            log.info("Creating MP preference for booking: {}", booking.getBookingNumber());

            PreferenceItemRequest item = PreferenceItemRequest.builder()
                    .title("Reserva de Servicio - " + booking.getBookingNumber())
                    .description("Servicio profesional de dermocosmiatría")
                    .quantity(1)
                    .currencyId("ARS")
                    .unitPrice(booking.getAmount())
                    .build();

            PreferencePayerRequest payer = PreferencePayerRequest.builder()
                    .name(booking.getCustomerInfo().getName())
                    .email(booking.getCustomerInfo().getEmail())
                    .build();

            PreferenceBackUrlsRequest backUrls = PreferenceBackUrlsRequest.builder()
                    .success(baseUrl + "/reserva/exitosa")
                    .failure(baseUrl + "/reserva/fallida")
                    .pending(baseUrl + "/reserva/pendiente")
                    .build();

            PreferenceRequest request = PreferenceRequest.builder()
                    .items(List.of(item))
                    .payer(payer)
                    .backUrls(backUrls)
                    .autoReturn("approved")
                    .externalReference("BOOKING-" + booking.getBookingNumber())
                    .notificationUrl(baseUrl + "/api/mp/webhook")
                    .statementDescriptor("Flavia Dermobeauty")
                    .build();

            Preference preference = preferenceClient.create(request);
            log.info("Created MP preference for booking {}: {}", booking.getBookingNumber(), preference.getId());

            return preference.getId();

        } catch (MPApiException e) {
            log.error("MP API error creating preference for booking {}: {} - {}",
                    booking.getBookingNumber(), e.getStatusCode(), e.getMessage());
            throw new PaymentException("Error creating payment preference: " + e.getMessage(), e);
        } catch (MPException e) {
            log.error("MP error creating preference for booking {}: {}",
                    booking.getBookingNumber(), e.getMessage());
            throw new PaymentException("Error creating payment preference: " + e.getMessage(), e);
        }
    }

    /**
     * Create payment preference for an order.
     *
     * @param order The order to create payment for
     * @return Preference ID
     */
    public String createPreferenceForOrder(Order order) {
        try {
            log.info("Creating MP preference for order: {}", order.getOrderNumber());

            List<PreferenceItemRequest> items = new ArrayList<>();

            // Add product items
            order.getItems().forEach(orderItem -> {
                PreferenceItemRequest item = PreferenceItemRequest.builder()
                        .title(orderItem.getProductName())
                        .quantity(orderItem.getQuantity())
                        .currencyId("ARS")
                        .unitPrice(orderItem.getProductPrice())
                        .build();
                items.add(item);
            });

            // Add delivery cost as separate item if applicable
            if (order.getDeliveryCost().compareTo(BigDecimal.ZERO) > 0) {
                PreferenceItemRequest deliveryItem = PreferenceItemRequest.builder()
                        .title("Envío a domicilio")
                        .quantity(1)
                        .currencyId("ARS")
                        .unitPrice(order.getDeliveryCost())
                        .build();
                items.add(deliveryItem);
            }

            PreferencePayerRequest payer = PreferencePayerRequest.builder()
                    .name(order.getCustomerInfo().getName())
                    .email(order.getCustomerInfo().getEmail())
                    .build();

            PreferenceBackUrlsRequest backUrls = PreferenceBackUrlsRequest.builder()
                    .success(baseUrl + "/pedido/exitoso")
                    .failure(baseUrl + "/pedido/fallido")
                    .pending(baseUrl + "/pedido/pendiente")
                    .build();

            PreferenceRequest request = PreferenceRequest.builder()
                    .items(items)
                    .payer(payer)
                    .backUrls(backUrls)
                    .autoReturn("approved")
                    .externalReference("ORDER-" + order.getOrderNumber())
                    .notificationUrl(baseUrl + "/api/mp/webhook")
                    .statementDescriptor("Flavia Dermobeauty")
                    .build();

            Preference preference = preferenceClient.create(request);
            log.info("Created MP preference for order {}: {}", order.getOrderNumber(), preference.getId());

            return preference.getId();

        } catch (MPApiException e) {
            log.error("MP API error creating preference for order {}: {} - {}",
                    order.getOrderNumber(), e.getStatusCode(), e.getMessage());
            throw new PaymentException("Error creating payment preference: " + e.getMessage(), e);
        } catch (MPException e) {
            log.error("MP error creating preference for order {}: {}",
                    order.getOrderNumber(), e.getMessage());
            throw new PaymentException("Error creating payment preference: " + e.getMessage(), e);
        }
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/payment/service/OrderPaymentServiceImpl.java ==========
package com.flavia.dermobeauty.payment.service;

import com.flavia.dermobeauty.sales.application.port.PaymentService;
import com.flavia.dermobeauty.sales.domain.Order;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

/**
 * Implementation of PaymentService for sales module.
 * Delegates to MercadoPagoClient for preference creation.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class OrderPaymentServiceImpl implements PaymentService {

    private final MercadoPagoClient mercadoPagoClient;

    @Override
    public String createOrderPreference(Order order) {
        return mercadoPagoClient.createPreferenceForOrder(order);
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/application/port/DeliveryCostCalculator.java ==========
package com.flavia.dermobeauty.sales.application.port;

import com.flavia.dermobeauty.sales.domain.DeliveryType;

import java.math.BigDecimal;

/**
 * Port (interface) for calculating delivery costs.
 * Will be implemented by infrastructure reading from config.
 */
public interface DeliveryCostCalculator {

    /**
     * Calculate delivery cost based on delivery type.
     *
     * @param deliveryType Type of delivery
     * @return Delivery cost (0 for PICKUP)
     */
    BigDecimal calculate(DeliveryType deliveryType);
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/application/port/NotificationService.java ==========
package com.flavia.dermobeauty.sales.application.port;

import com.flavia.dermobeauty.sales.domain.Order;

/**
 * Port (interface) for notification operations.
 * Will be implemented by the notification module infrastructure.
 */
public interface NotificationService {

    /**
     * Send order confirmation email to customer.
     *
     * @param order The confirmed order
     */
    void sendOrderConfirmation(Order order);
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/application/port/PaymentService.java ==========
package com.flavia.dermobeauty.sales.application.port;

import com.flavia.dermobeauty.sales.domain.Order;

/**
 * Port (interface) for payment operations.
 * Will be implemented by the payment module infrastructure.
 */
public interface PaymentService {

    /**
     * Create a Mercado Pago payment preference for an order.
     *
     * @param order The order to create payment for
     * @return Preference ID
     */
    String createOrderPreference(Order order);
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/application/port/StockService.java ==========
package com.flavia.dermobeauty.sales.application.port;

/**
 * Port (interface) for stock management operations.
 * Will be implemented by the catalog infrastructure.
 */
public interface StockService {

    /**
     * Check if sufficient stock is available for a product.
     *
     * @param productId Product ID
     * @param quantity  Requested quantity
     * @return true if stock available, false otherwise
     */
    boolean checkAvailability(Long productId, Integer quantity);

    /**
     * Decrement stock for a product.
     * Should be called after payment confirmation.
     *
     * @param productId Product ID
     * @param quantity  Quantity to decrement
     */
    void decrementStock(Long productId, Integer quantity);
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/application/usecase/ConfirmOrderPaymentUseCase.java ==========
package com.flavia.dermobeauty.sales.application.usecase;

import com.flavia.dermobeauty.sales.application.port.NotificationService;
import com.flavia.dermobeauty.sales.application.port.StockService;
import com.flavia.dermobeauty.sales.domain.Order;
import com.flavia.dermobeauty.sales.domain.OrderRepository;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Use Case: Confirm order payment.
 * Called from Mercado Pago webhook when payment is approved.
 * Decrements stock and sends confirmation email.
 */
@Slf4j
@RequiredArgsConstructor
public class ConfirmOrderPaymentUseCase {

    private final OrderRepository orderRepository;
    private final StockService stockService;
    private final NotificationService notificationService;

    public Order execute(String paymentId) {
        log.info("Confirming payment for payment ID: {}", paymentId);

        // Find order by payment ID
        Order order = orderRepository.findByMercadoPagoPaymentId(paymentId)
                .orElseThrow(() -> new ResourceNotFoundException("Order with payment ID '" + paymentId + "' not found"));

        // Confirm payment (domain logic)
        order.confirmPayment(paymentId);

        // Decrement stock for all items
        order.getItems().forEach(item -> {
            stockService.decrementStock(item.getProductId(), item.getQuantity());
            log.info("Decremented stock for product {}: {} units", item.getProductId(), item.getQuantity());
        });

        // Persist
        Order updated = orderRepository.save(order);
        log.info("Payment confirmed for order: {}", updated.getOrderNumber());

        // Send confirmation email (async, non-blocking)
        try {
            notificationService.sendOrderConfirmation(updated);
        } catch (Exception e) {
            log.error("Failed to send order confirmation email for {}", updated.getOrderNumber(), e);
            // Don't throw - email failure should not break payment confirmation
        }

        return updated;
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/application/usecase/CreateOrderUseCase.java ==========
package com.flavia.dermobeauty.sales.application.usecase;

import com.flavia.dermobeauty.booking.domain.PaymentStatus;
import com.flavia.dermobeauty.catalog.entity.ProductEntity;
import com.flavia.dermobeauty.catalog.repository.ProductRepository;
import com.flavia.dermobeauty.sales.application.port.DeliveryCostCalculator;
import com.flavia.dermobeauty.sales.application.port.StockService;
import com.flavia.dermobeauty.sales.domain.*;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import com.flavia.dermobeauty.shared.exception.ValidationException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;

/**
 * Use Case: Create a new order.
 * Validates stock availability, calculates delivery cost, and creates order in PENDING status.
 */
@Slf4j
@RequiredArgsConstructor
public class CreateOrderUseCase {

    private final OrderRepository orderRepository;
    private final ProductRepository productRepository;
    private final StockService stockService;
    private final DeliveryCostCalculator deliveryCostCalculator;

    public Order execute(
            String customerName,
            String customerEmail,
            String customerWhatsapp,
            DeliveryType deliveryType,
            String deliveryAddress,
            String deliveryCity,
            String deliveryPostalCode,
            String deliveryProvince,
            String deliveryNotes,
            List<OrderItemRequest> itemRequests) {

        log.info("Creating order for customer: {}", customerEmail);

        // Validate stock availability for all items
        for (OrderItemRequest itemRequest : itemRequests) {
            if (!stockService.checkAvailability(itemRequest.productId, itemRequest.quantity)) {
                ProductEntity product = productRepository.findById(itemRequest.productId)
                        .orElseThrow(() -> new ResourceNotFoundException("Product", itemRequest.productId));
                throw new ValidationException(
                        String.format("Insufficient stock for product '%s'. Requested: %d, Available: %d",
                                product.getName(), itemRequest.quantity, product.getStock())
                );
            }
        }

        // Create value objects
        CustomerInfo customerInfo = new CustomerInfo(customerName, customerEmail, customerWhatsapp);

        DeliveryInfo deliveryInfo = new DeliveryInfo(
                deliveryType,
                deliveryAddress,
                deliveryCity,
                deliveryPostalCode,
                deliveryProvince,
                deliveryNotes
        );

        // Calculate delivery cost
        BigDecimal deliveryCost = deliveryCostCalculator.calculate(deliveryType);

        // Create order aggregate
        Order order = Order.builder()
                .orderNumber(generateOrderNumber())
                .customerInfo(customerInfo)
                .deliveryInfo(deliveryInfo)
                .status(OrderStatus.PENDING)
                .paymentStatus(PaymentStatus.PENDING)
                .deliveryCost(deliveryCost)
                .createdAt(LocalDateTime.now())
                .updatedAt(LocalDateTime.now())
                .build();

        // Add items to order
        for (OrderItemRequest itemRequest : itemRequests) {
            ProductEntity product = productRepository.findById(itemRequest.productId)
                    .orElseThrow(() -> new ResourceNotFoundException("Product", itemRequest.productId));

            BigDecimal subtotal = OrderItem.calculateSubtotal(product.getPrice(), itemRequest.quantity);

            OrderItem item = OrderItem.builder()
                    .productId(product.getId())
                    .productName(product.getName())
                    .productPrice(product.getPrice())
                    .quantity(itemRequest.quantity)
                    .subtotal(subtotal)
                    .build();

            order.addItem(item);
        }

        // Validate and recalculate
        order.validate();
        order.recalculateTotal();

        // Persist
        Order saved = orderRepository.save(order);
        log.info("Order created successfully: {}", saved.getOrderNumber());

        return saved;
    }

    private String generateOrderNumber() {
        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd-HHmmss"));
        return "ORD-" + timestamp;
    }

    /**
     * DTO for order item request.
     */
    @RequiredArgsConstructor
    public static class OrderItemRequest {
        public final Long productId;
        public final Integer quantity;
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/application/usecase/GetOrderByNumberUseCase.java ==========
package com.flavia.dermobeauty.sales.application.usecase;

import com.flavia.dermobeauty.sales.domain.Order;
import com.flavia.dermobeauty.sales.domain.OrderRepository;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Use Case: Get order by order number.
 * Used by customers to check their order status.
 */
@Slf4j
@RequiredArgsConstructor
public class GetOrderByNumberUseCase {

    private final OrderRepository orderRepository;

    public Order execute(String orderNumber) {
        log.debug("Fetching order by number: {}", orderNumber);

        return orderRepository.findByOrderNumber(orderNumber)
                .orElseThrow(() -> new ResourceNotFoundException("Order with number '" + orderNumber + "' not found"));
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/application/usecase/ListOrdersUseCase.java ==========
package com.flavia.dermobeauty.sales.application.usecase;

import com.flavia.dermobeauty.sales.domain.Order;
import com.flavia.dermobeauty.sales.domain.OrderRepository;
import com.flavia.dermobeauty.sales.domain.OrderStatus;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

/**
 * Use Case: List orders for admin panel.
 * Supports filtering by status and pagination.
 */
@Slf4j
@RequiredArgsConstructor
public class ListOrdersUseCase {

    private final OrderRepository orderRepository;

    @Transactional(readOnly = true)
    public List<Order> execute() {
        log.debug("Fetching all orders");
        return orderRepository.findAll();
    }

    @Transactional(readOnly = true)
    public Page<Order> executePaginated(Pageable pageable) {
        log.debug("Fetching orders with pagination: page={}, size={}",
                pageable.getPageNumber(), pageable.getPageSize());
        return orderRepository.findAll(pageable);
    }

    public List<Order> executeByStatus(OrderStatus status) {
        log.debug("Fetching orders with status: {}", status);
        return orderRepository.findByStatus(status);
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/application/usecase/UpdateOrderStatusUseCase.java ==========
package com.flavia.dermobeauty.sales.application.usecase;

import com.flavia.dermobeauty.sales.domain.Order;
import com.flavia.dermobeauty.sales.domain.OrderRepository;
import com.flavia.dermobeauty.sales.domain.OrderStatus;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Use Case: Update order status.
 * Used by admin to move order through fulfillment stages.
 */
@Slf4j
@RequiredArgsConstructor
public class UpdateOrderStatusUseCase {

    private final OrderRepository orderRepository;

    public Order execute(Long orderId, OrderStatus newStatus) {
        log.info("Updating order {} to status: {}", orderId, newStatus);

        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new ResourceNotFoundException("Order", orderId));

        // Update status (domain logic validates transition)
        order.updateStatus(newStatus);

        // Persist
        Order updated = orderRepository.save(order);
        log.info("Order status updated: {} -> {}", updated.getOrderNumber(), newStatus);

        return updated;
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/config/SalesConfig.java ==========
package com.flavia.dermobeauty.sales.config;

import com.flavia.dermobeauty.catalog.repository.ProductRepository;
import com.flavia.dermobeauty.sales.application.port.DeliveryCostCalculator;
import com.flavia.dermobeauty.sales.application.port.NotificationService;
import com.flavia.dermobeauty.sales.application.port.StockService;
import com.flavia.dermobeauty.sales.application.usecase.*;
import com.flavia.dermobeauty.sales.domain.OrderRepository;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * Configuration class for Sales module.
 * Wires use cases as Spring beans for dependency injection.
 */
@Configuration
public class SalesConfig {

    @Bean
    public CreateOrderUseCase createOrderUseCase(
            OrderRepository orderRepository,
            ProductRepository productRepository,
            StockService stockService,
            DeliveryCostCalculator deliveryCostCalculator) {
        return new CreateOrderUseCase(orderRepository, productRepository, stockService, deliveryCostCalculator);
    }

    @Bean
    public ConfirmOrderPaymentUseCase confirmOrderPaymentUseCase(
            OrderRepository orderRepository,
            StockService stockService,
            @Qualifier("orderNotificationService") NotificationService notificationService) {
        return new ConfirmOrderPaymentUseCase(orderRepository, stockService, notificationService);
    }

    @Bean
    public UpdateOrderStatusUseCase updateOrderStatusUseCase(OrderRepository orderRepository) {
        return new UpdateOrderStatusUseCase(orderRepository);
    }

    @Bean
    public ListOrdersUseCase listOrdersUseCase(OrderRepository orderRepository) {
        return new ListOrdersUseCase(orderRepository);
    }

    @Bean
    public GetOrderByNumberUseCase getOrderByNumberUseCase(OrderRepository orderRepository) {
        return new GetOrderByNumberUseCase(orderRepository);
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/domain/CustomerInfo.java ==========
package com.flavia.dermobeauty.sales.domain;

import lombok.Value;

/**
 * Value Object representing customer information for an order.
 * Immutable to ensure consistency.
 */
@Value
public class CustomerInfo {
    String name;
    String email;
    String whatsapp;

    public CustomerInfo(String name, String email, String whatsapp) {
        if (name == null || name.isBlank()) {
            throw new IllegalArgumentException("Customer name cannot be empty");
        }
        if (email == null || email.isBlank()) {
            throw new IllegalArgumentException("Customer email cannot be empty");
        }
        if (whatsapp == null || whatsapp.isBlank()) {
            throw new IllegalArgumentException("Customer whatsapp cannot be empty");
        }

        this.name = name;
        this.email = email;
        this.whatsapp = whatsapp;
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/domain/DeliveryInfo.java ==========
package com.flavia.dermobeauty.sales.domain;

import lombok.Value;

/**
 * Value Object representing delivery information for an order.
 * Immutable to ensure consistency.
 */
@Value
public class DeliveryInfo {
    DeliveryType deliveryType;
    String address;
    String city;
    String postalCode;
    String province;
    String notes;

    public DeliveryInfo(DeliveryType deliveryType, String address, String city,
                        String postalCode, String province, String notes) {
        if (deliveryType == null) {
            throw new IllegalArgumentException("Delivery type cannot be null");
        }

        if (deliveryType == DeliveryType.HOME_DELIVERY) {
            if (address == null || address.isBlank()) {
                throw new IllegalArgumentException("Address is required for home delivery");
            }
            if (city == null || city.isBlank()) {
                throw new IllegalArgumentException("City is required for home delivery");
            }
        }

        this.deliveryType = deliveryType;
        this.address = address;
        this.city = city;
        this.postalCode = postalCode;
        this.province = province;
        this.notes = notes;
    }

    public boolean isHomeDelivery() {
        return deliveryType == DeliveryType.HOME_DELIVERY;
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/domain/DeliveryType.java ==========
package com.flavia.dermobeauty.sales.domain;

/**
 * Domain enum representing delivery method for an order.
 */
public enum DeliveryType {
    PICKUP,         // Customer picks up at location
    HOME_DELIVERY   // Delivery to customer address
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/domain/OrderItem.java ==========
package com.flavia.dermobeauty.sales.domain;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;

import java.math.BigDecimal;

/**
 * Entity representing a single item in an order.
 * Part of the Order aggregate.
 */
@Getter
@AllArgsConstructor
@Builder
public class OrderItem {

    private Long id;
    private Long productId;
    private String productName;  // Snapshot at time of order
    private BigDecimal productPrice;  // Snapshot at time of order
    private Integer quantity;
    private BigDecimal subtotal;

    /**
     * Calculate subtotal based on price and quantity.
     */
    public static BigDecimal calculateSubtotal(BigDecimal price, Integer quantity) {
        if (price == null || quantity == null || quantity <= 0) {
            throw new IllegalArgumentException("Invalid price or quantity for order item");
        }
        return price.multiply(BigDecimal.valueOf(quantity));
    }

    /**
     * Validate order item business rules.
     */
    public void validate() {
        if (productId == null) {
            throw new IllegalArgumentException("Product ID cannot be null");
        }
        if (productName == null || productName.isBlank()) {
            throw new IllegalArgumentException("Product name cannot be empty");
        }
        if (productPrice == null || productPrice.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Product price must be greater than zero");
        }
        if (quantity == null || quantity <= 0) {
            throw new IllegalArgumentException("Quantity must be greater than zero");
        }
        if (subtotal == null || subtotal.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("Subtotal cannot be negative");
        }
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/domain/Order.java ==========
package com.flavia.dermobeauty.sales.domain;

import com.flavia.dermobeauty.booking.domain.PaymentStatus;
import com.flavia.dermobeauty.shared.exception.DomainException;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Order Aggregate Root.
 * Represents a product order with business rules enforcement.
 */
@Getter
@AllArgsConstructor
@Builder
public class Order {

    private Long id;
    private String orderNumber;
    private CustomerInfo customerInfo;
    private DeliveryInfo deliveryInfo;

    @Builder.Default
    private List<OrderItem> items = new ArrayList<>();

    private BigDecimal subtotal;
    private BigDecimal deliveryCost;
    private BigDecimal total;
    private OrderStatus status;
    private PaymentStatus paymentStatus;
    private String mercadoPagoPreferenceId;
    private String mercadoPagoPaymentId;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    /**
     * Add an item to the order.
     * Business rule: can only add items to PENDING orders.
     */
    public void addItem(OrderItem item) {
        if (this.status != OrderStatus.PENDING) {
            throw new DomainException("Cannot add items to order in status: " + status);
        }

        item.validate();
        this.items.add(item);
        recalculateTotal();
    }

    /**
     * Recalculate order totals based on items and delivery cost.
     */
    public void recalculateTotal() {
        this.subtotal = items.stream()
                .map(OrderItem::getSubtotal)
                .reduce(BigDecimal.ZERO, BigDecimal::add);

        BigDecimal deliveryCostValue = deliveryCost != null ? deliveryCost : BigDecimal.ZERO;
        this.total = subtotal.add(deliveryCostValue);
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Set delivery cost for the order.
     */
    public void setDeliveryCost(BigDecimal cost) {
        if (cost == null || cost.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("Delivery cost cannot be negative");
        }
        this.deliveryCost = cost;
        recalculateTotal();
    }

    /**
     * Confirm payment for this order.
     * Business rule: can only confirm payment once, and only from PENDING status.
     */
    public void confirmPayment(String paymentId) {
        if (this.paymentStatus == PaymentStatus.PAID) {
            throw new DomainException("Payment already confirmed for order " + orderNumber);
        }

        if (this.status == OrderStatus.CANCELLED) {
            throw new DomainException("Cannot confirm payment for cancelled order " + orderNumber);
        }

        if (paymentId == null || paymentId.isBlank()) {
            throw new IllegalArgumentException("Payment ID cannot be empty");
        }

        this.mercadoPagoPaymentId = paymentId;
        this.paymentStatus = PaymentStatus.PAID;
        this.status = OrderStatus.PAID;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Update order status.
     * Business rule: cannot update cancelled or certain status transitions.
     */
    public void updateStatus(OrderStatus newStatus) {
        if (this.status == OrderStatus.CANCELLED) {
            throw new DomainException("Cannot update status of cancelled order " + orderNumber);
        }

        if (this.status == OrderStatus.DELIVERED && newStatus != OrderStatus.DELIVERED) {
            throw new DomainException("Cannot change status of delivered order " + orderNumber);
        }

        this.status = newStatus;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Cancel this order.
     * Business rule: cannot cancel delivered orders.
     */
    public void cancel() {
        if (this.status == OrderStatus.CANCELLED) {
            throw new DomainException("Order " + orderNumber + " is already cancelled");
        }

        if (this.status == OrderStatus.DELIVERED) {
            throw new DomainException("Cannot cancel delivered order " + orderNumber);
        }

        this.status = OrderStatus.CANCELLED;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Get immutable copy of items list.
     */
    public List<OrderItem> getItems() {
        return Collections.unmodifiableList(items);
    }

    /**
     * Validate order business rules.
     */
    public void validate() {
        if (items == null || items.isEmpty()) {
            throw new DomainException("Order must have at least one item");
        }

        items.forEach(OrderItem::validate);

        if (subtotal == null || subtotal.compareTo(BigDecimal.ZERO) <= 0) {
            throw new DomainException("Order subtotal must be greater than zero");
        }

        if (total == null || total.compareTo(BigDecimal.ZERO) <= 0) {
            throw new DomainException("Order total must be greater than zero");
        }
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/domain/OrderRepository.java ==========
package com.flavia.dermobeauty.sales.domain;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.List;
import java.util.Optional;

/**
 * Repository port (interface) for Order aggregate.
 * Defines operations needed by the domain layer without specifying implementation.
 * Implementation will be provided by infrastructure layer.
 */
public interface OrderRepository {

    /**
     * Save an order (create or update).
     */
    Order save(Order order);

    /**
     * Find order by ID.
     */
    Optional<Order> findById(Long id);

    /**
     * Find order by order number.
     */
    Optional<Order> findByOrderNumber(String orderNumber);

    /**
     * Find order by Mercado Pago payment ID.
     */
    Optional<Order> findByMercadoPagoPaymentId(String paymentId);

    /**
     * Find all orders (for admin).
     */
    List<Order> findAll();

    /**
     * Find all orders with pagination (for admin).
     */
    Page<Order> findAll(Pageable pageable);

    /**
     * Find orders by status (for admin filtering).
     */
    List<Order> findByStatus(OrderStatus status);
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/domain/OrderStatus.java ==========
package com.flavia.dermobeauty.sales.domain;

/**
 * Domain enum representing the lifecycle status of an order.
 */
public enum OrderStatus {
    PENDING,    // Order created, payment not yet completed
    PAID,       // Payment completed
    PREPARING,  // Order being prepared
    READY,      // Order ready for pickup/delivery
    DELIVERED,  // Order delivered to customer
    CANCELLED   // Order cancelled
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/infrastructure/delivery/DeliveryCostCalculatorImpl.java ==========
package com.flavia.dermobeauty.sales.infrastructure.delivery;

import com.flavia.dermobeauty.sales.application.port.DeliveryCostCalculator;
import com.flavia.dermobeauty.sales.domain.DeliveryType;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;

/**
 * Implementation of DeliveryCostCalculator reading from configuration.
 * For MVP, uses fixed cost from application.yml.
 * Future: could read from database config table.
 */
@Slf4j
@Service
public class DeliveryCostCalculatorImpl implements DeliveryCostCalculator {

    private final BigDecimal fixedDeliveryCost;

    public DeliveryCostCalculatorImpl(@Value("${app.delivery.fixed-cost:1500.00}") BigDecimal fixedCost) {
        this.fixedDeliveryCost = fixedCost;
        log.info("Delivery cost configured: {}", fixedCost);
    }

    @Override
    public BigDecimal calculate(DeliveryType deliveryType) {
        if (deliveryType == DeliveryType.PICKUP) {
            log.debug("Delivery cost for PICKUP: 0.00");
            return BigDecimal.ZERO;
        }

        log.debug("Delivery cost for HOME_DELIVERY: {}", fixedDeliveryCost);
        return fixedDeliveryCost;
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/infrastructure/mapper/OrderMapper.java ==========
package com.flavia.dermobeauty.sales.infrastructure.mapper;

import com.flavia.dermobeauty.sales.domain.*;
import com.flavia.dermobeauty.sales.infrastructure.persistence.OrderEntity;
import com.flavia.dermobeauty.sales.infrastructure.persistence.OrderItemEntity;
import org.springframework.stereotype.Component;

import java.util.stream.Collectors;

/**
 * Mapper between Order domain model and OrderEntity JPA entity.
 * Handles conversion in both directions including nested OrderItems.
 */
@Component
public class OrderMapper {

    /**
     * Convert domain Order to JPA OrderEntity.
     */
    public OrderEntity toEntity(Order order) {
        OrderEntity entity = OrderEntity.builder()
                .id(order.getId())
                .orderNumber(order.getOrderNumber())
                .customerName(order.getCustomerInfo().getName())
                .customerEmail(order.getCustomerInfo().getEmail())
                .customerWhatsapp(order.getCustomerInfo().getWhatsapp())
                .deliveryType(order.getDeliveryInfo().getDeliveryType())
                .deliveryAddress(order.getDeliveryInfo().getAddress())
                .deliveryCity(order.getDeliveryInfo().getCity())
                .deliveryPostalCode(order.getDeliveryInfo().getPostalCode())
                .deliveryProvince(order.getDeliveryInfo().getProvince())
                .deliveryNotes(order.getDeliveryInfo().getNotes())
                .subtotal(order.getSubtotal())
                .deliveryCost(order.getDeliveryCost())
                .total(order.getTotal())
                .status(order.getStatus())
                .paymentStatus(order.getPaymentStatus())
                .mercadoPagoPreferenceId(order.getMercadoPagoPreferenceId())
                .mercadoPagoPaymentId(order.getMercadoPagoPaymentId())
                .createdAt(order.getCreatedAt())
                .updatedAt(order.getUpdatedAt())
                .build();

        // Map items
        order.getItems().forEach(item -> {
            OrderItemEntity itemEntity = OrderItemEntity.builder()
                    .id(item.getId())
                    .productId(item.getProductId())
                    .productName(item.getProductName())
                    .productPrice(item.getProductPrice())
                    .quantity(item.getQuantity())
                    .subtotal(item.getSubtotal())
                    .build();
            entity.addItem(itemEntity);
        });

        return entity;
    }

    /**
     * Convert JPA OrderEntity to domain Order.
     */
    public Order toDomain(OrderEntity entity) {
        CustomerInfo customerInfo = new CustomerInfo(
                entity.getCustomerName(),
                entity.getCustomerEmail(),
                entity.getCustomerWhatsapp()
        );

        DeliveryInfo deliveryInfo = new DeliveryInfo(
                entity.getDeliveryType(),
                entity.getDeliveryAddress(),
                entity.getDeliveryCity(),
                entity.getDeliveryPostalCode(),
                entity.getDeliveryProvince(),
                entity.getDeliveryNotes()
        );

        Order order = Order.builder()
                .id(entity.getId())
                .orderNumber(entity.getOrderNumber())
                .customerInfo(customerInfo)
                .deliveryInfo(deliveryInfo)
                .items(entity.getItems().stream()
                        .map(this::itemToDomain)
                        .collect(Collectors.toList()))
                .subtotal(entity.getSubtotal())
                .deliveryCost(entity.getDeliveryCost())
                .total(entity.getTotal())
                .status(entity.getStatus())
                .paymentStatus(entity.getPaymentStatus())
                .mercadoPagoPreferenceId(entity.getMercadoPagoPreferenceId())
                .mercadoPagoPaymentId(entity.getMercadoPagoPaymentId())
                .createdAt(entity.getCreatedAt())
                .updatedAt(entity.getUpdatedAt())
                .build();

        return order;
    }

    private OrderItem itemToDomain(OrderItemEntity entity) {
        return OrderItem.builder()
                .id(entity.getId())
                .productId(entity.getProductId())
                .productName(entity.getProductName())
                .productPrice(entity.getProductPrice())
                .quantity(entity.getQuantity())
                .subtotal(entity.getSubtotal())
                .build();
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/infrastructure/notification/StubOrderNotificationService.java ==========
package com.flavia.dermobeauty.sales.infrastructure.notification;

import com.flavia.dermobeauty.sales.application.port.NotificationService;
import com.flavia.dermobeauty.sales.domain.Order;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

/**
 * Stub implementation of NotificationService for Phase 6.
 * Will be replaced with full email implementation in Phase 8.
 */
@Slf4j
@Service("orderNotificationService")
public class StubOrderNotificationService implements NotificationService {

    @Override
    public void sendOrderConfirmation(Order order) {
        log.info("STUB: Would send order confirmation email for {} to {}",
                order.getOrderNumber(),
                order.getCustomerInfo().getEmail());

        // No-op for now - will implement email sending in Phase 8
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/infrastructure/persistence/JpaOrderRepository.java ==========
package com.flavia.dermobeauty.sales.infrastructure.persistence;

import com.flavia.dermobeauty.sales.domain.OrderStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

/**
 * Spring Data JPA repository for OrderEntity.
 * Infrastructure implementation detail.
 */
@Repository
public interface JpaOrderRepository extends JpaRepository<OrderEntity, Long> {

    Optional<OrderEntity> findByOrderNumber(String orderNumber);

    Optional<OrderEntity> findByMercadoPagoPaymentId(String paymentId);

    List<OrderEntity> findByStatus(OrderStatus status);
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/infrastructure/persistence/OrderEntity.java ==========
package com.flavia.dermobeauty.sales.infrastructure.persistence;

import com.flavia.dermobeauty.booking.domain.PaymentStatus;
import com.flavia.dermobeauty.sales.domain.DeliveryType;
import com.flavia.dermobeauty.sales.domain.OrderStatus;
import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

/**
 * JPA entity for orders table.
 * Infrastructure layer representation of Order aggregate.
 */
@Entity
@Table(name = "orders")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class OrderEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @EqualsAndHashCode.Include
    private Long id;

    @Column(name = "order_number", nullable = false, unique = true, length = 50)
    private String orderNumber;

    // Customer information
    @Column(name = "customer_name", nullable = false, length = 200)
    private String customerName;

    @Column(name = "customer_email", nullable = false, length = 200)
    private String customerEmail;

    @Column(name = "customer_whatsapp", nullable = false, length = 50)
    private String customerWhatsapp;

    // Delivery information
    @Enumerated(EnumType.STRING)
    @Column(name = "delivery_type", nullable = false, length = 20)
    private DeliveryType deliveryType;

    @Column(name = "delivery_address_street", length = 300)
    private String deliveryAddress;

    @Column(name = "delivery_address_city", length = 100)
    private String deliveryCity;

    @Column(name = "delivery_address_postal_code", length = 20)
    private String deliveryPostalCode;

    @Column(name = "delivery_address_state", length = 100)
    private String deliveryProvince;

    @Column(name = "delivery_notes", columnDefinition = "TEXT")
    private String deliveryNotes;

    // Order items (OneToMany relationship)
    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true)
    @Builder.Default
    @ToString.Exclude
    private List<OrderItemEntity> items = new ArrayList<>();

    // Pricing
    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal subtotal;

    @Column(name = "delivery_cost", nullable = false, precision = 10, scale = 2)
    private BigDecimal deliveryCost;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal total;

    // Status tracking
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private OrderStatus status;

    // Payment information
    @Enumerated(EnumType.STRING)
    @Column(name = "payment_status", nullable = false, length = 20)
    private PaymentStatus paymentStatus;

    @Column(name = "mercadopago_preference_id", length = 200)
    private String mercadoPagoPreferenceId;

    @Column(name = "mercadopago_payment_id", length = 200)
    private String mercadoPagoPaymentId;

    // Timestamps
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = LocalDateTime.now();
        }
        if (updatedAt == null) {
            updatedAt = LocalDateTime.now();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }

    /**
     * Helper method to add item and maintain bidirectional relationship.
     */
    public void addItem(OrderItemEntity item) {
        items.add(item);
        item.setOrder(this);
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/infrastructure/persistence/OrderItemEntity.java ==========
package com.flavia.dermobeauty.sales.infrastructure.persistence;

import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * JPA entity for order_items table.
 * Part of Order aggregate in infrastructure layer.
 */
@Entity
@Table(name = "order_items")
@Getter@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class OrderItemEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @EqualsAndHashCode.Include
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id", nullable = false)
    @ToString.Exclude
    private OrderEntity order;

    @Column(name = "product_id", nullable = false)
    private Long productId;

    // Snapshot of product at time of order
    @Column(name = "product_name", nullable = false, length = 200)
    private String productName;

    @Column(name = "product_price", nullable = false, precision = 10, scale = 2)
    private BigDecimal productPrice;

    @Column(nullable = false)
    private Integer quantity;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal subtotal;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = LocalDateTime.now();
        }
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/infrastructure/persistence/OrderRepositoryAdapter.java ==========
package com.flavia.dermobeauty.sales.infrastructure.persistence;

import com.flavia.dermobeauty.sales.domain.Order;
import com.flavia.dermobeauty.sales.domain.OrderRepository;
import com.flavia.dermobeauty.sales.domain.OrderStatus;
import com.flavia.dermobeauty.sales.infrastructure.mapper.OrderMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional; // <--- IMPORTANTE

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Component
@RequiredArgsConstructor
public class OrderRepositoryAdapter implements OrderRepository {

    private final JpaOrderRepository jpaRepository;
    private final OrderMapper mapper;

    @Override
    @Transactional // Para escritura
    public Order save(Order order) {
        OrderEntity entity = mapper.toEntity(order);
        OrderEntity saved = jpaRepository.save(entity);
        return mapper.toDomain(saved);
    }

    @Override
    @Transactional(readOnly = true) // <--- AGREGAR ESTO (Mantiene la sesión DB abierta)
    public Optional<Order> findById(Long id) {
        return jpaRepository.findById(id)
                .map(mapper::toDomain);
    }

    @Override
    @Transactional(readOnly = true) // <--- AGREGAR ESTO
    public Optional<Order> findByOrderNumber(String orderNumber) {
        return jpaRepository.findByOrderNumber(orderNumber)
                .map(mapper::toDomain);
    }

    @Override
    @Transactional(readOnly = true) // <--- AGREGAR ESTO
    public Optional<Order> findByMercadoPagoPaymentId(String paymentId) {
        return jpaRepository.findByMercadoPagoPaymentId(paymentId)
                .map(mapper::toDomain);
    }

    @Override
    @Transactional(readOnly = true) // <--- AGREGAR ESTO (CRÍTICO PARA LA LISTA)
    public List<Order> findAll() {
        return jpaRepository.findAll()
                .stream()
                .map(mapper::toDomain)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public Page<Order> findAll(Pageable pageable) {
        return jpaRepository.findAll(pageable)
                .map(mapper::toDomain);
    }

    @Override
    @Transactional(readOnly = true) // <--- AGREGAR ESTO
    public List<Order> findByStatus(OrderStatus status) {
        return jpaRepository.findByStatus(status)
                .stream()
                .map(mapper::toDomain)
                .collect(Collectors.toList());
    }
}

========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/infrastructure/stock/StockServiceImpl.java ==========
package com.flavia.dermobeauty.sales.infrastructure.stock;

import com.flavia.dermobeauty.catalog.repository.ProductRepository;
import com.flavia.dermobeauty.sales.application.port.StockService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

/**
 * Implementation of StockService using product repository.
 * Manages product stock levels with pessimistic locking.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class StockServiceImpl implements StockService {

    private final ProductRepository productRepository;

    @Override
    @Transactional(readOnly = true)
    public boolean checkAvailability(Long productId, Integer quantity) {
        return productRepository.findById(productId)
                .map(p -> p.getStock() >= quantity)
                .orElse(false);
    }

    @Override
    @Transactional
    public void decrementStock(Long productId, Integer quantity) {
        int updatedRows = productRepository.decrementStock(productId, quantity);

        if (updatedRows == 0) {
             log.error("Stock update failed for product {}. Requested: {}", productId, quantity);
            throw new IllegalStateException("No hay stock suficiente para completar la operación o el producto no existe.");
        }

        log.info("Decremented stock for product {}: -{} units", productId, quantity);
    }
}

========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/web/AdminOperationsController.java ==========
package com.flavia.dermobeauty.sales.web;

import com.flavia.dermobeauty.booking.application.usecase.CancelBookingUseCase;
import com.flavia.dermobeauty.booking.application.usecase.ListBookingsUseCase;
import com.flavia.dermobeauty.booking.application.usecase.RescheduleBookingUseCase;
import com.flavia.dermobeauty.booking.domain.Booking;
import com.flavia.dermobeauty.booking.web.dto.BookingResponse;
import com.flavia.dermobeauty.sales.application.usecase.ListOrdersUseCase;
import com.flavia.dermobeauty.sales.application.usecase.UpdateOrderStatusUseCase;
import com.flavia.dermobeauty.sales.domain.Order;
import com.flavia.dermobeauty.sales.domain.OrderStatus;
import com.flavia.dermobeauty.sales.web.dto.OrderResponse;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.time.OffsetDateTime;
import java.time.ZoneId;
import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/admin")
@RequiredArgsConstructor
public class AdminOperationsController {

    private static final ZoneId ARGENTINA_ZONE = ZoneId.of("America/Argentina/Buenos_Aires");

    private final ListBookingsUseCase listBookingsUseCase;
    private final CancelBookingUseCase cancelBookingUseCase;
    private final RescheduleBookingUseCase rescheduleBookingUseCase;
    private final ListOrdersUseCase listOrdersUseCase;
    private final UpdateOrderStatusUseCase updateOrderStatusUseCase;

    // ==================== BOOKINGS ====================

    @GetMapping("/bookings")
    public ResponseEntity<ApiResponse<List<BookingResponse>>> getBookings() {
        List<BookingResponse> bookings = listBookingsUseCase.execute().stream()
                .map(BookingResponse::fromDomain)
                .collect(Collectors.toList());
        return ResponseEntity.ok(ApiResponse.success(bookings));
    }

    @DeleteMapping("/bookings/{id}")
    public ResponseEntity<ApiResponse<Void>> cancelBooking(@PathVariable Long id) {
        cancelBookingUseCase.execute(id);
        return ResponseEntity.ok(ApiResponse.success("Turno cancelado"));
    }

    @PatchMapping("/bookings/{id}/reschedule")
    public ResponseEntity<ApiResponse<BookingResponse>> rescheduleBooking(
            @PathVariable Long id,
            @RequestBody RescheduleRequest request) {
        // Convert LocalDate + LocalTime to OffsetDateTime
        OffsetDateTime newStartAt = LocalDateTime.of(request.getBookingDate(), request.getBookingTime())
                .atZone(ARGENTINA_ZONE)
                .toOffsetDateTime();

        Booking updated = rescheduleBookingUseCase.execute(id, newStartAt);
        return ResponseEntity.ok(ApiResponse.success(BookingResponse.fromDomain(updated)));
    }

    // ==================== ORDERS ====================

    @GetMapping("/orders")
    public ResponseEntity<ApiResponse<Page<OrderResponse>>> getOrders(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {
        Pageable pageable = PageRequest.of(page, size, Sort.by("id").descending());
        Page<OrderResponse> orders = listOrdersUseCase.executePaginated(pageable)
                .map(OrderResponse::fromDomain);
        return ResponseEntity.ok(ApiResponse.success(orders));
    }

    @PatchMapping("/orders/{id}/status")
    public ResponseEntity<ApiResponse<OrderResponse>> updateOrderStatus(
            @PathVariable Long id,
            @RequestBody UpdateStatusRequest request) {

        Order updated = updateOrderStatusUseCase.execute(id, request.getStatus());
        return ResponseEntity.ok(ApiResponse.success(OrderResponse.fromDomain(updated)));
    }

    @Data
    public static class UpdateStatusRequest {
        private OrderStatus status;
    }

    @Data
    public static class RescheduleRequest {
        private java.time.LocalDate bookingDate;
        private java.time.LocalTime bookingTime;
    }
}

========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/web/dto/CreateOrderRequest.java ==========
package com.flavia.dermobeauty.sales.web.dto;

import com.flavia.dermobeauty.sales.domain.DeliveryType;
import jakarta.validation.Valid;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

/**
 * DTO for creating a new order request.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateOrderRequest {

    @NotBlank(message = "Customer name is required")
    private String customerName;

    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    private String customerEmail;

    @NotBlank(message = "WhatsApp number is required")
    private String customerWhatsapp;

    @NotNull(message = "Delivery type is required")
    private DeliveryType deliveryType;

    private String deliveryAddress;
    private String deliveryCity;
    private String deliveryPostalCode;
    private String deliveryProvince;
    private String deliveryNotes;

    @NotEmpty(message = "Order must have at least one item")
    @Valid
    private List<OrderItemRequest> items;
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/web/dto/OrderItemRequest.java ==========
package com.flavia.dermobeauty.sales.web.dto;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO for order item in create order request.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderItemRequest {

    @NotNull(message = "Product ID is required")
    private Long productId;

    @NotNull(message = "Quantity is required")
    @Min(value = 1, message = "Quantity must be at least 1")
    private Integer quantity;
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/web/dto/OrderResponse.java ==========
package com.flavia.dermobeauty.sales.web.dto;

import com.flavia.dermobeauty.booking.domain.PaymentStatus;
import com.flavia.dermobeauty.sales.domain.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

/**
 * DTO for order response.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class OrderResponse {

    private Long id;
    private String orderNumber;
    private String customerName;
    private String customerEmail;
    private String customerWhatsapp;
    private DeliveryType deliveryType;
    private String deliveryAddress;
    private String deliveryCity;
    private List<OrderItemResponse> items;
    private BigDecimal subtotal;
    private BigDecimal deliveryCost;
    private BigDecimal total;
    private OrderStatus status;
    private PaymentStatus paymentStatus;
    private String mercadoPagoPreferenceId;
    private LocalDateTime createdAt;

    public static OrderResponse fromDomain(Order order) {
        return OrderResponse.builder()
                .id(order.getId())
                .orderNumber(order.getOrderNumber())
                .customerName(order.getCustomerInfo().getName())
                .customerEmail(order.getCustomerInfo().getEmail())
                .customerWhatsapp(order.getCustomerInfo().getWhatsapp())
                .deliveryType(order.getDeliveryInfo().getDeliveryType())
                .deliveryAddress(order.getDeliveryInfo().getAddress())
                .deliveryCity(order.getDeliveryInfo().getCity())
                .items(order.getItems().stream()
                        .map(OrderItemResponse::fromDomain)
                        .collect(Collectors.toList()))
                .subtotal(order.getSubtotal())
                .deliveryCost(order.getDeliveryCost())
                .total(order.getTotal())
                .status(order.getStatus())
                .paymentStatus(order.getPaymentStatus())
                .mercadoPagoPreferenceId(order.getMercadoPagoPreferenceId())
                .createdAt(order.getCreatedAt())
                .build();
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class OrderItemResponse {
        private Long productId;
        private String productName;
        private BigDecimal productPrice;
        private Integer quantity;
        private BigDecimal subtotal;

        public static OrderItemResponse fromDomain(OrderItem item) {
            return OrderItemResponse.builder()
                    .productId(item.getProductId())
                    .productName(item.getProductName())
                    .productPrice(item.getProductPrice())
                    .quantity(item.getQuantity())
                    .subtotal(item.getSubtotal())
                    .build();
        }
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/sales/web/OrderController.java ==========
package com.flavia.dermobeauty.sales.web;

import com.flavia.dermobeauty.sales.application.usecase.CreateOrderUseCase;
import com.flavia.dermobeauty.sales.application.usecase.GetOrderByNumberUseCase;
import com.flavia.dermobeauty.sales.domain.Order;
import com.flavia.dermobeauty.sales.web.dto.CreateOrderRequest;
import com.flavia.dermobeauty.sales.web.dto.OrderItemRequest;
import com.flavia.dermobeauty.sales.web.dto.OrderResponse;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

/**
 * REST controller for order operations.
 * Public endpoints for customers to create and check orders.
 */
@Slf4j
@RestController
@RequestMapping("/api/public/orders")
@RequiredArgsConstructor
public class OrderController {

    private final CreateOrderUseCase createOrderUseCase;
    private final GetOrderByNumberUseCase getOrderByNumberUseCase;

    @PostMapping
    public ResponseEntity<ApiResponse<OrderResponse>> createOrder(
            @Valid @RequestBody CreateOrderRequest request) {

        log.info("Creating order for customer: {}", request.getCustomerEmail());

        List<CreateOrderUseCase.OrderItemRequest> itemRequests = request.getItems().stream()
                .map(item -> new CreateOrderUseCase.OrderItemRequest(item.getProductId(), item.getQuantity()))
                .collect(Collectors.toList());

        Order order = createOrderUseCase.execute(
                request.getCustomerName(),
                request.getCustomerEmail(),
                request.getCustomerWhatsapp(),
                request.getDeliveryType(),
                request.getDeliveryAddress(),
                request.getDeliveryCity(),
                request.getDeliveryPostalCode(),
                request.getDeliveryProvince(),
                request.getDeliveryNotes(),
                itemRequests
        );

        OrderResponse response = OrderResponse.fromDomain(order);
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.success(response, "Order created successfully"));
    }

    @GetMapping("/{orderNumber}")
    public ResponseEntity<ApiResponse<OrderResponse>> getOrderByNumber(
            @PathVariable String orderNumber) {

        log.debug("Fetching order: {}", orderNumber);

        Order order = getOrderByNumberUseCase.execute(orderNumber);
        OrderResponse response = OrderResponse.fromDomain(order);

        return ResponseEntity.ok(ApiResponse.success(response));
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/security/config/SecurityConfig.java ==========
package com.flavia.dermobeauty.security.config;

import com.flavia.dermobeauty.security.jwt.JwtAuthenticationFilter;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.List;

/**
 * Spring Security configuration for the application.
 * Configures CORS, JWT authentication, and endpoint authorization.
 */
@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .cors(cors -> cors.configurationSource(corsConfigurationSource()))
                .csrf(csrf -> csrf.disable())
                .sessionManagement(session ->
                        session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .authorizeHttpRequests(auth -> auth
                        // Public endpoints
                        .requestMatchers("/api/public/**").permitAll()
                        .requestMatchers("/api/mp/webhook").permitAll()
                        .requestMatchers("/api/auth/login").permitAll()
                        .requestMatchers("/api/uploads/**").permitAll()
                        .requestMatchers("/api/test/**").permitAll() // TODO: Remove in production!
                        // Admin endpoints
                        .requestMatchers("/api/admin/**").hasRole("ADMIN")
                        // All other requests require authentication
                        .anyRequest().authenticated()
                )
                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(List.of("http://localhost:5173", "https://flaviadermobeauty.com","https://api.flaviadermobeauty.com"));
        configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(List.of("*"));
        configuration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/security/controller/AuthController.java ==========
package com.flavia.dermobeauty.security.controller;

import com.flavia.dermobeauty.security.dto.LoginRequest;
import com.flavia.dermobeauty.security.dto.LoginResponse;
import com.flavia.dermobeauty.security.jwt.JwtTokenProvider;
import com.flavia.dermobeauty.shared.web.ApiResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * Authentication controller for admin login.
 * Validates hardcoded credentials and returns JWT token.
 */
@Slf4j
@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
public class AuthController {

    private final JwtTokenProvider jwtTokenProvider;
    private final PasswordEncoder passwordEncoder;

    @Value("${admin.username}")
    private String adminUsername;

    @Value("${admin.password}")
    private String adminPasswordHash;

    @PostMapping("/login")
    public ResponseEntity<ApiResponse<LoginResponse>> login(@Valid @RequestBody LoginRequest request) {
        log.info("Login attempt for user: {}", request.getUsername());

        if (!adminUsername.equals(request.getUsername())) {
            log.warn("Login failed: Invalid username");
            return ResponseEntity.status(401)
                    .body(ApiResponse.success(null, "Invalid credentials"));
        }

        if (!passwordEncoder.matches(request.getPassword(), adminPasswordHash)) {
            log.warn("Login failed: Invalid password");
            return ResponseEntity.status(401)
                    .body(ApiResponse.success(null, "Invalid credentials"));
        }

        String token = jwtTokenProvider.generateToken(adminUsername);
        LoginResponse response = new LoginResponse(token, adminUsername, "ADMIN");

        log.info("Login successful for user: {}", adminUsername);
        return ResponseEntity.ok(ApiResponse.success(response));
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/security/dto/LoginRequest.java ==========
package com.flavia.dermobeauty.security.dto;

import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO for admin login request.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequest {

    @NotBlank(message = "Username is required")
    private String username;

    @NotBlank(message = "Password is required")
    private String password;
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/security/dto/LoginResponse.java ==========
package com.flavia.dermobeauty.security.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO for admin login response containing JWT token.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginResponse {

    private String token;
    private String username;
    private String role;
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/security/jwt/JwtAuthenticationFilter.java ==========
package com.flavia.dermobeauty.security.jwt;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.List;

/**
 * JWT authentication filter that intercepts requests and validates JWT tokens.
 * Runs once per request before Spring Security's filter chain.
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private static final String AUTHORIZATION_HEADER = "Authorization";
    private static final String BEARER_PREFIX = "Bearer ";

    private final JwtTokenProvider jwtTokenProvider;

    @Override
    protected void doFilterInternal(
            HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain) throws ServletException, IOException {

        try {
            String jwt = extractJwtFromRequest(request);

            if (jwt != null && jwtTokenProvider.validateToken(jwt)) {
                String username = jwtTokenProvider.getUsername(jwt);

                UsernamePasswordAuthenticationToken authentication =
                        new UsernamePasswordAuthenticationToken(
                                username,
                                null,
                                List.of(new SimpleGrantedAuthority("ROLE_ADMIN"))
                        );

                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authentication);

                log.debug("Set authentication for user: {}", username);
            }
        } catch (Exception ex) {
            log.error("Could not set user authentication in security context", ex);
        }

        filterChain.doFilter(request, response);
    }

    /**
     * Extract JWT token from Authorization header.
     *
     * @param request HTTP request
     * @return JWT token or null if not present
     */
    private String extractJwtFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader(AUTHORIZATION_HEADER);

        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith(BEARER_PREFIX)) {
            return bearerToken.substring(BEARER_PREFIX.length());
        }

        return null;
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/security/jwt/JwtTokenProvider.java ==========
package com.flavia.dermobeauty.security.jwt;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;

/**
 * Provides JWT token generation and validation functionality.
 * Uses HMAC-SHA256 signing algorithm.
 */
@Slf4j
@Component
public class JwtTokenProvider {

    private final SecretKey secretKey;
    private final long validityInMilliseconds;

    public JwtTokenProvider(
            @Value("${jwt.secret}") String secret,
            @Value("${jwt.expiration}") long validityInMilliseconds) {
        this.secretKey = Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));
        this.validityInMilliseconds = validityInMilliseconds;
    }

    /**
     * Generate JWT token for the given username.
     *
     * @param username Username to encode in the token
     * @return JWT token string
     */
    public String generateToken(String username) {
        Date now = new Date();
        Date validity = new Date(now.getTime() + validityInMilliseconds);

        return Jwts.builder()
                .subject(username)
                .issuedAt(now)
                .expiration(validity)
                .signWith(secretKey, Jwts.SIG.HS256)
                .compact();
    }

    /**
     * Extract username from JWT token.
     *
     * @param token JWT token
     * @return Username encoded in the token
     */
    public String getUsername(String token) {
        Claims claims = Jwts.parser()
                .verifyWith(secretKey)
                .build()
                .parseSignedClaims(token)
                .getPayload();

        return claims.getSubject();
    }

    /**
     * Validate JWT token.
     *
     * @param token JWT token to validate
     * @return true if valid, false otherwise
     */
    public boolean validateToken(String token) {
        try {
            Jwts.parser()
                    .verifyWith(secretKey)
                    .build()
                    .parseSignedClaims(token);
            return true;
        } catch (Exception e) {
            log.warn("Invalid JWT token: {}", e.getMessage());
            return false;
        }
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/shared/exception/ConflictException.java ==========
package com.flavia.dermobeauty.shared.exception;

/**
 * Exception for conflict errors (409).
 * Used when an operation cannot be completed due to resource conflicts
 * (e.g., time slot already occupied).
 */
public class ConflictException extends RuntimeException {

    public ConflictException(String message) {
        super(message);
    }

    public ConflictException(String message, Throwable cause) {
        super(message, cause);
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/shared/exception/DomainException.java ==========
package com.flavia.dermobeauty.shared.exception;

/**
 * Base exception for domain-level business rule violations.
 * Extends RuntimeException to avoid polluting domain layer with checked exceptions.
 */
public class DomainException extends RuntimeException {

    public DomainException(String message) {
        super(message);
    }

    public DomainException(String message, Throwable cause) {
        super(message, cause);
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/shared/exception/PaymentException.java ==========
package com.flavia.dermobeauty.shared.exception;

/**
 * Exception thrown for payment processing failures.
 * Results in HTTP 502 responses (bad gateway from payment provider).
 */
public class PaymentException extends DomainException {

    public PaymentException(String message) {
        super(message);
    }

    public PaymentException(String message, Throwable cause) {
        super(message, cause);
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/shared/exception/ResourceNotFoundException.java ==========
package com.flavia.dermobeauty.shared.exception;

/**
 * Exception thrown when a requested resource is not found.
 * Results in HTTP 404 responses.
 */
public class ResourceNotFoundException extends DomainException {

    public ResourceNotFoundException(String resourceType, Object id) {
        super(String.format("%s with id '%s' not found", resourceType, id));
    }

    public ResourceNotFoundException(String message) {
        super(message);
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/shared/exception/ValidationException.java ==========
package com.flavia.dermobeauty.shared.exception;

/**
 * Exception thrown for domain validation failures.
 * Results in HTTP 400 responses.
 */
public class ValidationException extends DomainException {

    public ValidationException(String message) {
        super(message);
    }

    public ValidationException(String message, Throwable cause) {
        super(message, cause);
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/shared/web/ApiResponse.java ==========
package com.flavia.dermobeauty.shared.web;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Generic wrapper for successful API responses.
 * Provides consistent response structure across all endpoints.
 *
 * @param <T> Type of the response data
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ApiResponse<T> {

    private boolean success;
    private T data;
    private String message;

    public static <T> ApiResponse<T> success(T data) {
        return new ApiResponse<>(true, data, null);
    }

    public static <T> ApiResponse<T> success(T data, String message) {
        return new ApiResponse<>(true, data, message);
    }

    public static <T> ApiResponse<T> success(String message) {
        return new ApiResponse<>(true, null, message);
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/shared/web/ErrorResponse.java ==========
package com.flavia.dermobeauty.shared.web;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.Map;

/**
 * Standardized error response structure for all API errors.
 * Includes timestamp, error details, and optional field-level validation errors.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ErrorResponse {

    private boolean success = false;
    private String error;
    private String message;
    private LocalDateTime timestamp;
    private String path;
    private Map<String, String> fieldErrors;

    public ErrorResponse(String error, String message, String path) {
        this.error = error;
        this.message = message;
        this.timestamp = LocalDateTime.now();
        this.path = path;
    }

    public ErrorResponse(String error, String message, String path, Map<String, String> fieldErrors) {
        this.error = error;
        this.message = message;
        this.timestamp = LocalDateTime.now();
        this.path = path;
        this.fieldErrors = fieldErrors;
    }
}


========== FILE: ./src/main/java/com/flavia/dermobeauty/shared/web/GlobalExceptionHandler.java ==========
package com.flavia.dermobeauty.shared.web;

import com.flavia.dermobeauty.shared.exception.ConflictException;
import com.flavia.dermobeauty.shared.exception.DomainException;
import com.flavia.dermobeauty.shared.exception.PaymentException;
import com.flavia.dermobeauty.shared.exception.ResourceNotFoundException;
import com.flavia.dermobeauty.shared.exception.ValidationException;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.HashMap;
import java.util.Map;

/**
 * Global exception handler for all REST controllers.
 * Provides consistent error responses across the application.
 */
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleResourceNotFound(
            ResourceNotFoundException ex,
            HttpServletRequest request) {

        log.warn("Resource not found: {}", ex.getMessage());

        ErrorResponse error = new ErrorResponse(
                "NOT_FOUND",
                ex.getMessage(),
                request.getRequestURI()
        );

        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }

    @ExceptionHandler(ValidationException.class)
    public ResponseEntity<ErrorResponse> handleValidation(
            ValidationException ex,
            HttpServletRequest request) {

        log.warn("Validation error: {}", ex.getMessage());

        ErrorResponse error = new ErrorResponse(
                "VALIDATION_ERROR",
                ex.getMessage(),
                request.getRequestURI()
        );

        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleMethodArgumentNotValid(
            MethodArgumentNotValidException ex,
            HttpServletRequest request) {

        Map<String, String> fieldErrors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach(error -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            fieldErrors.put(fieldName, errorMessage);
        });

        log.warn("Bean validation failed: {}", fieldErrors);

        ErrorResponse error = new ErrorResponse(
                "VALIDATION_ERROR",
                "Invalid request data",
                request.getRequestURI(),
                fieldErrors
        );

        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }

    @ExceptionHandler(PaymentException.class)
    public ResponseEntity<ErrorResponse> handlePayment(
            PaymentException ex,
            HttpServletRequest request) {

        log.error("Payment processing error: {}", ex.getMessage(), ex);

        ErrorResponse error = new ErrorResponse(
                "PAYMENT_ERROR",
                ex.getMessage(),
                request.getRequestURI()
        );

        return ResponseEntity.status(HttpStatus.BAD_GATEWAY).body(error);
    }

    @ExceptionHandler(ConflictException.class)
    public ResponseEntity<ErrorResponse> handleConflict(
            ConflictException ex,
            HttpServletRequest request) {

        log.warn("Conflict error: {}", ex.getMessage());

        ErrorResponse error = new ErrorResponse(
                "CONFLICT",
                ex.getMessage(),
                request.getRequestURI()
        );

        return ResponseEntity.status(HttpStatus.CONFLICT).body(error);
    }

    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ErrorResponse> handleDataIntegrityViolation(
            DataIntegrityViolationException ex,
            HttpServletRequest request) {

        // Check if this is a slot_occupied trigger exception
        String message = ex.getMostSpecificCause().getMessage();
        if (message != null && message.contains("slot_occupied")) {
            log.warn("Slot collision detected by DB trigger: {}", message);

            ErrorResponse error = new ErrorResponse(
                    "CONFLICT",
                    "El horario seleccionado ya está ocupado",
                    request.getRequestURI()
            );

            return ResponseEntity.status(HttpStatus.CONFLICT).body(error);
        }

        // For other data integrity violations, log and return generic error
        log.error("Data integrity violation: {}", ex.getMessage(), ex);

        ErrorResponse error = new ErrorResponse(
                "DATA_INTEGRITY_ERROR",
                "Error de integridad de datos",
                request.getRequestURI()
        );

        return ResponseEntity.status(HttpStatus.CONFLICT).body(error);
    }

    @ExceptionHandler(DomainException.class)
    public ResponseEntity<ErrorResponse> handleDomain(
            DomainException ex,
            HttpServletRequest request) {

        log.warn("Domain exception: {}", ex.getMessage());

        ErrorResponse error = new ErrorResponse(
                "BUSINESS_RULE_VIOLATION",
                ex.getMessage(),
                request.getRequestURI()
        );

        return ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY).body(error);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneral(
            Exception ex,
            HttpServletRequest request) {

        log.error("Unexpected error", ex);

        ErrorResponse error = new ErrorResponse(
                "INTERNAL_ERROR",
                "An unexpected error occurred. Please try again later.",
                request.getRequestURI()
        );

        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}


========== FILE: ./src/main/resources/application-dev.yml ==========
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/dermobeauty_dev
    username: dermobeauty
    password: dermobeauty
    driver-class-name: org.postgresql.Driver
  jpa:
    show-sql: true
    properties:
      hibernate:
        format_sql: false
  mail:
    host: smtp.gmail.com
    port: 587
    username: 'flavia.dermobeauty@gmail.com'
    password: 'qajp ptwr gdjg uozl'
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true
            required: true
          connectiontimeout: 5000
          timeout: 5000
          writetimeout: 5000

# Admin credentials (change in production!)
admin:
  username: admin
  # BCrypt hash for "admin123" (verified)
  password: $2a$10$OQlalRpvK3/0ikEa3xO62ujds5OHSF723wIXh3gIk7ca7nJmp0c9q

# JWT configuration
jwt:
  secret: flavia-dermobeauty-jwt-secret-key-change-in-production-2024
  expiration: 86400000 # 24 hours in milliseconds

# Mercado Pago configuration
mercadopago:
  access-token: APP_USR-3480197543728175-092819-981988e8773a0af18511e1e610ba5f23-2719878562
  base-url: https://flaviadermobeauty.com

# Application settings
app:
  api-url: https://api.flaviadermobeauty.com
  upload-dir: ./uploads
  email:
    from: flavia.dermobeauty@gmail.com
    from-name: Flavia Dermobeauty
  delivery:
    fixed-cost: 1500.00

# Logging
logging:
  level:
    com.flavia.dermobeauty: DEBUG
    org.springframework.web: INFO
    org.hibernate.SQL: DEBUG


========== FILE: ./src/main/resources/application.yml ==========
spring:
  application:
    name: dermobeauty
  profiles:
    active: dev
  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: false
    open-in-view: false
  flyway:
    enabled: true
    baseline-on-migrate: true
  servlet:
    multipart:
      max-file-size: 5MB
      max-request-size: 10MB

server:
  port: 8080
  error:
    include-message: always
    include-binding-errors: always


========== FILE: ./src/main/resources/db/migration/V10__create_blocks_table.sql ==========
-- V10: Create blocks table for schedule blocking
-- Blocks are separate from bookings (not "fake bookings")

CREATE TABLE blocks (
    id BIGSERIAL PRIMARY KEY,
    block_number VARCHAR(50) NOT NULL UNIQUE,
    reason VARCHAR(500) NOT NULL,

    -- Time range (both stored as TIMESTAMPTZ for timezone safety)
    start_at TIMESTAMPTZ NOT NULL,
    end_at TIMESTAMPTZ NOT NULL,

    -- Status (ACTIVE or CANCELLED)
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE'
        CHECK (status IN ('ACTIVE', 'CANCELLED')),

    -- Timestamps
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    cancelled_at TIMESTAMPTZ,

    -- Constraints
    CONSTRAINT chk_block_end_after_start CHECK (end_at > start_at),
    CONSTRAINT chk_block_aligned_start CHECK (EXTRACT(MINUTE FROM start_at) IN (0, 30)),
    CONSTRAINT chk_block_aligned_end CHECK (EXTRACT(MINUTE FROM end_at) IN (0, 30))
);

-- Indexes for performance
CREATE INDEX idx_blocks_number ON blocks(block_number);
CREATE INDEX idx_blocks_status ON blocks(status);
CREATE INDEX idx_blocks_start_at ON blocks(start_at);
CREATE INDEX idx_blocks_time_range ON blocks(start_at, end_at);

-- Partial index for active blocks (used in collision queries)
CREATE INDEX idx_blocks_active ON blocks(start_at, end_at) WHERE status = 'ACTIVE';

-- Comments
COMMENT ON TABLE blocks IS 'Schedule blocks for holidays, personal days, etc. Separate from bookings.';
COMMENT ON COLUMN blocks.block_number IS 'Human-readable reference (BLOCK-{ULID})';
COMMENT ON COLUMN blocks.reason IS 'Reason for blocking (e.g., "Feriado", "Vacaciones")';
COMMENT ON COLUMN blocks.start_at IS 'Block start time with timezone (TIMESTAMPTZ)';
COMMENT ON COLUMN blocks.end_at IS 'Block end time with timezone (TIMESTAMPTZ)';


========== FILE: ./src/main/resources/db/migration/V11__add_booking_datetime_columns.sql ==========
-- V11: Add start_at and service_name to bookings
-- Also update status CHECK to include BLOCKED (backward compatibility during migration)

-- 1. Add new columns (nullable initially for migration)
ALTER TABLE bookings ADD COLUMN start_at TIMESTAMPTZ;
ALTER TABLE bookings ADD COLUMN service_name VARCHAR(200);

-- 2. Populate start_at from booking_date + booking_time (assume Buenos Aires timezone)
UPDATE bookings
SET start_at = (booking_date + booking_time) AT TIME ZONE 'America/Argentina/Buenos_Aires';

-- 3. Populate service_name from services table
UPDATE bookings b
SET service_name = s.name
FROM services s
WHERE b.service_id = s.id;

-- 4. Make start_at NOT NULL (service_name can be null for BLOCKED bookings)
ALTER TABLE bookings ALTER COLUMN start_at SET NOT NULL;

-- 5. Update status CHECK constraint to include BLOCKED
ALTER TABLE bookings DROP CONSTRAINT IF EXISTS bookings_status_check;
ALTER TABLE bookings ADD CONSTRAINT bookings_status_check
    CHECK (status IN ('PENDING', 'CONFIRMED', 'CANCELLED', 'COMPLETED', 'BLOCKED'));

-- 6. Fix existing duration_minutes to be multiples of 30 (round up)
-- e.g., 45 -> 60, 50 -> 60
UPDATE bookings
SET duration_minutes = CEIL(duration_minutes::numeric / 30) * 30
WHERE duration_minutes % 30 != 0;

-- Also fix services table durations
UPDATE services
SET duration_minutes = CEIL(duration_minutes::numeric / 30) * 30
WHERE duration_minutes % 30 != 0;

-- 7. Add constraint for slot alignment (30 min intervals)
ALTER TABLE bookings ADD CONSTRAINT chk_booking_aligned_start
    CHECK (EXTRACT(MINUTE FROM start_at) IN (0, 30));

-- 8. Add constraint for duration (multiple of 30)
ALTER TABLE bookings ADD CONSTRAINT chk_booking_duration_aligned
    CHECK (duration_minutes > 0 AND duration_minutes % 30 = 0);

-- 9. Indexes for new columns
CREATE INDEX idx_bookings_start_at ON bookings(start_at);

-- Partial index for bookings that "occupy" time slots (for collision queries)
CREATE INDEX idx_bookings_occupying ON bookings(start_at, duration_minutes)
    WHERE status IN ('PENDING', 'CONFIRMED');

-- Comments
COMMENT ON COLUMN bookings.start_at IS 'Booking start time with timezone (TIMESTAMPTZ). Replaces booking_date + booking_time.';
COMMENT ON COLUMN bookings.service_name IS 'Snapshot of service name at booking creation (immutable for historical accuracy)';


========== FILE: ./src/main/resources/db/migration/V12__create_booking_history_table.sql ==========
-- V12: Create booking_history table for audit trail
-- Append-only table: records are never modified or deleted

CREATE TABLE booking_history (
    id BIGSERIAL PRIMARY KEY,
    booking_id BIGINT NOT NULL REFERENCES bookings(id) ON DELETE CASCADE,

    -- Event type enum (stored as string for flexibility)
    event_type VARCHAR(30) NOT NULL
        CHECK (event_type IN ('CREATED', 'STATUS_CHANGED', 'RESCHEDULED', 'CUSTOMER_UPDATED', 'PAYMENT_UPDATED')),

    -- Who made the change
    actor VARCHAR(20) NOT NULL
        CHECK (actor IN ('ADMIN', 'SYSTEM', 'CUSTOMER')),

    -- What changed (JSON diff)
    payload JSONB,

    -- When it happened (TIMESTAMPTZ for timezone safety)
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Indexes for performance
CREATE INDEX idx_booking_history_booking_id ON booking_history(booking_id);
CREATE INDEX idx_booking_history_event_type ON booking_history(event_type);
CREATE INDEX idx_booking_history_created_at ON booking_history(created_at);

-- GIN index for JSONB payload queries (optional, for future auditing)
CREATE INDEX idx_booking_history_payload ON booking_history USING GIN (payload);

-- Comments
COMMENT ON TABLE booking_history IS 'Audit trail for booking changes. Append-only: never modify or delete records.';
COMMENT ON COLUMN booking_history.event_type IS 'Type of change: CREATED, STATUS_CHANGED, RESCHEDULED, CUSTOMER_UPDATED, PAYMENT_UPDATED';
COMMENT ON COLUMN booking_history.actor IS 'Who made the change: ADMIN, SYSTEM, or CUSTOMER';
COMMENT ON COLUMN booking_history.payload IS 'JSON diff of what changed (e.g., {"old_status": "PENDING", "new_status": "CONFIRMED"})';


========== FILE: ./src/main/resources/db/migration/V13__create_collision_triggers.sql ==========
-- V13: Create triggers for collision detection (concurrency safety)
-- This ensures no double-booking even under concurrent requests

-- Create a lock table for serializing collision checks
CREATE TABLE agenda_lock (
    id INTEGER PRIMARY KEY DEFAULT 1,
    CONSTRAINT single_row CHECK (id = 1)
);
INSERT INTO agenda_lock (id) VALUES (1);

-- Function to check booking collision
CREATE OR REPLACE FUNCTION check_booking_collision()
RETURNS TRIGGER AS $$
DECLARE
    new_end_at TIMESTAMPTZ;
    collision_count INTEGER;
BEGIN
    -- Only check for bookings that "occupy" time (PENDING or CONFIRMED)
    IF NEW.status NOT IN ('PENDING', 'CONFIRMED') THEN
        RETURN NEW;
    END IF;

    -- Calculate end time
    new_end_at := NEW.start_at + (NEW.duration_minutes * INTERVAL '1 minute');

    -- Acquire advisory lock for serialization (prevents race conditions)
    PERFORM pg_advisory_xact_lock(hashtext('agenda_collision'));

    -- Check collision with other bookings that occupy time
    SELECT COUNT(*) INTO collision_count
    FROM bookings b
    WHERE b.status IN ('PENDING', 'CONFIRMED')
      AND b.id IS DISTINCT FROM NEW.id  -- Exclude self (for updates/reschedule)
      AND b.start_at < new_end_at
      AND (b.start_at + (b.duration_minutes * INTERVAL '1 minute')) > NEW.start_at;

    IF collision_count > 0 THEN
        RAISE EXCEPTION 'slot_occupied: Time slot conflicts with existing booking'
            USING ERRCODE = '23P01';  -- exclusion_violation
    END IF;

    -- Check collision with active blocks
    SELECT COUNT(*) INTO collision_count
    FROM blocks bl
    WHERE bl.status = 'ACTIVE'
      AND bl.start_at < new_end_at
      AND bl.end_at > NEW.start_at;

    IF collision_count > 0 THEN
        RAISE EXCEPTION 'slot_occupied: Time slot conflicts with existing block'
            USING ERRCODE = '23P01';
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Function to check block collision
CREATE OR REPLACE FUNCTION check_block_collision()
RETURNS TRIGGER AS $$
DECLARE
    collision_count INTEGER;
BEGIN
    -- Only check for ACTIVE blocks
    IF NEW.status != 'ACTIVE' THEN
        RETURN NEW;
    END IF;

    -- Acquire advisory lock for serialization
    PERFORM pg_advisory_xact_lock(hashtext('agenda_collision'));

    -- Check collision with bookings that occupy time
    SELECT COUNT(*) INTO collision_count
    FROM bookings b
    WHERE b.status IN ('PENDING', 'CONFIRMED')
      AND b.start_at < NEW.end_at
      AND (b.start_at + (b.duration_minutes * INTERVAL '1 minute')) > NEW.start_at;

    IF collision_count > 0 THEN
        RAISE EXCEPTION 'slot_occupied: Block conflicts with existing booking'
            USING ERRCODE = '23P01';
    END IF;

    -- Check collision with other active blocks
    SELECT COUNT(*) INTO collision_count
    FROM blocks bl
    WHERE bl.status = 'ACTIVE'
      AND bl.id IS DISTINCT FROM NEW.id  -- Exclude self (for updates)
      AND bl.start_at < NEW.end_at
      AND bl.end_at > NEW.start_at;

    IF collision_count > 0 THEN
        RAISE EXCEPTION 'slot_occupied: Block conflicts with existing block'
            USING ERRCODE = '23P01';
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create triggers
CREATE TRIGGER trg_check_booking_collision
    BEFORE INSERT OR UPDATE ON bookings
    FOR EACH ROW
    EXECUTE FUNCTION check_booking_collision();

CREATE TRIGGER trg_check_block_collision
    BEFORE INSERT OR UPDATE ON blocks
    FOR EACH ROW
    EXECUTE FUNCTION check_block_collision();

-- Drop the old unique index that was per-service (we use global collision now)
DROP INDEX IF EXISTS idx_bookings_unique_slot;

-- Comments
COMMENT ON FUNCTION check_booking_collision() IS 'Trigger function to prevent booking collisions (double-booking). Uses advisory lock for concurrency safety.';
COMMENT ON FUNCTION check_block_collision() IS 'Trigger function to prevent block collisions. Uses advisory lock for concurrency safety.';


========== FILE: ./src/main/resources/db/migration/V14__migrate_blocked_to_blocks.sql ==========
-- V14: Migrate BLOCKED bookings to blocks table and remove BLOCKED status

-- 1. Insert all BLOCKED bookings into blocks table
INSERT INTO blocks (block_number, reason, start_at, end_at, status, created_at, updated_at)
SELECT
    'BLOCK-' || UPPER(SUBSTRING(MD5(RANDOM()::text) FROM 1 FOR 8)) as block_number,
    COALESCE(customer_comments, 'Migrado de sistema anterior') as reason,
    COALESCE(start_at, (booking_date + booking_time) AT TIME ZONE 'America/Argentina/Buenos_Aires') as start_at,
    -- For full-day blocks, end_at is start of next day; otherwise add duration
    CASE
        WHEN duration_minutes >= 600 THEN -- 10+ hours = likely full day block
            (COALESCE(start_at, (booking_date + booking_time) AT TIME ZONE 'America/Argentina/Buenos_Aires'))::date + INTERVAL '1 day'
        ELSE
            COALESCE(start_at, (booking_date + booking_time) AT TIME ZONE 'America/Argentina/Buenos_Aires')
            + (duration_minutes * INTERVAL '1 minute')
    END as end_at,
    'ACTIVE' as status,
    created_at,
    updated_at
FROM bookings
WHERE status = 'BLOCKED';

-- 2. Delete BLOCKED bookings from bookings table
DELETE FROM bookings WHERE status = 'BLOCKED';

-- 3. Drop and recreate status check constraint WITHOUT 'BLOCKED'
ALTER TABLE bookings DROP CONSTRAINT IF EXISTS bookings_status_check;
ALTER TABLE bookings ADD CONSTRAINT bookings_status_check
    CHECK (status IN ('PENDING', 'CONFIRMED', 'CANCELLED', 'COMPLETED'));

-- 4. Update the collision trigger to NOT check for BLOCKED status
-- (since BLOCKED no longer exists in bookings table)
CREATE OR REPLACE FUNCTION check_booking_collision()
RETURNS TRIGGER AS $$
DECLARE
    conflict_count INTEGER;
    new_end_at TIMESTAMPTZ;
BEGIN
    -- Acquire advisory lock for serialization
    PERFORM pg_advisory_xact_lock(hashtext('booking_collision'));

    -- Calculate end time
    new_end_at := NEW.start_at + (NEW.duration_minutes * INTERVAL '1 minute');

    -- Only check if booking occupies time (PENDING or CONFIRMED)
    IF NEW.status NOT IN ('PENDING', 'CONFIRMED') THEN
        RETURN NEW;
    END IF;

    -- Check collision with other bookings that occupy time
    SELECT COUNT(*) INTO conflict_count
    FROM bookings b
    WHERE b.id IS DISTINCT FROM NEW.id
    AND b.status IN ('PENDING', 'CONFIRMED')
    AND b.start_at < new_end_at
    AND (b.start_at + (b.duration_minutes * INTERVAL '1 minute')) > NEW.start_at;

    IF conflict_count > 0 THEN
        RAISE EXCEPTION 'slot_occupied' USING ERRCODE = '23P01';
    END IF;

    -- Check collision with active blocks
    SELECT COUNT(*) INTO conflict_count
    FROM blocks bl
    WHERE bl.status = 'ACTIVE'
    AND bl.start_at < new_end_at
    AND bl.end_at > NEW.start_at;

    IF conflict_count > 0 THEN
        RAISE EXCEPTION 'slot_occupied' USING ERRCODE = '23P01';
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 5. Log migration
DO $$
DECLARE
    migrated_count INTEGER;
BEGIN
    SELECT COUNT(*) INTO migrated_count FROM blocks WHERE reason = 'Migrado de sistema anterior';
    RAISE NOTICE 'Migrated % BLOCKED bookings to blocks table', migrated_count;
END $$;


========== FILE: ./src/main/resources/db/migration/V1__create_categories_table.sql ==========
-- Categories table for both services and products
CREATE TABLE categories (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    slug VARCHAR(100) NOT NULL UNIQUE,
    description TEXT,
    type VARCHAR(20) NOT NULL CHECK (type IN ('SERVICE', 'PRODUCT')),
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Indexes
CREATE INDEX idx_categories_type ON categories(type);
CREATE INDEX idx_categories_slug ON categories(slug);

-- Comments
COMMENT ON TABLE categories IS 'Categories for organizing services and products';
COMMENT ON COLUMN categories.type IS 'Type of category: SERVICE or PRODUCT';


========== FILE: ./src/main/resources/db/migration/V2__create_services_table.sql ==========
-- Services table for bookable beauty/dermatology treatments
CREATE TABLE services (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    slug VARCHAR(200) NOT NULL UNIQUE,
    description TEXT NOT NULL,
    short_description VARCHAR(500),
    duration_minutes INTEGER NOT NULL,
    price DECIMAL(10, 2) NOT NULL,
    category_id BIGINT REFERENCES categories(id),
    is_featured BOOLEAN NOT NULL DEFAULT FALSE,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    image_url VARCHAR(500),
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT chk_duration_positive CHECK (duration_minutes > 0),
    CONSTRAINT chk_price_positive CHECK (price >= 0)
);

-- Indexes
CREATE INDEX idx_services_category ON services(category_id);
CREATE INDEX idx_services_featured ON services(is_featured) WHERE is_featured = TRUE;
CREATE INDEX idx_services_active ON services(is_active) WHERE is_active = TRUE;
CREATE INDEX idx_services_slug ON services(slug);

-- Comments
COMMENT ON TABLE services IS 'Beauty and dermatology services available for booking';
COMMENT ON COLUMN services.duration_minutes IS 'Duration of the service in minutes';
COMMENT ON COLUMN services.is_featured IS 'Whether to show this service on the homepage';


========== FILE: ./src/main/resources/db/migration/V3__create_products_table.sql ==========
-- Products table for beauty/dermatology products sold via e-commerce
CREATE TABLE products (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    slug VARCHAR(200) NOT NULL UNIQUE,
    description TEXT NOT NULL,
    short_description VARCHAR(500),
    price DECIMAL(10, 2) NOT NULL,
    stock INTEGER NOT NULL DEFAULT 0,
    category_id BIGINT REFERENCES categories(id),
    is_featured BOOLEAN NOT NULL DEFAULT FALSE,
    is_offer BOOLEAN NOT NULL DEFAULT FALSE,
    is_trending BOOLEAN NOT NULL DEFAULT FALSE,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    image_url VARCHAR(500),
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT chk_stock_non_negative CHECK (stock >= 0),
    CONSTRAINT chk_price_positive CHECK (price >= 0)
);

-- Indexes
CREATE INDEX idx_products_category ON products(category_id);
CREATE INDEX idx_products_featured ON products(is_featured) WHERE is_featured = TRUE;
CREATE INDEX idx_products_trending ON products(is_trending) WHERE is_trending = TRUE;
CREATE INDEX idx_products_offer ON products(is_offer) WHERE is_offer = TRUE;
CREATE INDEX idx_products_active ON products(is_active) WHERE is_active = TRUE;
CREATE INDEX idx_products_slug ON products(slug);

-- Comments
COMMENT ON TABLE products IS 'Beauty and dermatology products available for purchase';
COMMENT ON COLUMN products.stock IS 'Available inventory (decremented on confirmed orders)';
COMMENT ON COLUMN products.is_featured IS 'Whether to show this product on the homepage';
COMMENT ON COLUMN products.is_offer IS 'Whether this product is currently on sale/offer';
COMMENT ON COLUMN products.is_trending IS 'Whether this product is marked as trending';


========== FILE: ./src/main/resources/db/migration/V4__create_bookings_table.sql ==========
-- Bookings table for service appointments
CREATE TABLE bookings (
    id BIGSERIAL PRIMARY KEY,
    booking_number VARCHAR(50) NOT NULL UNIQUE,
    service_id BIGINT NOT NULL REFERENCES services(id),

    -- Customer information
    customer_name VARCHAR(200) NOT NULL,
    customer_email VARCHAR(200) NOT NULL,
    customer_whatsapp VARCHAR(50) NOT NULL,
    customer_comments TEXT,

    -- Booking details
    booking_date DATE NOT NULL,
    booking_time TIME NOT NULL,
    duration_minutes INTEGER NOT NULL,

    -- Status tracking
    status VARCHAR(20) NOT NULL DEFAULT 'PENDING'
        CHECK (status IN ('PENDING', 'CONFIRMED', 'CANCELLED', 'COMPLETED')),

    -- Payment information
    payment_status VARCHAR(20) NOT NULL DEFAULT 'PENDING'
        CHECK (payment_status IN ('PENDING', 'PAID', 'FAILED', 'REFUNDED')),
    mercadopago_preference_id VARCHAR(200),
    mercadopago_payment_id VARCHAR(200),
    amount DECIMAL(10, 2) NOT NULL,

    -- Timestamps
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    confirmed_at TIMESTAMP,
    cancelled_at TIMESTAMP,

    CONSTRAINT chk_amount_positive CHECK (amount >= 0)
);

-- Indexes for performance
CREATE INDEX idx_bookings_number ON bookings(booking_number);
CREATE INDEX idx_bookings_service ON bookings(service_id);
CREATE INDEX idx_bookings_date ON bookings(booking_date);
CREATE INDEX idx_bookings_status ON bookings(status);
CREATE INDEX idx_bookings_payment_status ON bookings(payment_status);
CREATE INDEX idx_bookings_customer_email ON bookings(customer_email);
CREATE INDEX idx_bookings_mp_payment ON bookings(mercadopago_payment_id) WHERE mercadopago_payment_id IS NOT NULL;

-- Prevent double-booking: same service, date, and time (excluding cancelled bookings)
CREATE UNIQUE INDEX idx_bookings_unique_slot ON bookings(service_id, booking_date, booking_time)
    WHERE status != 'CANCELLED';

-- Comments
COMMENT ON TABLE bookings IS 'Service appointments/bookings with payment tracking';
COMMENT ON COLUMN bookings.booking_number IS 'Human-readable booking reference (e.g., BOOK-20241205-001)';
COMMENT ON COLUMN bookings.mercadopago_preference_id IS 'Mercado Pago preference ID for payment';
COMMENT ON COLUMN bookings.mercadopago_payment_id IS 'Mercado Pago payment ID after successful payment';
-- Note: idx_bookings_unique_slot is a unique index that prevents double-booking the same time slot


========== FILE: ./src/main/resources/db/migration/V5__create_orders_table.sql ==========
-- Orders table for product purchases
CREATE TABLE orders (
    id BIGSERIAL PRIMARY KEY,
    order_number VARCHAR(50) NOT NULL UNIQUE,

    -- Customer information
    customer_name VARCHAR(200) NOT NULL,
    customer_email VARCHAR(200) NOT NULL,
    customer_whatsapp VARCHAR(50) NOT NULL,

    -- Delivery information
    delivery_type VARCHAR(20) NOT NULL CHECK (delivery_type IN ('PICKUP', 'HOME_DELIVERY')),
    delivery_address_street VARCHAR(300),
    delivery_address_city VARCHAR(100),
    delivery_address_state VARCHAR(100),
    delivery_address_postal_code VARCHAR(20),
    delivery_notes TEXT,

    -- Pricing
    subtotal DECIMAL(10, 2) NOT NULL,
    delivery_cost DECIMAL(10, 2) NOT NULL DEFAULT 0,
    total DECIMAL(10, 2) NOT NULL,

    -- Status tracking
    status VARCHAR(20) NOT NULL DEFAULT 'PENDING'
        CHECK (status IN ('PENDING', 'PAID', 'PREPARING', 'READY', 'DELIVERED', 'CANCELLED')),
    payment_status VARCHAR(20) NOT NULL DEFAULT 'PENDING'
        CHECK (payment_status IN ('PENDING', 'PAID', 'FAILED', 'REFUNDED')),

    -- Payment information
    mercadopago_preference_id VARCHAR(200),
    mercadopago_payment_id VARCHAR(200),

    -- Timestamps
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    paid_at TIMESTAMP,
    delivered_at TIMESTAMP,

    CONSTRAINT chk_subtotal_positive CHECK (subtotal >= 0),
    CONSTRAINT chk_delivery_cost_non_negative CHECK (delivery_cost >= 0),
    CONSTRAINT chk_total_positive CHECK (total >= 0)
);

-- Indexes for performance
CREATE INDEX idx_orders_number ON orders(order_number);
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_orders_payment_status ON orders(payment_status);
CREATE INDEX idx_orders_customer_email ON orders(customer_email);
CREATE INDEX idx_orders_created_at ON orders(created_at DESC);
CREATE INDEX idx_orders_mp_payment ON orders(mercadopago_payment_id) WHERE mercadopago_payment_id IS NOT NULL;

-- Comments
COMMENT ON TABLE orders IS 'Product orders with delivery and payment tracking';
COMMENT ON COLUMN orders.order_number IS 'Human-readable order reference (e.g., ORD-20241205-001)';
COMMENT ON COLUMN orders.delivery_type IS 'PICKUP: pickup at office, HOME_DELIVERY: delivery to address';
COMMENT ON COLUMN orders.subtotal IS 'Sum of all order items (before delivery cost)';
COMMENT ON COLUMN orders.total IS 'Final amount including delivery cost';


========== FILE: ./src/main/resources/db/migration/V6__create_order_items_table.sql ==========
-- Order items table for products in each order
CREATE TABLE order_items (
    id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
    product_id BIGINT NOT NULL REFERENCES products(id),

    -- Snapshot of product at time of order (preserves historical data)
    product_name VARCHAR(200) NOT NULL,
    product_price DECIMAL(10, 2) NOT NULL,

    -- Quantity and pricing
    quantity INTEGER NOT NULL,
    subtotal DECIMAL(10, 2) NOT NULL,

    -- Timestamps
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT chk_quantity_positive CHECK (quantity > 0),
    CONSTRAINT chk_product_price_non_negative CHECK (product_price >= 0),
    CONSTRAINT chk_subtotal_non_negative CHECK (subtotal >= 0)
);

-- Indexes for performance
CREATE INDEX idx_order_items_order ON order_items(order_id);
CREATE INDEX idx_order_items_product ON order_items(product_id);

-- Comments
COMMENT ON TABLE order_items IS 'Line items for each order with product snapshot';
COMMENT ON COLUMN order_items.product_name IS 'Product name at time of order (snapshot for history)';
COMMENT ON COLUMN order_items.product_price IS 'Product price at time of order (snapshot for history)';
COMMENT ON COLUMN order_items.subtotal IS 'Calculated as quantity * product_price';


========== FILE: ./src/main/resources/db/migration/V7__create_config_table.sql ==========
-- Application configuration table (key-value store)
CREATE TABLE app_config (
    id BIGSERIAL PRIMARY KEY,
    config_key VARCHAR(100) NOT NULL UNIQUE,
    config_value TEXT NOT NULL,
    description TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Indexes
CREATE INDEX idx_config_key ON app_config(config_key);

-- Comments
COMMENT ON TABLE app_config IS 'Application configuration settings (editable via admin panel)';
COMMENT ON COLUMN app_config.config_key IS 'Unique configuration key (e.g., site.name, delivery.fixed_cost)';
COMMENT ON COLUMN app_config.config_value IS 'Configuration value as text (parse as needed)';


========== FILE: ./src/main/resources/db/migration/V8__insert_initial_data.sql ==========
-- =====================================================
-- DATOS INICIALES - FLAVIA DERMOBEAUTY
-- Contenido en ESPAÑOL según especificación del proyecto
-- =====================================================

-- =====================================================
-- CATEGORÍAS
-- =====================================================

INSERT INTO categories (name, slug, description, type) VALUES
    ('Tratamientos Faciales', 'tratamientos-faciales', 'Tratamientos especializados para el cuidado y rejuvenecimiento del rostro', 'SERVICE'),
    ('Tratamientos Corporales', 'tratamientos-corporales', 'Tratamientos para el cuidado y embellecimiento del cuerpo', 'SERVICE'),
    ('Cuidado Facial', 'cuidado-facial', 'Productos especializados para el cuidado de la piel del rostro', 'PRODUCT'),
    ('Cuidado Corporal', 'cuidado-corporal', 'Productos para el cuidado integral de la piel del cuerpo', 'PRODUCT');

-- =====================================================
-- SERVICIOS DE EJEMPLO
-- =====================================================

INSERT INTO services (name, slug, description, short_description, duration_minutes, price, category_id, is_featured, is_active) VALUES
    (
        'Limpieza Facial Profunda',
        'limpieza-facial-profunda',
        'Tratamiento completo de limpieza facial que incluye: exfoliación, extracción de impurezas, aplicación de máscara purificante y hidratación profunda. Ideal para todo tipo de piel.',
        'Limpieza profunda con extracción y máscara purificante',
        60,
        12000.00,
        (SELECT id FROM categories WHERE slug = 'tratamientos-faciales'),
        TRUE,
        TRUE
    ),
    (
        'Peeling Químico',
        'peeling-quimico',
        'Renovación celular mediante la aplicación de ácidos que eliminan las capas superficiales de la piel, reduciendo manchas, líneas de expresión y mejorando la textura cutánea.',
        'Renovación celular para reducir manchas y líneas',
        45,
        18000.00,
        (SELECT id FROM categories WHERE slug = 'tratamientos-faciales'),
        TRUE,
        TRUE
    ),
    (
        'Hidratación Facial Intensiva',
        'hidratacion-facial-intensiva',
        'Tratamiento de hidratación profunda con ácido hialurónico y vitaminas. Aporta luminosidad, suavidad y elasticidad a la piel. Incluye mascarilla y masaje facial relajante.',
        'Hidratación profunda con ácido hialurónico',
        50,
        14500.00,
        (SELECT id FROM categories WHERE slug = 'tratamientos-faciales'),
        TRUE,
        TRUE
    ),
    (
        'Drenaje Linfático Corporal',
        'drenaje-linfatico-corporal',
        'Masaje especializado que estimula el sistema linfático para eliminar toxinas, reducir retención de líquidos y mejorar la circulación. Ideal para piernas cansadas y celulitis.',
        'Masaje para eliminar toxinas y reducir retención',
        75,
        16000.00,
        (SELECT id FROM categories WHERE slug = 'tratamientos-corporales'),
        FALSE,
        TRUE
    );

-- =====================================================
-- PRODUCTOS DE EJEMPLO
-- =====================================================

INSERT INTO products (name, slug, description, short_description, price, stock, category_id, is_featured, is_offer, is_trending, is_active) VALUES
    (
        'Serum Vitamina C - 30ml',
        'serum-vitamina-c-30ml',
        'Serum concentrado con vitamina C pura que aporta luminosidad, reduce manchas y protege contra el daño ambiental. Fórmula ligera de rápida absorción. Apto para todo tipo de piel.',
        'Ilumina y reduce manchas con vitamina C pura',
        8500.00,
        25,
        (SELECT id FROM categories WHERE slug = 'cuidado-facial'),
        TRUE,
        FALSE,
        TRUE,
        TRUE
    ),
    (
        'Crema Hidratante Ácido Hialurónico - 50ml',
        'crema-hidratante-acido-hialuronico-50ml',
        'Crema facial con triple acción: hidrata, rellena y suaviza. Contiene ácido hialurónico de diferentes pesos moleculares para una hidratación profunda y duradera.',
        'Hidratación profunda con ácido hialurónico',
        9800.00,
        30,
        (SELECT id FROM categories WHERE slug = 'cuidado-facial'),
        TRUE,
        FALSE,
        TRUE,
        TRUE
    ),
    (
        'Protector Solar FPS 50+ - 50ml',
        'protector-solar-fps-50-50ml',
        'Protección solar de amplio espectro UVA/UVB. Fórmula oil-free, no comedogénica. Resistente al agua. Textura ligera que no deja residuo blanco. Ideal para uso diario.',
        'Protección solar FPS 50+ sin residuo blanco',
        7200.00,
        40,
        (SELECT id FROM categories WHERE slug = 'cuidado-facial'),
        TRUE,
        TRUE,
        FALSE,
        TRUE
    ),
    (
        'Exfoliante Corporal Enzimático - 200ml',
        'exfoliante-corporal-enzimatico-200ml',
        'Exfoliante suave con enzimas de papaya y partículas de bambú. Elimina células muertas sin agredir la piel. Deja la piel suave, renovada y preparada para absorber tratamientos.',
        'Exfoliación suave con enzimas naturales',
        6500.00,
        20,
        (SELECT id FROM categories WHERE slug = 'cuidado-corporal'),
        FALSE,
        FALSE,
        TRUE,
        TRUE
    ),
    (
        'Aceite Corporal Nutritivo - 100ml',
        'aceite-corporal-nutritivo-100ml',
        'Blend de aceites naturales (rosa mosqueta, jojoba, vitamina E) que nutre profundamente la piel. Mejora la elasticidad y previene estrías. Ideal para masajes.',
        'Nutrición profunda con aceites naturales',
        8900.00,
        15,
        (SELECT id FROM categories WHERE slug = 'cuidado-corporal'),
        FALSE,
        TRUE,
        FALSE,
        TRUE
    );

-- =====================================================
-- CONFIGURACIÓN DEL SITIO
-- =====================================================

INSERT INTO app_config (config_key, config_value, description) VALUES
    -- Información del sitio
    ('site.name', 'Flavia Dermobeauty', 'Nombre del sitio web'),
    ('site.tagline', 'Belleza y Salud Dermatológica', 'Eslogan del sitio'),

    -- Contacto
    ('contact.email', 'contacto@flaviadermobeauty.com', 'Email de contacto'),
    ('contact.whatsapp', '+54 9 11 1234-5678', 'Número de WhatsApp'),
    ('contact.address', 'Av. Santa Fe 1234, CABA, Argentina', 'Dirección física del consultorio'),
    ('contact.phone', '+54 11 4567-8901', 'Teléfono fijo'),

    -- Costos
    ('delivery.fixed_cost', '1500.00', 'Costo fijo de envío a domicilio en ARS'),

    -- Textos del sitio (Hero)
    ('hero.title', 'Belleza que cuida tu piel', 'Título principal del hero'),
    ('hero.subtitle', 'Tratamientos dermatológicos profesionales y productos de alta calidad para realzar tu belleza natural', 'Subtítulo del hero'),
    ('hero.cta_text', 'Conocé nuestros tratamientos', 'Texto del botón CTA del hero'),

    -- Bio de Flavia
    ('bio.title', '¿Quién es Flavia?', 'Título de la sección bio'),
    ('bio.text', 'Soy Flavia, profesional en dermocosmiatría con más de 10 años de experiencia en el cuidado de la piel. Mi objetivo es ayudarte a sentirte bien con vos misma, brindándote tratamientos personalizados y productos de la más alta calidad. En mi consultorio, cada cliente es único y recibe atención especializada según sus necesidades.', 'Biografía de Flavia'),
    ('bio.credentials', 'Dermocosmiatrista matriculada • Especialista en tratamientos faciales • Certificada en peelings químicos', 'Credenciales profesionales'),

    -- Redes sociales
    ('social.instagram', 'https://instagram.com/flaviadermobeauty', 'URL de Instagram'),
    ('social.facebook', 'https://facebook.com/flaviadermobeauty', 'URL de Facebook'),
    ('social.tiktok', '', 'URL de TikTok (opcional)'),

    -- Horarios
    ('schedule.info', 'Lunes a Viernes: 9:00 - 19:00hs | Sábados: 9:00 - 13:00hs', 'Información de horarios de atención'),

    -- Políticas
    ('policy.cancellation', 'Las cancelaciones deben realizarse con al menos 24hs de anticipación. Caso contrario se cobrará el 50% del servicio.', 'Política de cancelación'),
    ('policy.returns', 'Aceptamos devoluciones de productos sin abrir dentro de los 15 días de la compra.', 'Política de devoluciones');

-- =====================================================
-- FIN DE DATOS INICIALES
-- =====================================================


========== FILE: ./src/main/resources/db/migration/V9__add_offer_price_columns.sql ==========
-- Add offer_price column to products table
ALTER TABLE products ADD COLUMN IF NOT EXISTS offer_price DECIMAL(10, 2);

-- Add offer_price and is_offer columns to services table
ALTER TABLE services ADD COLUMN IF NOT EXISTS offer_price DECIMAL(10, 2);
ALTER TABLE services ADD COLUMN IF NOT EXISTS is_offer BOOLEAN NOT NULL DEFAULT FALSE;


